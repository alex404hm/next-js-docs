---
title: Comparison
description: Comparison of Better Auth versus over other auth libraries and services.
---

> <p className="text-orange-400 dark:text-orange-200">Comparison is the thief of joy.</p>

Here are non detailed reasons why you may want to use Better Auth over other auth libraries and services.

### vs Other Auth Libraries

- **Framework agnostic** - Works with any framework, not just specific ones
- **Advanced features built-in** - 2FA, multi-tenancy, multi-session, rate limiting, and many more
- **Plugin system** - Extend functionality without forking or complex workarounds
- **Full control** - Customize auth flows exactly how you want
- **Flexible deployment** - Run alongside your app or as a standalone self-hosted auth server

### vs Managed Auth Services

- **Keep your data** - Users stay in your database, not a third-party service
- **No per-user costs** - Scale without worrying about auth billing
- **Single source of truth** - All user data in one place
- **Self-host anywhere** - Deploy on your own infrastructure with full control

### vs Rolling Your Own

- **Security handled** - Battle-tested auth flows and security practices
- **Focus on your product** - Spend time on features that matter to your business
- **Plugin extensibility** - Add custom features without starting from scratch
- **Production ready** - Works embedded in your app or as a dedicated auth server---
title: Commet
description: Better Auth Plugin for Billing and Subscriptions using Commet
---

[Commet](https://commet.co) is the billing and payments solution for SaaS and AI products. As a Merchant of Record, Commet handles subscriptions, usage-based billing, tax compliance, and global payments—so you can start monetizing in minutes.

<Callout>
  This plugin is maintained by the Commet team. For bugs, issues or feature requests,
  please contact [Commet support](https://commet.co).
</Callout>

## Features

- Automatic customer creation on signup
- Customer Portal for self-service billing management
- Subscription management (get, change plan, cancel)
- Feature access control (boolean, metered, seats)
- Usage tracking for metered billing
- Seat management for per-user pricing
- Optional webhook handling with signature verification

## Installation

```bash
pnpm add better-auth @commet/better-auth @commet/node
```

## Preparation

Get your API key from the [Commet dashboard](https://sandbox.commet.co).

```bash title=".env"
COMMET_API_KEY=ck_...
COMMET_ENVIRONMENT=sandbox # or production
```

## Server Configuration

```typescript title="auth.ts"
import { betterAuth } from "better-auth";
import {
  commet,
  portal,
  subscriptions,
  features,
  usage,
  seats,
} from "@commet/better-auth";
import { Commet } from "@commet/node";

const commetClient = new Commet({
  apiKey: process.env.COMMET_API_KEY,
  environment: process.env.COMMET_ENVIRONMENT, // 'sandbox' or 'production'
});

export const auth = betterAuth({
  // ... your config
  plugins: [
    commet({
      client: commetClient,
      createCustomerOnSignUp: true,
      use: [
        portal(),
        subscriptions(),
        features(),
        usage(),
        seats(),
      ],
    }),
  ],
});
```

## Client Configuration

```typescript title="auth-client.ts"
import { createAuthClient } from "better-auth/react";
import { commetClient } from "@commet/better-auth";

export const authClient = createAuthClient({
  plugins: [commetClient()],
});
```

## Configuration Options

```typescript
commet({
  client: commetClient,                    // Required: Commet SDK instance
  createCustomerOnSignUp: true,            // Auto-create customer on signup
  getCustomerCreateParams: ({ user }) => ({
    legalName: user.name,
    metadata: { source: "web" },
  }),
  use: [/* plugins */],
})
```

When `createCustomerOnSignUp` is enabled, a Commet customer is automatically created with `externalId` set to the user's ID. No database mapping required.

## Portal Plugin

Redirects users to the Commet customer portal for self-service billing management.

```typescript title="Server"
import { commet, portal } from "@commet/better-auth";

commet({
  client: commetClient,
  use: [
    portal({ returnUrl: "/dashboard" }),
  ],
})
```

```typescript title="Client"
// Redirects to Commet customer portal
await authClient.customer.portal();
```

## Subscriptions Plugin

Manage customer subscriptions.

```typescript title="Server"
import { commet, subscriptions } from "@commet/better-auth";

commet({
  client: commetClient,
  use: [subscriptions()],
})
```

```typescript title="Client"
// Get current subscription
const { data: subscription } = await authClient.subscription.get();

// Change plan
await authClient.subscription.changePlan({
  subscriptionId: "sub_xxx",
  planCode: "enterprise",
  billingInterval: "yearly",
});

// Cancel subscription
await authClient.subscription.cancel({
  subscriptionId: "sub_xxx",
  reason: "Too expensive",
  immediate: false, // Cancel at period end
});
```

## Features Plugin

Check feature access for the authenticated user.

```typescript title="Server"
import { commet, features } from "@commet/better-auth";

commet({
  client: commetClient,
  use: [features()],
})
```

```typescript title="Client"
// List all features
const { data: featuresList } = await authClient.features.list();

// Get specific feature
const { data: feature } = await authClient.features.get("api_calls");

// Check if feature is enabled (boolean)
const { data: check } = await authClient.features.check("sso");

// Check if user can use one more unit (metered)
const { data: canUse } = await authClient.features.canUse("api_calls");
// Returns: { allowed: boolean, willBeCharged: boolean }
```

## Usage Plugin

Track usage events for metered billing.

```typescript title="Server"
import { commet, usage } from "@commet/better-auth";

commet({
  client: commetClient,
  use: [usage()],
})
```

```typescript title="Client"
await authClient.usage.track({
  eventType: "api_call",
  value: 1,
  idempotencyKey: `evt_${Date.now()}`,
  properties: { endpoint: "/api/generate" },
});
```

The authenticated user is automatically associated with the event.

## Seats Plugin

Manage seat-based licenses.

```typescript title="Server"
import { commet, seats } from "@commet/better-auth";

commet({
  client: commetClient,
  use: [seats()],
})
```

```typescript title="Client"
// List all seat balances
const { data: seatBalances } = await authClient.seats.list();

// Add seats
await authClient.seats.add({ seatType: "member", count: 5 });

// Remove seats
await authClient.seats.remove({ seatType: "member", count: 2 });

// Set exact count
await authClient.seats.set({ seatType: "admin", count: 3 });

// Set all seat types at once
await authClient.seats.setAll({ admin: 2, member: 10, viewer: 50 });
```

## Webhooks Plugin (Optional)

Handle Commet webhooks. This is optional since you can always query state directly.

```typescript title="Server"
import { commet, webhooks } from "@commet/better-auth";

commet({
  client: commetClient,
  use: [
    webhooks({
      secret: process.env.COMMET_WEBHOOK_SECRET,
      onPayload: (payload) => {
        // Catch-all handler
      },
      onSubscriptionCreated: (payload) => {},
      onSubscriptionActivated: (payload) => {},
      onSubscriptionCanceled: (payload) => {},
      onSubscriptionUpdated: (payload) => {},
    }),
  ],
})
```

Configure the webhook endpoint in your Commet dashboard: `/api/auth/commet/webhooks`

## Full Example

```typescript title="auth.ts"
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import {
  commet as commetPlugin,
  portal,
  subscriptions,
  features,
  usage,
  seats,
} from "@commet/better-auth";
import { Commet } from "@commet/node";
import { db } from "./db";
import * as schema from "./schema";

const commetClient = new Commet({
  apiKey: process.env.COMMET_API_KEY!,
  environment: process.env.COMMET_ENVIRONMENT as "sandbox" | "production",
});

export const auth = betterAuth({
  database: drizzleAdapter(db, { provider: "pg", schema }),
  emailAndPassword: { enabled: true },
  plugins: [
    commetPlugin({
      client: commetClient,
      createCustomerOnSignUp: true,
      getCustomerCreateParams: ({ user }) => ({
        legalName: user.name,
      }),
      use: [
        portal({ returnUrl: "/dashboard" }),
        subscriptions(),
        features(),
        usage(),
        seats(),
      ],
    }),
  ],
});
```

```typescript title="auth-client.ts"
import { createAuthClient } from "better-auth/react";
import { commetClient } from "@commet/better-auth";

export const authClient = createAuthClient({
  baseURL: process.env.NEXT_PUBLIC_BETTER_AUTH_URL,
  plugins: [commetClient()],
});

export const { signIn, signUp, signOut, useSession } = authClient;
```

```tsx title="dashboard.tsx"
"use client";

import { authClient } from "@/lib/auth-client";

export function BillingSection() {
  const handlePortal = async () => {
    await authClient.customer.portal();
  };

  const checkFeature = async () => {
    const { data } = await authClient.features.canUse("api_calls");
    if (data?.allowed) {
      // Proceed with action
      await authClient.usage.track({ eventType: "api_call" });
    }
  };

  return (
    <div>
      <button onClick={handlePortal}>Manage Billing</button>
      <button onClick={checkFeature}>Use Feature</button>
    </div>
  );
}
```

---
title: Generic OAuth
description: Authenticate users with any OAuth provider
---

The Generic OAuth plugin provides a flexible way to integrate authentication with any OAuth provider. It supports both OAuth 2.0 and OpenID Connect (OIDC) flows, allowing you to easily add social login or custom OAuth authentication to your application.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To use the Generic OAuth plugin, add it to your auth config.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { genericOAuth } from "better-auth/plugins" // [!code highlight]

    export const auth = betterAuth({
        // ... other config options
        plugins: [
            genericOAuth({ // [!code highlight]
                config: [ // [!code highlight]
                    { // [!code highlight]
                        providerId: "provider-id", // [!code highlight]
                        clientId: "test-client-id", // [!code highlight]
                        clientSecret: "test-client-secret", // [!code highlight]
                        discoveryUrl: "https://auth.example.com/.well-known/openid-configuration", // [!code highlight]
                        // ... other config options // [!code highlight]
                    }, // [!code highlight]
                    // Add more providers as needed // [!code highlight]
                ] // [!code highlight]
            }) // [!code highlight]
        ]
    })
    ```
  </Step>

  <Step>
    ### Add the client plugin

    Include the Generic OAuth client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { genericOAuthClient } from "better-auth/client/plugins" // [!code highlight]

    export const authClient = createAuthClient({
        plugins: [
            genericOAuthClient() // [!code highlight]
        ]
    })
    ```
  </Step>
</Steps>

## Usage

The Generic OAuth plugin provides endpoints for initiating the OAuth flow and handling the callback. Here's how to use them:

### Initiate OAuth Sign-In

To start the OAuth sign-in process:

<APIMethod path="/sign-in/oauth2" method="POST">
```ts
type signInWithOAuth2 = {
    /**
     * The provider ID for the OAuth provider. 
     */
    providerId: string = "provider-id"
    /**
     * The URL to redirect to after sign in. 
     */
    callbackURL?: string = "/dashboard"
    /**
     * The URL to redirect to if an error occurs. 
     */
    errorCallbackURL?: string = "/error-page"
    /**
     * The URL to redirect to after login if the user is new. 
     */
    newUserCallbackURL?: string = "/welcome"
    /**
     * Disable redirect. 
     */
    disableRedirect?: boolean = false
    /**
     * Scopes to be passed to the provider authorization request. 
     */
    scopes?: string[] = ["my-scope"]
    /**
     * Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. 
     */
    requestSignUp?: boolean = false
}
```
</APIMethod>

### Linking OAuth Accounts

To link an OAuth account to an existing user:

<APIMethod
  path="/oauth2/link"
  method="POST"
  requireSession
>
```ts
type oAuth2LinkAccount = {
    /**
     * The OAuth provider ID. 
     */
    providerId: string = "my-provider-id"
    /**
     * The URL to redirect to once the account linking was complete. 
     */
    callbackURL: string = "/successful-link"
}
```
</APIMethod>

### Handle OAuth Callback

The plugin mounts a route to handle the OAuth callback `/oauth2/callback/:providerId`. This means by default `${baseURL}/api/auth/oauth2/callback/:providerId` will be used as the callback URL. Make sure your OAuth provider is configured to use this URL.

## Pre-configured Provider Helpers

Better Auth provides pre-configured helper functions for popular OAuth providers. These helpers handle the provider-specific configuration, including discovery URLs and user info endpoints.

### Supported Providers

- **Auth0** - `auth0(options)`
- **HubSpot** - `hubspot(options)`
- **Keycloak** - `keycloak(options)`
- **LINE** - `line(options)`
- **Microsoft Entra ID (Azure AD)** - `microsoftEntraId(options)`
- **Okta** - `okta(options)`
- **Slack** - `slack(options)`
- **Patreon** - `patreon(options)`

### Example: Using Pre-configured Providers

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import {
	// genericOAuth plugin
	genericOAuth,
	// providers
	auth0,
	gumroad,
	hubspot,
	keycloak,
	line,
	microsoftEntraId,
	okta,
	slack,
	patreon,
} from 'better-auth/plugins';

export const auth = betterAuth({
	plugins: [
		genericOAuth({
			config: [
				auth0({
					clientId: process.env.AUTH0_CLIENT_ID,
					clientSecret: process.env.AUTH0_CLIENT_SECRET,
					domain: process.env.AUTH0_DOMAIN,
				}),
				gumroad({
					clientId: process.env.GUMROAD_CLIENT_ID,
					clientSecret: process.env.GUMROAD_CLIENT_SECRET,
				}),
				hubspot({
					clientId: process.env.HUBSPOT_CLIENT_ID,
					clientSecret: process.env.HUBSPOT_CLIENT_SECRET,
					scopes: ['oauth', 'contacts'],
				}),
				keycloak({
					clientId: process.env.KEYCLOAK_CLIENT_ID,
					clientSecret: process.env.KEYCLOAK_CLIENT_SECRET,
					issuer: process.env.KEYCLOAK_ISSUER,
				}),
				// LINE supports multiple channels (countries) - use different providerIds
				line({
					providerId: 'line-jp',
					clientId: process.env.LINE_JP_CLIENT_ID,
					clientSecret: process.env.LINE_JP_CLIENT_SECRET,
				}),
				line({
					providerId: 'line-th',
					clientId: process.env.LINE_TH_CLIENT_ID,
					clientSecret: process.env.LINE_TH_CLIENT_SECRET,
				}),
				microsoftEntraId({
					clientId: process.env.MS_APP_ID,
					clientSecret: process.env.MS_CLIENT_SECRET,
					tenantId: process.env.MS_TENANT_ID,
				}),
				okta({
					clientId: process.env.OKTA_CLIENT_ID,
					clientSecret: process.env.OKTA_CLIENT_SECRET,
					issuer: process.env.OKTA_ISSUER,
				}),
				slack({
					clientId: process.env.SLACK_CLIENT_ID,
					clientSecret: process.env.SLACK_CLIENT_SECRET,
				}),
				patreon({
					clientId: process.env.PATREON_CLIENT_ID,
					clientSecret: process.env.PATREON_CLIENT_SECRET,
				}),
			],
		}),
	],
});
```

Each provider helper accepts common OAuth options (extending `BaseOAuthProviderOptions`) plus provider-specific fields:

- **Auth0**: Requires `domain` (e.g., `dev-xxx.eu.auth0.com`)
- **HubSpot**: No additional required fields. Optional `scopes` (defaults to `["oauth"]`)
- **Keycloak**: Requires `issuer` (e.g., `https://my-domain/realms/MyRealm`)
- **LINE**: Optional `providerId` (defaults to `"line"`). LINE requires separate channels for different countries (Japan, Thailand, Taiwan, etc.), so you can call `line()` multiple times with different `providerId`s and credentials to support multiple countries
- **Microsoft Entra ID**: Requires `tenantId` (can be a GUID, `"common"`, `"organizations"`, or `"consumers"`)
- **Okta**: Requires `issuer` (e.g., `https://dev-xxxxx.okta.com/oauth2/default`)
- **Slack**: No additional required fields
- **Patreon**: No additional required fields

All providers support the same optional fields:
- `scopes?: string[]` - Array of OAuth scopes to request
- `redirectURI?: string` - Custom redirect URI
- `pkce?: boolean` - Enable PKCE (defaults to `false`)
- `disableImplicitSignUp?: boolean` - Disable automatic sign-up for new users
- `disableSignUp?: boolean` - Disable sign-up entirely
- `overrideUserInfo?: boolean` - Override user info on sign in

## Configuration

When adding the plugin to your auth config, you can configure multiple OAuth providers. You can either use the pre-configured provider helpers (shown above) or create custom configurations manually.

### Manual Configuration

Each provider configuration object supports the following options:

```ts
interface GenericOAuthConfig {
  providerId: string;
  discoveryUrl?: string;
  issuer?: string;
  requireIssuerValidation?: boolean;
  authorizationUrl?: string;
  tokenUrl?: string;
  userInfoUrl?: string;
  clientId: string;
  clientSecret: string;
  scopes?: string[];
  redirectURI?: string;
  responseType?: string;
  prompt?: string;
  pkce?: boolean;
  accessType?: string;
  getUserInfo?: (tokens: OAuth2Tokens) => Promise<User | null>;
}
```

### Other Provider Configurations

**providerId**: A unique string to identify the OAuth provider configuration.

**discoveryUrl**: (Optional) URL to fetch the provider's OAuth 2.0/OIDC configuration. If provided, endpoints like `authorizationUrl`, `tokenUrl`, and `userInfoUrl` can be auto-discovered.

**issuer**: (Optional) The expected issuer identifier for validation. If not provided but `discoveryUrl` is set, it will be fetched from the discovery document. When set, the callback validates that the `iss` parameter matches this value.

**requireIssuerValidation**: (Optional) When `true`, requires the `iss` parameter in callbacks if an issuer is configured. This provides stricter security but may break with older OAuth servers. Defaults to `false`.

**authorizationUrl**: (Optional) The OAuth provider's authorization endpoint. Not required if using `discoveryUrl`.

**tokenUrl**: (Optional) The OAuth provider's token endpoint. Not required if using `discoveryUrl`.

**userInfoUrl**: (Optional) The endpoint to fetch user profile information. Not required if using `discoveryUrl`.

**clientId**: The OAuth client ID issued by your provider.

**clientSecret**: The OAuth client secret issued by your provider.

**scopes**: (Optional) An array of scopes to request from the provider (e.g., `["openid", "email", "profile"]`).

**redirectURI**: (Optional) The redirect URI to use for the OAuth flow. If not set, a default is constructed based on your app's base URL.

**responseType**: (Optional) The OAuth response type. Defaults to `"code"` for authorization code flow.

**responseMode**: (Optional) The response mode for the authorization code request, such as `"query"` or `"form_post"`.

**prompt**: (Optional) Controls the authentication experience (e.g., force login, consent, etc.).

**pkce**: (Optional) If true, enables PKCE (Proof Key for Code Exchange) for enhanced security. Defaults to `false`.


**accessType**: (Optional) The access type for the authorization request. Use `"offline"` to request a refresh token.

**getToken**: (Optional) A custom function to exchange authorization code for tokens. If provided, this function will be used instead of the default token exchange logic. This is useful for providers with non-standard token endpoints that use GET requests or custom parameters.

**getUserInfo**: (Optional) A custom function to fetch user info from the provider, given the OAuth tokens. If not provided, a default fetch is used.

**mapProfileToUser**: (Optional) A function to map the provider's user profile to your app's user object. Useful for custom field mapping or transformations.

**authorizationUrlParams**: (Optional) Additional query parameters to add to the authorization URL. These can override default parameters. You can also provide a function that returns the parameters.

**tokenUrlParams**: (Optional) Additional query parameters to add to the token URL. These can override default parameters. You can also provide a function that returns the parameters.

**disableImplicitSignUp**: (Optional) If true, disables automatic sign-up for new users. Sign-in must be explicitly requested with sign-up intent.

**disableSignUp**: (Optional) If true, disables sign-up for new users entirely. Only existing users can sign in.

**authentication**: (Optional) The authentication method for token requests. Can be `'basic'` or `'post'`. Defaults to `'post'`.

**discoveryHeaders**: (Optional) Custom headers to include in the discovery request. Useful for providers that require special headers.

**authorizationHeaders**: (Optional) Custom headers to include in the authorization request. Useful for providers that require special headers.

**overrideUserInfo**: (Optional) If true, the user's info in your database will be updated with the provider's info every time they sign in. Defaults to `false`.

## Security: Issuer Validation

Better Auth validates the OAuth provider's issuer to protect against mix-up attacks ([RFC 9207](https://datatracker.ietf.org/doc/html/rfc9207)). A mix-up attack occurs when a malicious authorization server tricks your application into sending an authorization code to the wrong token endpoint.

### How It Works

When an OAuth provider supports RFC 9207, it includes an `iss` (issuer) parameter in the authorization response. Better Auth validates this parameter against the expected issuer to ensure the response came from the intended provider.

### Configuration Examples

**Auto-discovery (recommended for OIDC providers):**
```ts
genericOAuth({
  config: [{
    providerId: "my-provider",
    discoveryUrl: "https://auth.example.com/.well-known/openid-configuration",
    clientId: "...",
    clientSecret: "...",
    // issuer is automatically fetched from discovery document
  }]
})
```

**Manual issuer configuration:**
```ts
genericOAuth({
  config: [{
    providerId: "custom-oauth",
    authorizationUrl: "https://auth.example.com/authorize",
    tokenUrl: "https://auth.example.com/token",
    issuer: "https://auth.example.com",  // manually specify expected issuer
    clientId: "...",
    clientSecret: "...",
  }]
})
```

**Strict mode (recommended for modern providers):**
```ts
genericOAuth({
  config: [{
    providerId: "secure-provider",
    discoveryUrl: "https://auth.example.com/.well-known/openid-configuration",
    clientId: "...",
    clientSecret: "...",
    requireIssuerValidation: true,  // reject if iss parameter is missing
  }]
})
```

### Validation Behavior

| Scenario | `requireIssuerValidation` | Result |
|----------|---------------------------|--------|
| `iss` matches expected | - | Success |
| `iss` doesn't match | - | `issuer_mismatch` error |
| `iss` missing | `false` (default) | Success (backward compatible) |
| `iss` missing | `true` | `issuer_missing` error |

<Callout>
For maximum security with modern OAuth/OIDC providers (Google, Auth0, Okta, etc.), we recommend enabling `requireIssuerValidation: true`.
</Callout>

## Advanced Usage

### Custom Token Exchange

For providers with non-standard token endpoints that use GET requests or custom parameters, you can provide a custom `getToken` function:

```ts
genericOAuth({
  config: [
    {
      providerId: "custom-provider",
      clientId: process.env.CUSTOM_CLIENT_ID!,
      clientSecret: process.env.CUSTOM_CLIENT_SECRET,
      authorizationUrl: "https://provider.example.com/oauth/authorize",
      scopes: ["profile", "email"],
      // Custom token exchange for non-standard endpoints
      getToken: async ({ code, redirectURI }) => {
        // Example: GET request instead of POST
        const response = await fetch(
          `https://provider.example.com/oauth/token?` +
          `client_id=${process.env.CUSTOM_CLIENT_ID}&` +
          `client_secret=${process.env.CUSTOM_CLIENT_SECRET}&` +
          `code=${code}&` +
          `redirect_uri=${redirectURI}&` +
          `grant_type=authorization_code`,
          { method: "GET" }
        );

        const data = await response.json();

        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          accessTokenExpiresAt: new Date(Date.now() + data.expires_in * 1000),
          scopes: data.scope?.split(" ") ?? [],
          // Preserve provider-specific fields in raw
          raw: data,
        };
      },
      getUserInfo: async (tokens) => {
        // Access provider-specific fields from raw token data
        const userId = tokens.raw?.user_id as string;

        const response = await fetch(
          `https://provider.example.com/api/user?` +
          `access_token=${tokens.accessToken}`
        );

        const data = await response.json();

        return {
          id: userId,
          name: data.display_name,
          email: data.email,
          image: data.avatar_url,
          emailVerified: data.email_verified,
        };
      },
    },
  ],
});
```

### Custom User Info Fetching

You can provide a custom `getUserInfo` function to handle specific provider requirements:

```ts
genericOAuth({
  config: [
    {
      providerId: "custom-provider",
      // ... other config options
      getUserInfo: async (tokens) => {
        // Custom logic to fetch and return user info
        const userInfo = await fetchUserInfoFromCustomProvider(tokens);
        return {
          id: userInfo.sub,
          email: userInfo.email,
          name: userInfo.name,
          // ... map other fields as needed
        };
      }
    }
  ]
})
```

### Map User Info Fields

If the user info returned by the provider does not match the expected format, or you need to map additional fields, you can use the `mapProfileToUser`:

```ts
genericOAuth({
  config: [
    {
      providerId: "custom-provider",
      // ... other config options
      mapProfileToUser: async (profile) => {
        return {
          firstName: profile.given_name,
          // ... map other fields as needed
        };
      }
    }
  ]
})
```

### Accessing Raw Token Data

The `tokens` parameter includes a `raw` field that preserves the original token response from the provider. This is useful for accessing provider-specific fields:

```ts
getUserInfo: async (tokens) => {
  // Access provider-specific fields
  const customField = tokens.raw?.custom_provider_field as string;
  const userId = tokens.raw?.provider_user_id as string;

  // Use in your logic
  return {
    id: userId,
    // ...
  };
}
```

### Error Handling

The plugin includes built-in error handling for common OAuth issues. Errors are typically redirected to your application's error page with an appropriate error message in the URL parameters. If the callback URL is not provided, the user will be redirected to Better Auth's default error page.
---
title: System for Cross-domain Identity Management (SCIM)
description: Integrate SCIM with your application.
---

System for Cross-domain Identity Management ([SCIM](https://simplecloud.info/#Specification)) makes managing identities in multi-domain scenarios easier to support via a standardized protocol.
This plugin exposes a [SCIM](https://simplecloud.info/#Specification) server that allows third party identity providers to sync identities to your service.

## Installation

<Steps>
    <Step>
        ### Install the plugin

        ```package-install
        @better-auth/scim
        ```
    </Step>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { scim } from "@better-auth/scim"; // [!code highlight]

        const auth = betterAuth({
            plugins: [
                scim() // [!code highlight]
            ]
        })
        ```
    </Step>
    <Step>
        ### Enable HTTP methods

        SCIM requires the `POST`, `GET`, `PUT`, `PATCH` and `DELETE` HTTP methods to be supported by your server.
        For most frameworks, this will work out of the box, but some frameworks may require additional configuration:

        <Tabs items={["Next.js", "Solid Start"]}>
            <Tab value="Next.js">
            ```ts title="api/auth/[...all]/route.ts"
            import { auth } from "@/lib/auth";
            import { toNextJsHandler } from "better-auth/next-js";

            export const { POST, GET, PUT, PATCH, DELETE } = toNextJsHandler(auth); // [!code highlight]
            ```
            </Tab>
            <Tab value="Solid Start">
            ```ts title="routes/api/auth/*auth.ts"
            import { auth } from "~/lib/auth";
            import { toSolidStartHandler } from "better-auth/solid-start";

            export const { GET, POST, PUT, PATCH, DELETE } = toSolidStartHandler(auth); // [!code highlight]
            ```
            </Tab>
        </Tabs>
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
</Steps>

## Usage

Upon registration, this plugin will expose compliant [SCIM 2.0](https://simplecloud.info/#Specification) server. Generally, this server is meant to be consumed by a third-party (your identity provider), and will require a:

- **SCIM base URL**: This should be the fully qualified URL to the SCIM server (e.g `http://your-app.com/api/auth/scim/v2`)
- **SCIM bearer token**: See [generating a SCIM token](#generating-a-scim-token)

### Generating a SCIM token

Before your identity provider can start syncing information to your SCIM server,
you need to generate a SCIM token that your identity provider will use to authenticate against it.

A SCIM token is a simple bearer token that you can generate:

<APIMethod path="/scim/generate-token" method="POST" requireSession>
```ts
type generateSCIMToken = {
  /**
  * The provider id
  */
  providerId: string = "acme-corp"
  /**
   * Optional organization id. When specified, the organizations plugin must also be enabled
  */
  organizationId?: string = "the-org"
}
```
</APIMethod>

A `SCIM` token is always restricted to a provider, thus you are required to specify a `providerId`. This can be any provider your instance supports (e.g one of the built-in providers such as `credentials` or an external provider registered through an external plugin such as `@better-auth/sso`).
Additionally, when the `organization` plugin is registered, you can optionally restrict the token to an organization via the `organizationId`.

<Callout>
**Important:** By default, any authenticated user with access to your better-auth instance will be able to generate a SCIM token. This can be an important security risk to your application, especially in multi-tenant scenarios.
It is highly recommended that you implement [hooks](#hooks) to restrict this access to certain roles or users:
</Callout>

```ts
const userRoles = new Set(["admin"]);
const userAdminIds = new Set(["some-admin-user-id"]);

scim({
    beforeSCIMTokenGenerated: async ({ user, member, scimToken }) => {
        // IMPORTANT: Use this hook to restrict access to certain roles or users
        // At the very least access must be restricted to admin users (see example below)

        const userHasAdmin = member?.role && userRoles.has(member.role);
        const userIsAdmin = userAdminIds.size > 0 && userAdminIds.has(user.id);

        if (!userHasAdmin && !userIsAdmin) {
            throw new APIError("FORBIDDEN", { message: "User does not have enough permissions" });
        }
    },
})
```

See the [hooks](#hooks) documentation for more details about supported hooks.

#### Default SCIM token

We also provide a way for you to specify a `SCIM` token to use by default. This allows you to test a SCIM connection without setting up providers in the database:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { scim } from "@better-auth/scim"; 

const auth = betterAuth({
    plugins: [
        scim({
            defaultSCIM: [
                {
                    providerId: "default-scim", // ID of the existing provider you want to provision
                    scimToken: "some-scim-token", // SCIM plain token
                    organizationId: "the-org" // Optional organization id
                }
            ]
        })
    ]
});
```

<Callout type="info">
**Important**: Please note that you must base64 encode your `scimToken` before you try to use as follows: `base64(scimToken:providerId[:organizationId])`.

In our example above, you would need to encode the `some-scim-token:default-scim:the-org` text to base64, resulting in the following scimToken: `c29tZS1zY2ltLXRva2VuOmRlZmF1bHQtc2NpbTp0aGUtb3Jn`
</Callout>

### SCIM provider connection ownership

SCIM provider connection ownership allows your application to track and restrict access to the SCIM management endpoints
by linking each connection to the user who generated the token.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { scim } from "@better-auth/scim";

const auth = betterAuth({
    plugins: [
        scim({ // [!code highlight]
            providerOwnership: { // [!code highlight]
                enabled: true // [!code highlight]
            } // [!code highlight]
        }) // [!code highlight]
    ]
});
```

Once enabled, make sure you migrate the database schema (again).

<Tabs items={["migrate", "generate"]}>
    <Tab value="migrate">
    ```bash
    npx @better-auth/cli migrate
    ```
    </Tab>
    <Tab value="generate">
    ```bash
    npx @better-auth/cli generate
    ```
    </Tab>
</Tabs>

See the [Schema](#if-you-have-provider-ownership-enabled-via-providerownershipenabled) section to add the fields manually.


### Managing SCIM provider connections

You can manage SCIM provider connections from your application using the following endpoints:

#### List SCIM provider connections

List existing connections for organizations the current user is a member of or providers that are not associated to an organization.

<APIMethod path="/scim/list-provider-connections" method="GET" requireSession>
```ts
type listSCIMProviderConnections = {
}
```
</APIMethod>

#### Get SCIM provider connection details

Get a single connection by id. Access is allowed only if the user is a member of the connection's organization or the connection is not associated to an organization.

<APIMethod path="/scim/get-provider-connection" method="GET" requireSession>
```ts
type getSCIMProviderConnection = {
  /**
   * Unique provider identifier
   */
  providerId: string = "acme-corp"
}
```
</APIMethod>

#### Delete SCIM provider connection

Delete an existing connection. This will immediately invalidate the connection's associated token.

<APIMethod path="/scim/delete-provider-connection" method="POST" requireSession>
```ts
type deleteSCIMProviderConnection = {
  /**
   * Unique provider identifier
   */
  providerId: string = "acme-corp"
}
```
</APIMethod>

### SCIM endpoints

The following subset of the specification is currently supported:

#### List users

Get a list of available users in the database. This is restricted to list only users associated to the same provider and organization than your SCIM token.

<APIMethod path="/scim/v2/Users" method="GET" requireBearerToken isExternalOnly note="Returns the provisioned SCIM user details. See https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.1">
```ts
type listSCIMUsers = {
    /**
     * SCIM compliant filter expression
    */
    filter?: string = 'userName eq "user-a"'
}
```
</APIMethod>

#### Get user

Get an user from the database. The user will be only returned if it belongs to the same provider and organization than the SCIM token.

<APIMethod path="/scim/v2/Users/:userId" method="GET" forceAsParam requireBearerToken isExternalOnly note="Returns the provisioned SCIM user details. See https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.1">
```ts
type getSCIMUser = {
    /**
     * Unique user identifier
    */
    userId: string = "user id"
}
```
</APIMethod>

#### Create new user

Provisions a new user to the database. The user will have an account associated to the same provider and will be member of the same org than the SCIM token.

<APIMethod path="/scim/v2/Users" method="POST" requireBearerToken isExternalOnly note="Provision a new user via SCIM. See https://datatracker.ietf.org/doc/html/rfc7644#section-3.3">
```ts
type createSCIMUser = {
    /*
     * Unique external (third party) identifier
    */
    externalId?: string = "third party id"
    /**
     * User name details
    */
    name?: {
        /**
         * Formatted name (takes priority over given and family name)
        */
        formatted?: string = "Daniel Perez"
        /**
         * Given name
        */
        givenName?: string = "Daniel"
        /**
         * Family name
        */
        familyName?: string = "Perez"
    }
    /**
     * List of emails associated to the user, only a single email can be primary
    */
    emails?: Array<{ value: string, primary?: boolean }> = [{ value: "daniel@email.com", primary: true }]
}
```
</APIMethod>

#### Update an existing user

Replaces an existing user details in the database. This operation can only update users that belong to the same provider and organization than the SCIM token.

<APIMethod path="/scim/v2/Users/:userId" method="PUT" requireBearerToken isExternalOnly note="Updates an existing user via SCIM. See https://datatracker.ietf.org/doc/html/rfc7644#section-3.3">
```ts
type updateSCIMUser = {
    /*
     * Unique external (third party) identifier
    */
    externalId?: string = "third party id"
    /**
     * User name details
    */
    name?: {
        /**
         * Formatted name (takes priority over given and family name)
        */
        formatted?: string = "Daniel Perez"
        /**
         * Given name
        */
        givenName?: string = "Daniel"
        /**
         * Family name
        */
        familyName?: string = "Perez"
    }
    /**
     * List of emails associated to the user, only a single email can be primary
    */
    emails?: Array<{ value: string, primary?: boolean }> = [{ value: "daniel@email.com", primary: true }]
}
```
</APIMethod>

#### Partial update an existing user

Allows to apply a partial update to the user details. This operation can only update users that belong to the same provider and organization than the SCIM token.

<APIMethod path="/scim/v2/Users/:userId" method="PATCH" requireBearerToken isExternalOnly note="Partially updates a user resource. See https://datatracker.ietf.org/doc/html/rfc7644#section-3.5.2">
```ts
type patchSCIMUser = {
    /**
     * Mandatory schema declaration
    */
    schemas: string[] = ["urn:ietf:params:scim:api:messages:2.0:PatchOp"]
    /**
     * List of JSON patch operations
    */
    Operations: Array<{ op: "replace" | "add" | "remove", path?: string, value: any }> = [{ op: "replace", path: "/userName", value: "any value" }]
}
```
</APIMethod>

#### Deletes a user resource

Completely deletes a user resource from the database. This operation can only delete users that belong to the same provider and organization than the SCIM token.

<APIMethod path="/scim/v2/Users/:userId" method="DELETE" forceAsParam requireBearerToken isExternalOnly note="Deletes an existing user resource. See https://datatracker.ietf.org/doc/html/rfc7644#section-3.6">
```ts
type deleteSCIMUser = {
    userId: string
}
```
</APIMethod>

#### Get service provider config

Get SCIM metadata describing supported features of this server.

<APIMethod path="/scim/v2/ServiceProviderConfig" method="GET" isExternalOnly note="Standard SCIM metadata endpoint used by identity providers. See https://datatracker.ietf.org/doc/html/rfc7644#section-4">
```ts
type getSCIMServiceProviderConfig = {
}
```
</APIMethod>

#### Get SCIM schemas

Get the list of supported SCIM schemas.

<APIMethod path="/scim/v2/Schemas" method="GET" isExternalOnly note="Standard SCIM metadata endpoint used by identity providers to acquire information about supported schemas. See https://datatracker.ietf.org/doc/html/rfc7644#section-4">
```ts
type getSCIMSchemas = {
}
```
</APIMethod>

#### Get SCIM schema

Get the details of a supported SCIM schema.

<APIMethod path="/scim/v2/Schemas/:schemaId" method="GET" isExternalOnly note="Standard SCIM metadata endpoint used by identity providers to acquire information about a given schema. See https://datatracker.ietf.org/doc/html/rfc7644#section-4">
```ts
type getSCIMSchema = {
}
```
</APIMethod>

#### Get SCIM resource types

Get the list of supported SCIM types.

<APIMethod path="/scim/v2/ResourceTypes" method="GET" isExternalOnly note="Standard SCIM metadata endpoint used by identity providers to get a list of server supported types. See https://datatracker.ietf.org/doc/html/rfc7644#section-4">
```ts
type getSCIMResourceTypes = {
}
```
</APIMethod>

#### Get SCIM resource type

Get the details of a supported SCIM resource type.

<APIMethod path="/scim/v2/ResourceTypes/:resourceTypeId" method="GET" isExternalOnly note="Standard SCIM metadata endpoint used by identity providers to get a server supported type. See https://datatracker.ietf.org/doc/html/rfc7644#section-4">
```ts
type getSCIMResourceType = {
}
```
</APIMethod>

#### SCIM attribute mapping

By default, the SCIM provisioning will automatically map the following fields:

- `user.email`: User primary email or the first available email if there is not a primary one
- `user.name`: Derived from `name` (`name.formatted` or `name.givenName` + `name.familyName`) and fallbacks to the user primary email
- `account.providerId`: Provider associated to the `SCIM` token
- `account.accountId`: Defaults to `externalId` and fallbacks to `userName`
- `member.organizationId`: Organization associated to the provider

## Schema

The plugin requires additional fields in the `scimProvider` table to store the provider's configuration.

<DatabaseTable
    fields={[
        {
            name: "id", type: "string", description: "A database identifier", isRequired: true, isPrimaryKey: true,
        },
        { name: "providerId", type: "string", description: "The provider ID. Used to identify a provider and to generate a redirect URL.", isRequired: true, isUnique: true },
        { name: "scimToken", type: "string", description: "The SCIM bearer token. Used by your identity provider to authenticate against your server", isRequired: true, isUnique: true },
        { name: "organizationId", type: "string", description: "The organization Id. If provider is linked to an organization.", isRequired: false },
    ]}
/>

### If you have provider ownership enabled via `providerOwnership.enabled`:

The `scimProvider` schema is extended as follows:

<DatabaseTable
    fields={[
        { name: "userId", type: "string", description: "The user id of the connection owner. Set automatically when generating a token via the API.", isRequired: false },
    ]}
/>


## Options

### Server

- `providerOwnership`: `{ enabled: boolean }` — When enabled, links each provider connection to the user who generated its token. See [Connection ownership](#scim-provider-connection-ownership) for details. Default is `{ enabled: false }`.

```ts title="Enable connection ownership (requires migration)"
scim({
    providerOwnership: { enabled: true },
})
```

- `defaultSCIM`: Default list of SCIM tokens for testing.
- `storeSCIMToken`: The method to store the SCIM token in your database, whether `encrypted`, `hashed` or `plain` text. Default is `plain` text.

Alternatively, you can pass a custom encryptor or hasher to store the SCIM token in your database.

**Custom encryptor**

```ts title="auth.ts"
scim({
    storeSCIMToken: { 
        encrypt: async (scimToken) => {
            return myCustomEncryptor(scimToken);
        },
        decrypt: async (scimToken) => {
            return myCustomDecryptor(scimToken);
        },
    }
})
```

**Custom hasher**

```ts title="auth.ts"
scim({
    storeSCIMToken: {
        hash: async (scimToken) => {
            return myCustomHasher(scimToken);
        },
    }
})
```

### Hooks

The following hooks allow to intercept the lifecycle of the `SCIM` token generation:

```ts
scim({
    beforeSCIMTokenGenerated: async ({ user, member, scimToken }) => {
        // Callback called before the scim token is persisted
        // can be useful to intercept the generation
        if (member?.role !== "admin") {
            throw new APIError("FORBIDDEN", { message: "User does not have enough permissions" });
        }
    },
    afterSCIMTokenGenerated: async ({ user, member, scimToken, scimProvider }) => {
        // Callback called after the scim token has been persisted
        // can be useful to send a notification or otherwise share the token
        await shareSCIMTokenWithInterestedParty(scimToken);
    },
})
```

<Callout>
**Note**: All hooks support error handling. Throwing an error in a before hook will prevent the operation from proceeding.
</Callout>
---
title: Test Utils
description: Testing utilities for integration and E2E testing
---

The Test Utils plugin provides helpers for writing integration and E2E tests against Better Auth. It includes factories, database helpers, authentication helpers, and OTP capture functionality.

<Callout type="warn">
This plugin is designed for test environments only. Do not use it in production.
</Callout>

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { testUtils } from "better-auth/plugins" // [!code highlight]

    export const auth = betterAuth({
        // ... other config options
        plugins: [
            testUtils() // [!code highlight]
        ]
    })
    ```
  </Step>
  <Step>
    ### Access test helpers via context

    ```ts title="test-setup.ts"
    const ctx = await auth.$context
    const test = ctx.test
    ```
  </Step>
</Steps>

## Usage

### Factories

Factories create objects without writing to the database. Use them to generate test data with sensible defaults.

#### createUser

Creates a user object with default values that can be overridden.

```ts
// Create user with defaults
const user = test.createUser()
// { id: "...", email: "user-xxx@example.com", name: "Test User", emailVerified: true, ... }

// Create user with overrides
const user = test.createUser({
    email: "alice@example.com",
    name: "Alice",
    emailVerified: false
})
```

#### createOrganization

Creates an organization object. Only available when the organization plugin is installed.

```ts
const org = test.createOrganization({
    name: "Acme Corp",
    slug: "acme-corp"
})
```

### Database Helpers

Database helpers persist and remove test data from the database.

#### saveUser

Saves a user to the database.

```ts
const user = test.createUser({ email: "test@example.com" })
const savedUser = await test.saveUser(user)
```

#### deleteUser

Deletes a user from the database.

```ts
await test.deleteUser(user.id)
```

#### saveOrganization

Saves an organization to the database. Only available with the organization plugin.

```ts
const org = test.createOrganization({ name: "Test Org" })
const savedOrg = await test.saveOrganization(org)
```

#### deleteOrganization

Deletes an organization from the database. Only available with the organization plugin.

```ts
await test.deleteOrganization(org.id)
```

#### addMember

Adds a user as a member of an organization. Only available with the organization plugin.

```ts
const member = await test.addMember({
    userId: user.id,
    organizationId: org.id,
    role: "admin"
})
```

### Auth Helpers

Auth helpers create authenticated sessions for testing protected routes.

#### login

Creates a session for a user and returns session details, headers, cookies, and token.

```ts
const { session, user, headers, cookies, token } = await test.login({
    userId: user.id
})

// session - The session object with userId, token, etc.
// user - The user object
// headers - Headers object with session cookie (for fetch/Request)
// cookies - Cookie array (for Playwright/Puppeteer)
// token - The session token string
```

#### getAuthHeaders

Returns a `Headers` object with the session cookie set. Useful for making authenticated requests.

```ts
const headers = await test.getAuthHeaders({ userId: user.id })

// Use with auth API
const session = await auth.api.getSession({ headers })

// Use with fetch
const response = await fetch("/api/protected", { headers })
```

#### getCookies

Returns an array of cookie objects compatible with browser testing tools like Playwright and Puppeteer.

```ts
const cookies = await test.getCookies({
    userId: user.id,
    domain: "localhost" // optional, defaults to baseURL domain
})

// Playwright example
await context.addCookies(cookies)

// Puppeteer example
for (const cookie of cookies) {
    await page.setCookie(cookie)
}
```

Each cookie object contains:
- `name` - Cookie name (e.g., "better-auth.session_token")
- `value` - Cookie value
- `domain` - Cookie domain
- `path` - Cookie path (defaults to "/")
- `httpOnly` - Whether cookie is HTTP-only
- `secure` - Whether cookie requires HTTPS
- `sameSite` - SameSite attribute ("Lax", "Strict", or "None")

### OTP Capture

When `captureOTP: true` is set, the plugin passively captures OTPs as they are created. This allows you to retrieve OTPs in tests without needing to mock email or SMS sending.

<Callout>
OTP capture is passive - it does not prevent OTPs from being sent via your configured `sendVerificationOTP` function. It simply stores a copy for test retrieval.
</Callout>

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { testUtils, emailOTP } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        testUtils({ captureOTP: true }), // [!code highlight]
        emailOTP({
            async sendVerificationOTP({ email, otp }) {
                // Your email sending logic
            }
        })
    ]
})
```

#### getOTP

Retrieves a captured OTP by identifier (email or phone number).

```ts
// Send OTP
await auth.api.sendVerificationOTP({
    body: { email: "user@example.com", type: "sign-in" }
})

// Retrieve captured OTP
const otp = test.getOTP("user@example.com")
// "123456"
```

## Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `captureOTP` | `boolean` | `false` | Enable OTP capture for testing verification flows |

## Examples

### Integration Test (Vitest)

```ts
import { describe, it, expect, beforeAll } from "vitest"
import { auth } from "./auth"
import type { TestHelpers } from "better-auth/plugins"

describe("protected route", () => {
    let test: TestHelpers

    beforeAll(async () => {
        const ctx = await auth.$context
        test = ctx.test
    })

    it("should return user data for authenticated request", async () => {
        // Setup
        const user = test.createUser({ email: "test@example.com" })
        await test.saveUser(user)

        // Get authenticated headers
        const headers = await test.getAuthHeaders({ userId: user.id })

        // Test authenticated request
        const session = await auth.api.getSession({ headers })
        expect(session?.user.id).toBe(user.id)

        // Cleanup
        await test.deleteUser(user.id)
    })
})
```

### E2E Test (Playwright)

```ts
import { test, expect } from "@playwright/test"
import { auth } from "./auth"

test("dashboard shows user name", async ({ context, page }) => {
    const ctx = await auth.$context
    const testUtils = ctx.test

    // Create and save user
    const user = testUtils.createUser({
        email: "e2e@example.com",
        name: "E2E User"
    })
    await testUtils.saveUser(user)

    // Get cookies and inject into browser
    const cookies = await testUtils.getCookies({
        userId: user.id,
        domain: "localhost"
    })
    await context.addCookies(cookies)

    // Navigate to protected page
    await page.goto("/dashboard")

    // Assert user name is visible
    await expect(page.getByText("E2E User")).toBeVisible()

    // Cleanup
    await testUtils.deleteUser(user.id)
})
```

### OTP Verification Test

```ts
import { describe, it, expect, beforeAll, beforeEach } from "vitest"
import { auth } from "./auth"
import type { TestHelpers } from "better-auth/plugins"

describe("OTP verification", () => {
    let test: TestHelpers

    beforeAll(async () => {
        const ctx = await auth.$context
        test = ctx.test
    })

    beforeEach(() => {
        test.clearOTPs()
    })

    it("should verify email with captured OTP", async () => {
        const email = "otp-test@example.com"
        const user = test.createUser({ email, emailVerified: false })
        await test.saveUser(user)

        // Request OTP
        await auth.api.sendVerificationOTP({
            body: { email, type: "email-verification" }
        })

        // Get captured OTP
        const otp = test.getOTP(email)
        expect(otp).toBeDefined()

        // Verify email
        await auth.api.verifyEmail({
            body: { email, otp }
        })

        // Cleanup
        await test.deleteUser(user.id)
    })
})
```
---
title: One-Time Token Plugin
description: Generate and verify single-use token
---

The One-Time Token (OTT) plugin provides functionality to generate and verify secure, single-use session tokens. These are commonly used for across domains authentication.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To use the One-Time Token plugin, add it to your auth config.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { oneTimeToken } from "better-auth/plugins/one-time-token"; // [!code highlight]
    
    export const auth = betterAuth({
        plugins: [
          oneTimeToken() // [!code highlight]
        ]
        // ... other auth config
    });
    ```
  </Step>

  <Step>
    ### Add the client plugin

    Next, include the one-time-token client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { oneTimeTokenClient } from "better-auth/client/plugins" // [!code highlight]
    
    export const authClient = createAuthClient({
        plugins: [
            oneTimeTokenClient() // [!code highlight]
        ]
    })
    ```
  </Step>
</Steps>

## Usage

### 1. Generate a Token

Generate a token using `auth.api.generateOneTimeToken` or `authClient.oneTimeToken.generate`

<APIMethod
  path="/one-time-token/generate"
  method="GET"
  requireSession
>
```ts
type generateOneTimeToken = {
}
```
</APIMethod>

This will return a `token` that is attached to the current session which can be used to verify the one-time token. By default, the token will expire in 3 minutes.

### 2. Verify the Token

When the user clicks the link or submits the token, use the `auth.api.verifyOneTimeToken` or `authClient.oneTimeToken.verify` method in another API route to validate it.

<APIMethod path="/one-time-token/verify" method="POST">
```ts
type verifyOneTimeToken = {
    /**
     * The token to verify. 
     */
    token: string = "some-token"
}
```
</APIMethod>

This will return the session that was attached to the token.

## Options

These options can be configured when adding the `oneTimeToken` plugin:

*   **`disableClientRequest`** (boolean): Optional. If `true`, the token will only be generated on the server side. Default: `false`.
*   **`expiresIn`** (number): Optional. The duration for which the token is valid in minutes. Default: `3`.

```ts
oneTimeToken({
    expiresIn: 10 // 10 minutes
})
```
* **`generateToken`**: A custom token generator function that takes `session` object and a `ctx` as parameters.

* **`storeToken`**: Optional. This option allows you to configure how the token is stored in your database.

    * **`plain`**: The token is stored in plain text. (Default)
    * **`hashed`**: The token is hashed using the default hasher.
    * **`custom-hasher`**: A custom hasher function that takes a token and returns a hashed token.

<Callout type="info">
    Note: It will not affect the token that's sent, it will only affect the token stored in your database.
</Callout>

Examples:

```ts title="No hashing (default)"
oneTimeToken({
    storeToken: "plain"
})
```
```ts title="built-in hasher"
oneTimeToken({
    storeToken: "hashed"
})
```
```ts title="custom hasher"
oneTimeToken({
    storeToken: {
        type: "custom-hasher",
        hash: async (token) => {
            return myCustomHasher(token);
        }
    }
})
```
---
title: Username
description: Username plugin
---

The username plugin is a lightweight plugin that adds username support to the email and password authenticator. This allows users to sign in with their username instead of their email.

## Installation

<Steps>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { username } from "better-auth/plugins" // [!code highlight]

        export const auth = betterAuth({
            emailAndPassword: { // [!code highlight]
                enabled: true, // [!code highlight]
            }, // [!code highlight]
            plugins: [ // [!code highlight]
                username() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { usernameClient } from "better-auth/client/plugins" // [!code highlight]

        export const authClient = createAuthClient({
            plugins: [ // [!code highlight]
                usernameClient() // [!code highlight]
            ] // [!code highlight]
        })
        ```
    </Step>
</Steps>

## Usage

### Sign up

To sign up a user with username, you can use the existing `signUp.email` function provided by the client.
The `signUp` function should take a new `username` property in the object.

<APIMethod path="/sign-up/email" method="POST">
```ts
type signUpEmail = {
    /**
     * The email of the user.
    */
    email: string = "email@domain.com"
    /**
     * The name of the user.
    */
    name: string = "Test User"
    /**
     * The password of the user.
    */
    password: string = "password1234"
    /**
     * The username of the user.
    */
    username?: string = "test"
    /**
     * An optional display username of the user.
    */
    displayUsername?: string = "Test User123"
}
```
</APIMethod>


<Callout type="info">
    If only `username` is provided, the `displayUsername` will be set to the pre normalized version of the `username`. You can see the [Username Normalization](#username-normalization) and [Display Username Normalization](#display-username-normalization) sections for more details.
</Callout>

### Sign in

To sign in a user with username, you can use the `signIn.username` function provided by the client.

<APIMethod path="/sign-in/username" method="POST">
```ts
type signInUsername = {
    /**
     * The username of the user.
    */
    username: string = "test"
    /**
     * The password of the user.
    */
    password: string = "password1234"
}
```
</APIMethod>

### Update username

To update the username of a user, you can use the `updateUser` function provided by the client.

<APIMethod path="/update-user" method="POST">
```ts
type updateUser = {
    /**
     * The username to update.
    */
    username?: string = "new-username"
}
```
</APIMethod>

### Check if username is available

To check if a username is available, you can use the `isUsernameAvailable` function provided by the client.

<APIMethod path="/is-username-available" method="POST" resultVariable="response">
```ts
type isUsernameAvailable = {
    /**
     * The username to check.
    */
    username: string = "new-username"
}

if(response?.available) {
    console.log("Username is available");
} else {
    console.log("Username is not available");
}
```
</APIMethod>

## Options

### Min Username Length

The minimum length of the username. Default is `3`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    plugins: [
        username({
            minUsernameLength: 5
        })
    ]
})
```

### Max Username Length

The maximum length of the username. Default is `30`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    plugins: [
        username({
            maxUsernameLength: 100
        })
    ]
})
```

### Username Validator

A function that validates the username. The function should return false if the username is invalid. By default, the username should only contain alphanumeric characters, underscores, and dots.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    plugins: [
        username({
            usernameValidator: (username) => {
                if (username === "admin") {
                    return false
                }
                return true
            }
        })
    ]
})
```

### Display Username Validator

A function that validates the display username. The function should return false if the display username is invalid. By default, no validation is applied to display username.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    plugins: [
        username({
            displayUsernameValidator: (displayUsername) => {
                // Allow only alphanumeric characters, underscores, and hyphens
                return /^[a-zA-Z0-9_-]+$/.test(displayUsername)
            }
        })
    ]
})
```

### Username Normalization

A function that normalizes the username, or `false` if you want to disable normalization.

By default, usernames are normalized to lowercase, so "TestUser" and "testuser", for example, are considered the same username. The `username` field will contain the normalized (lower case) username, while `displayUsername` will contain the original `username`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    plugins: [
        username({
            usernameNormalization: (username) => {
                return username.toLowerCase()
                    .replaceAll("0", "o")
                    .replaceAll("3", "e")
                    .replaceAll("4", "a");
            }
        })
    ]
})
```

### Display Username Normalization

A function that normalizes the display username, or `false` to disable normalization.

By default, display usernames are not normalized. When only `username` is provided during signup or update, the `displayUsername` will be set to match the original `username` value (before normalization). You can also explicitly set a `displayUsername` which will be preserved as-is. For custom normalization, provide a function that takes the display username as input and returns the normalized version.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    plugins: [
        username({
            displayUsernameNormalization: (displayUsername) => displayUsername.toLowerCase(),
        })
    ]
})
```

### Validation Order

By default, username and display username are validated before normalization. You can change this behavior by setting `validationOrder` to `post-normalization`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    plugins: [
        username({
            validationOrder: {
                username: "post-normalization",
                displayUsername: "post-normalization",
            }
        })
    ]
})
```

### Disable Is Username Available

By default, the plugin exposes an endpoint `/is-username-available` to check if a username is available. You can disable this endpoint by providing `disabledPaths` option to the better-auth configuration. This is useful if you want to protect usernames from being enumerated.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { username } from "better-auth/plugins"

const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    disabledPaths: ["/is-username-available"],
    plugins: [
        username()
    ]
})
```

## Schema

The plugin requires 2 fields to be added to the user table:

<DatabaseTable
    fields={[
        {
            name: "username",
            type: "string",
            description: "The username of the user",
            isUnique: true
        },
        {
            name: "displayUsername",
            type: "string",
            description: "Non normalized username of the user",
            isUnique: true
        },
    ]}
/>
---
title: Creem
description: Better Auth Plugin for Payment and Subscriptions using Creem
---

[Creem](https://creem.io) is a financial OS that enables teams and individuals selling software globally to split revenue and collaborate on financial workflows without any tax compliance headaches. This plugin integrates Creem with Better Auth, bringing payment processing and subscription management directly into your authentication layer.

<Callout>
  This plugin is maintained by the Creem team. For bugs, issues or feature requests,
  please visit the [Creem GitHub repo](https://github.com/armitage-labs/creem-betterauth).
</Callout>

<Card href="https://discord.gg/q3GKZs92Av" title="Get support on Creem Discord or in our in-app live-chat">
  Need help? Reach out to our team anytime on Discord.
</Card>


## Features

- **Database Persistence** - Automatically synchronize customer and subscription data with your database
- **Access Management** - Automatically grant or revoke access to users based on their subscription status
- **Customer Synchronization** - Synchronize Creem customer IDs with your database users
- **Checkout Integration** - Create checkout sessions either automatically for authenticated users or manually for unauthenticated users
- **Customer Portal** - Enable users to manage subscriptions, view invoices, and update payment methods
- **Subscription Management** - Cancel, retrieve, and track subscription details for authenticated users or manually for unauthenticated users
- **Transaction History** - Search and filter transaction records for authenticated users or manually for unauthenticated users
- **Webhook Processing** - Handle Creem webhooks securely with signature verification
- **Flexible Architecture** - Use Better Auth endpoints or direct server-side functions
- **Trial Abuse Prevention** - Users can only get one trial per account across all plans (when using database mode)

## Installation

<Steps>
  <Step>
    ### Install the plugin

    ```package-install
    @creem_io/better-auth
    ```

    <Callout>
      If you're using a separate client and server setup, make sure to install the plugin in both parts of your project.
    </Callout>
  </Step>

  <Step>
    ### Get your API Key

    Get your Creem API Key from the [Creem dashboard](https://creem.io/dashboard/developers), under the 'Developers' menu and add it to your environment variables:

    ```bash
    # .env
    CREEM_API_KEY=your_api_key_here
    ```

    <Callout type="warn">
      Test Mode and Production have different API keys. Make sure you're using the correct one for your environment.
    </Callout>
  </Step>

</Steps>

## Configuration

### Server Configuration

Configure Better Auth with the Creem plugin:

```typescript
// lib/auth.ts
import { betterAuth } from "better-auth";
import { creem } from "@creem_io/better-auth";

export const auth = betterAuth({
  database: {
    // your database config
  },
  plugins: [
    creem({
      apiKey: process.env.CREEM_API_KEY!,
      webhookSecret: process.env.CREEM_WEBHOOK_SECRET, // Optional, webhooks are automatically enabled when passing a signing secret
      testMode: true, // Optional, use test mode for development
      defaultSuccessUrl: "/success", // Optional, redirect to this URL after successful payments
      persistSubscriptions: true, // Optional, enable database persistence (default: true)
    }),
  ],
});
```

### Client Configuration

### Standard Setup

```typescript
// lib/auth-client.ts
import { createAuthClient } from "better-auth/react";
import { creemClient } from "@creem_io/better-auth/client";

export const authClient = createAuthClient({
  baseURL: process.env.NEXT_PUBLIC_APP_URL,
  plugins: [creemClient()],
});
```

### Enhanced TypeScript Support (React-Only)

For improved TypeScript IntelliSense and autocomplete:

```typescript
// lib/auth-client.ts
import { createCreemAuthClient } from "@creem_io/better-auth/create-creem-auth-client";
import { creemClient } from "@creem_io/better-auth/client";

export const authClient = createCreemAuthClient({
  baseURL: process.env.NEXT_PUBLIC_APP_URL,
  plugins: [creemClient()],
});
```

<Callout>
  The `createCreemAuthClient` wrapper provides enhanced TypeScript support and cleaner parameter types. It's optimized for use with the Creem plugin.
</Callout>

### Database Migration

If you're using database persistence (`persistSubscriptions: true`), generate and run the database schema:

<Tabs items={["migrate", "generate"]}>
    <Tab value="migrate">
    ```package-install
    npx auth migrate
    ```
    </Tab>
    <Tab value="generate">
    ```package-install
    npx auth generate
    ```
    </Tab>
</Tabs>

<Callout type="info">
  Depending on your database adapter, additional setup steps may be required. Refer to the [Better Auth adapter documentation](https://www.better-auth.com/docs/adapters/mysql) for details.
</Callout>

### Webhook Setup

<Steps>
  <Step>
    ### Create Webhook Endpoint

    In your [Creem dashboard](https://creem.io/dashboard/developers/webhooks), create a webhook endpoint pointing to your local or production server pointing to:

    ```text
    https://your-domain.com/api/auth/creem/webhook
    ```

    (`/api/auth` is the default Better Auth server path)

    <Callout type="info">
      Check step 3 if local development.
    </Callout>
  </Step>

  <Step>
    ### Configure Webhook Secret

    Copy the webhook signing secret from Creem and add it to your environment:

    ```bash
    CREEM_WEBHOOK_SECRET=your_webhook_secret_here
    ```

    Update your server configuration:

    ```typescript
    creem({
      apiKey: process.env.CREEM_API_KEY!,
      webhookSecret: process.env.CREEM_WEBHOOK_SECRET,
      testMode: true,
    })
    ```
  </Step>

  <Step>
    ### Local Development (Optional)

    For local testing, use a tool like [ngrok](https://ngrok.com) to expose your local server:

    ```bash
    ngrok http 3000
    ```

    Add the ngrok URL to your Creem webhook settings.
  </Step>
</Steps>

## Database Schema

When `persistSubscriptions: true`, the plugin creates the following schema:

### Creem Subscription Table

Table Name: `creem_subscription`

| Field                 | Type    | Description                      |
| --------------------- | ------- | -------------------------------- |
| `id`                  | string  | Primary key                      |
| `productId`           | string  | Creem product ID                 |
| `referenceId`         | string  | Your user/organization ID        |
| `creemCustomerId`     | string  | Creem customer ID                |
| `creemSubscriptionId` | string  | Creem subscription ID            |
| `creemOrderId`        | string  | Creem order ID                   |
| `status`              | string  | Subscription status              |
| `periodStart`         | date    | Billing period start date        |
| `periodEnd`           | date    | Billing period end date          |
| `cancelAtPeriodEnd`   | boolean | Whether subscription will cancel |

### User Table Extension

| Field             | Type   | Description                  |
| ----------------- | ------ | ---------------------------- |
| `creemCustomerId` | string | Links user to Creem customer |

## Usage

### Checkout

Create a checkout session to process payments:

```typescript
"use client";

import { authClient } from "@/lib/auth-client";

export function SubscribeButton({ productId }: { productId: string }) {
  const handleCheckout = async () => {
    const { data, error } = await authClient.creem.createCheckout({
      productId,
      successUrl: "/dashboard",
      discountCode: "LAUNCH50", // Optional
      metadata: { planType: "pro" }, // Optional
    });

    if (data?.url) {
      window.location.href = data.url;
    }
  };

  return <button onClick={handleCheckout}>Subscribe Now</button>;
}
```

#### Checkout Options

- `productId` (required) - The Creem product ID
- `units` - Number of units (default: 1)
- `successUrl` - Redirect URL after successful payment
- `discountCode` - Discount code to apply
- `customer` - Customer information (auto-populated from session)
- `metadata` - Additional metadata (auto-includes user ID as `referenceId`)
- `requestId` - Idempotency key for duplicate prevention

### Customer Portal

Redirect users to manage their subscriptions:

```typescript
const handlePortal = async () => {
  // No need to redirect, the portal will be opened in the same tab
  const { data, error } = await authClient.creem.createPortal();
};
```

### Subscription Management

### Cancel Subscription

When database persistence is enabled, the subscription is found automatically for the authenticated user:

```typescript
const handleCancel = async () => {
  const { data, error } = await authClient.creem.cancelSubscription();

  if (data?.success) {
    console.log(data.message);
  }
};
```

If database persistence is disabled, provide the subscription ID:

```typescript
const { data } = await authClient.creem.cancelSubscription({
  id: "sub_123456",
});
```

### Retrieve Subscription

Get subscription details for the authenticated user:

```typescript
const getSubscription = async () => {
  const { data } = await authClient.creem.retrieveSubscription();

  if (data) {
    console.log(`Status: ${data.status}`);
    console.log(`Product: ${data.product.name}`);
    console.log(`Price: ${data.product.price} ${data.product.currency}`);
  }
};
```

### Check Access

Verify if the user has an active subscription (requires database mode):

```typescript
const { data } = await authClient.creem.hasAccessGranted();

if (data?.hasAccess) {
  // User has active subscription access
  console.log(`Expires: ${data.expiresAt}`);
}
```

<Callout type="info">
  This function checks if the user has access for the current billing period. For example, if a user purchases a yearly plan and cancels after one month, they still have access until the year ends.
</Callout>

### Transaction History

Search transaction records for the authenticated user:

```typescript
const { data } = await authClient.creem.searchTransactions({
  productId: "prod_xyz789", // Optional filter
  pageNumber: 1,
  pageSize: 50,
});

if (data?.transactions) {
  data.transactions.forEach((tx) => {
    console.log(`${tx.type}: ${tx.amount} ${tx.currency}`);
  });
}
```

## Webhook Handling

The plugin provides flexible webhook handling with both granular event handlers and high-level access control handlers.

### High-Level Access Control Handlers (Recommended)

These handlers provide the simplest and most powerful way to manage user access. They automatically handle all payment scenarios and subscription states, so you don't need to manage individual subscription events.

  <strong> Database Persistence Required:</strong> These handlers require the database persistence option to be enabled in your plugin configuration.

  | Handler Name           | Data Parameter Type        | Description                                                                                              |
  |------------------------|----------------------------|----------------------------------------------------------------------------------------------------------|
  | **`onGrantAccess`**    | **`GrantAccessContext`**   | **Called when a user should be granted access.** Handles successful payments, active subscriptions, and trial periods. Use this to enable features, add user to groups, or update permissions. |
  | **`onRevokeAccess`**   | **`RevokeAccessContext`**  | **Called when a user's access should be revoked.** Handles cancellations, expirations, refunds, and failed payments. Use this to disable features, remove from groups, or revoke permissions. |

**Why use these handlers?**
-  Single source of truth for access control
-  Handles all payment scenarios automatically
-  Reduces code complexity and potential bugs
-  Works for both one-time purchases and subscriptions
-  Takes current billing period and access expiration dates into consideration

```typescript
// lib/auth.ts
import { betterAuth } from "better-auth";
import { creem } from "@creem_io/better-auth";

export const auth = betterAuth({
  database: {
    // your database config
  },
  plugins:[ 
    creem({
      apiKey: process.env.CREEM_API_KEY!,
      webhookSecret: process.env.CREEM_WEBHOOK_SECRET!,

      onGrantAccess: async ({ reason, product, customer, metadata }) => {
        const userId = metadata?.referenceId as string;

        // Update your database specific logic
        await db.user.update({
          where: { id: userId },
          data: { 
            hasAccess: true, 
            subscriptionTier: product.name,
            accessReason: reason 
          },
        });

        console.log(`Granted ${reason} access to ${customer.email}`);
      },

      onRevokeAccess: async ({ reason, product, customer, metadata }) => {
        const userId = metadata?.referenceId as string;

        // Update your database specific logic
        await db.user.update({
          where: { id: userId },
          data: { 
            hasAccess: false, 
            revokeReason: reason 
          },
        });

        console.log(`Revoked access (${reason}) from ${customer.email}`);
      },
    }),
  ],
})
```

### Grant Access Reasons

- `subscription_active` - Subscription is active
- `subscription_trialing` - Subscription is in trial period
- `subscription_paid` - Subscription payment received

### Revoke Access Reasons

- `subscription_paused` - Subscription paused by user or admin
- `subscription_expired` - Subscription expired without renewal
- `subscription_period_end` - Current subscription period ended without renewal


---

### Granular Event Handlers

For advanced use cases where you need fine-grained control over specific events, use these handlers:

  | Handler Name                | Data Parameter Type            | Description                                                  |
  |-----------------------------|-------------------------------|--------------------------------------------------------------|
  | `onCheckoutCompleted`       | `FlatCheckoutCompleted`       | Called when a checkout is completed successfully.            |
  | `onRefundCreated`           | `FlatRefundCreated`           | Triggered when a refund is issued for a payment.             |
  | `onDisputeCreated`          | `FlatDisputeCreated`          | Invoked when a payment dispute/chargeback is created.        |
  | `onSubscriptionActive`      | `FlatSubscriptionEvent`       | Fired when a subscription becomes active.                    |
  | `onSubscriptionTrialing`    | `FlatSubscriptionEvent`       | Subscription enters a trial period.                          |
  | `onSubscriptionCanceled`    | `FlatSubscriptionEvent`       | Called when a subscription is canceled.                      |
  | `onSubscriptionPaid`        | `FlatSubscriptionEvent`       | Subscription payment is received.                            |
  | `onSubscriptionExpired`     | `FlatSubscriptionEvent`       | Subscription has expired (no renewal/payment).               |
  | `onSubscriptionUnpaid`      | `FlatSubscriptionEvent`       | Payment for a subscription failed or remains unpaid.         |
  | `onSubscriptionUpdate`      | `FlatSubscriptionEvent`       | Subscription settings/details updated.                       |
  | `onSubscriptionPastDue`     | `FlatSubscriptionEvent`       | Subscription payment is late or overdue.                     |
  | `onSubscriptionPaused`      | `FlatSubscriptionEvent`       | Subscription has been paused (by user or admin).             |

### How to use a Webhook Handler

Handle individual webhook events with all properties flattened for easy access:

```typescript
// lib/auth.ts
import { betterAuth } from "better-auth";
import { creem } from "@creem_io/better-auth";

export const auth = betterAuth({
  database: {
    // your database config
  },
  plugins: [
    creem({
      apiKey: process.env.CREEM_API_KEY!,
      webhookSecret: process.env.CREEM_WEBHOOK_SECRET!,

      onCheckoutCompleted: async (data) => {
        const { customer, product, order, webhookEventType } = data;
        console.log(`${customer.email} purchased ${product.name}`);
        
        // Perfect for one-time payments
        await sendThankYouEmail(customer.email);
      },

      onSubscriptionActive: async (data) => {
        const { customer, product, status } = data;
        // Handle active subscription
      },

      onSubscriptionTrialing: async (data) => {
        // Handle trial period
      },

      onSubscriptionCanceled: async (data) => {
        // Handle cancellation
      },

      onSubscriptionExpired: async (data) => {
        // Handle expiration
      },

      onRefundCreated: async (data) => {
        // Handle refunds
      },

      onDisputeCreated: async (data) => {
        // Handle disputes
      },
    }),
  ],
});
```


### Custom Webhook Handler

Create your own webhook endpoint with signature verification:

```typescript
// app/api/webhooks/custom/route.ts
import { validateWebhookSignature } from "@creem_io/better-auth/server";

export async function POST(req: Request) {
  const payload = await req.text();
  const signature = req.headers.get("creem-signature");

  if (
    !validateWebhookSignature(
      payload,
      signature,
      process.env.CREEM_WEBHOOK_SECRET!
    )
  ) {
    return new Response("Invalid signature", { status: 401 });
  }

  const event = JSON.parse(payload);
  // Your custom webhook handling logic

  return Response.json({ received: true });
}
```

## Server-Side Functions

Use these utilities directly in Server Components, Server Actions, or API routes without going through Better Auth endpoints.

### Import Server Utilities

```typescript
import {
  createCheckout,
  createPortal,
  cancelSubscription,
  retrieveSubscription,
  searchTransactions,
  checkSubscriptionAccess,
  isActiveSubscription,
  formatCreemDate,
  getDaysUntilRenewal,
  validateWebhookSignature,
} from "@creem_io/better-auth/server";
```

### Server Component Example

```typescript
import { checkSubscriptionAccess } from "@creem_io/better-auth/server";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { redirect } from "next/navigation";

export default async function DashboardPage() {
  const session = await auth.api.getSession({ headers: await headers() });

  if (!session?.user) {
    redirect("/login");
  }

  const status = await checkSubscriptionAccess(
    {
      apiKey: process.env.CREEM_API_KEY!,
      testMode: true,
    },
    {
      database: auth.options.database,
      userId: session.user.id,
    }
  );

  if (!status.hasAccess) {
    redirect("/subscribe");
  }

  return (
    <div>
      <h1>Welcome to Dashboard</h1>
      <p>Subscription Status: {status.status}</p>
      {status.expiresAt && (
        <p>Renews: {status.expiresAt.toLocaleDateString()}</p>
      )}
    </div>
  );
}
```

### Server Action Example

```typescript
"use server";

import { createCheckout } from "@creem_io/better-auth/server";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { redirect } from "next/navigation";

export async function startCheckout(productId: string) {
  const session = await auth.api.getSession({ headers: await headers() });

  if (!session?.user) {
    throw new Error("Not authenticated");
  }

  const { url } = await createCheckout(
    {
      apiKey: process.env.CREEM_API_KEY!,
      testMode: true,
    },
    {
      productId,
      customer: { email: session.user.email },
      successUrl: "/success",
      metadata: { userId: session.user.id },
    }
  );

  redirect(url);
}
```

### Middleware Example

Protect routes based on subscription status:

```typescript
import { checkSubscriptionAccess } from "@creem_io/better-auth/server";
import { auth } from "@/lib/auth";
import { NextRequest, NextResponse } from "next/server";

export async function middleware(request: NextRequest) {
  const session = await auth.api.getSession({
    headers: request.headers,
  });

  if (!session?.user) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  const status = await checkSubscriptionAccess(
    {
      apiKey: process.env.CREEM_API_KEY!,
      testMode: true,
    },
    {
      database: auth.options.database,
      userId: session.user.id,
    }
  );

  if (!status.hasAccess) {
    return NextResponse.redirect(new URL("/subscribe", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/dashboard/:path*"],
};
```

### Utility Functions

```typescript
import {
  isActiveSubscription,
  formatCreemDate,
  getDaysUntilRenewal,
} from "@creem_io/better-auth/server";

// Check if status grants access
if (isActiveSubscription(subscription.status)) {
  // User has access
}

// Format Creem timestamps
const renewalDate = formatCreemDate(subscription.next_billing_date);
console.log(renewalDate.toLocaleDateString());

// Calculate days until renewal
const days = getDaysUntilRenewal(subscription.current_period_end_date);
console.log(`Renews in ${days} days`);
```


### Database Mode vs API Mode

The plugin supports two operational modes:

### Database Mode (Recommended)

When `persistSubscriptions: true` (default), subscription data is stored in your database.

**Benefits:**
- Fast access checks without API calls
- Offline access to subscription data
- Query subscriptions with SQL
- Automatic synchronization via webhooks
- Trial abuse prevention

**Usage:**

```typescript
creem({
  apiKey: process.env.CREEM_API_KEY!,
  persistSubscriptions: true, // Default
})
```

### API Mode

When `persistSubscriptions: false`, all data comes directly from the Creem API.

**Benefits:**
- No database schema required
- Simpler initial setup

**Limitations:**
- Requires API call for each access check
- Some features require custom implementation
- No built-in trial abuse prevention

**Usage:**

```typescript
creem({
  apiKey: process.env.CREEM_API_KEY!,
  persistSubscriptions: false,
})
```

<Callout type="warn">
  In API mode, functions like `checkSubscriptionAccess` and `hasAccessGranted` have limited functionality and may require custom implementation using the Creem SDK directly.
</Callout>

## Type Exports

### Server-Side Types

| Type Name               | Description                                                                                       | Typical Usage                                      |
|-------------------------|---------------------------------------------------------------------------------------------------|----------------------------------------------------|
| `CreemOptions`          | Configuration options for the Creem plugin, such as API keys and persistence settings.            | Used to configure the plugin on the server.         |
| `GrantAccessContext`    | Context passed to custom access control hooks when granting access to a user.                      | Used in custom access logic.                        |
| `RevokeAccessContext`   | Context passed to hooks when revoking user access due to subscription status changes.              | Used in custom access logic.                        |
| `GrantAccessReason`     | Enum or type describing reasons for granting access (e.g., payment received, trial activated).     | Returned in access-related hooks and events.        |
| `RevokeAccessReason`    | Enum or type describing reasons for revoking access (e.g., canceled, payment failed).              | Returned in access-related hooks and events.        |
| `FlatCheckoutCompleted` | Event object type for webhook payload when a checkout completes successfully.                      | Used in webhook handlers and event listeners.       |
| `FlatRefundCreated`     | Event object type for webhook payload when a refund is created.                                   | Used in webhook handlers and event listeners.       |
| `FlatDisputeCreated`    | Event object type for webhook payload when a dispute is created.                                  | Used in webhook handlers and event listeners.       |
| `FlatSubscriptionEvent` | Event object type for generic subscription events (created, updated, canceled, etc).              | Used in webhook handlers and event listeners.       |

### Client-Side Types

| Type Name                    | Description                                                                                           |
|------------------------------|-------------------------------------------------------------------------------------------------------|
| `CreateCheckoutInput`        | Input parameters for creating a checkout session.                                                     |
| `CreateCheckoutResponse`     | Response shape for a checkout session creation request.                                               |
| `CheckoutCustomer`           | Customer information type used in a checkout session.                                                 |
| `CreatePortalInput`          | Input parameters for creating a customer portal session.                                              |
| `CreatePortalResponse`       | Response data for a request to create a customer portal.                                              |
| `CancelSubscriptionInput`    | Input parameters when cancelling a subscription.                                                      |
| `CancelSubscriptionResponse` | Response data for a subscription cancellation request.                                                |
| `RetrieveSubscriptionInput`  | Input for retrieving a specific subscription's details.                                               |
| `SubscriptionData`           | Subscription information structure as returned by the API.                                            |
| `SearchTransactionsInput`    | Filters and parameters for searching transactions.                                                    |
| `SearchTransactionsResponse` | Response structure for a transaction search query.                                                    |
| `TransactionData`            | Data relating to individual transactions (e.g., payment, refund, etc).                                |
| `HasAccessGrantedResponse`   | The shape of the response indicating whether a user has access based on subscription status/rules.    |

## Trial Abuse Prevention

When using database mode (`persistSubscriptions: true`), the plugin automatically prevents trial abuse. Users can only receive one trial across all subscription plans.

**Example Scenario:**
1. User subscribes to "Starter" plan with 7-day trial
2. User cancels subscription during the trial period
3. User attempts to subscribe to "Premium" plan
4. No trial is offered - user is charged immediately

This protection is automatic and requires no configuration. Trial eligibility is determined when the subscription is created and cannot be overridden.

## Troubleshooting

### Webhook Issues

If webhooks aren't being processed correctly:

1. Verify the webhook URL is correct in your Creem dashboard
2. Check that the webhook signing secret matches
3. Ensure all necessary events are selected in the Creem dashboard
4. Review server logs for webhook processing errors
5. Test webhook delivery using Creem's webhook testing tool

### Subscription Status Issues

If subscription statuses aren't updating:

1. Confirm webhooks are being received and processed
2. Verify `creemCustomerId` and `creemSubscriptionId` fields are populated
3. Check that reference IDs match between your application and Creem
4. Review webhook handler logs for errors

### Database Mode Not Working

If database persistence isn't functioning:

1. Ensure `persistSubscriptions: true` is set (it's the default)
2. Run migrations: `npx auth migrate`
3. Verify database connection is working
4. Check that schema tables were created successfully
5. Review database adapter configuration

### API Mode Limitations

Some functionalities are only available in database mode or require extra parameters to be passed:

- `checkSubscriptionAccess` requires passing the `userId` parameter
- `getActiveSubscriptions` requires passing the `userId` parameter  
- No automatic trial abuse prevention
- No access to `hasAccessGranted` client method

To use these features, either enable database mode or implement custom logic using the Creem SDK directly.

## Additional Resources

- [Creem Documentation](https://docs.creem.io)
- [Creem Dashboard](https://creem.io/dashboard)
- [Better Auth Documentation](https://better-auth.com)
- [Plugin GitHub Repository Additional Documentation](https://github.com/armitage-labs/creem-betterauth)

## Support

For issues or questions:

- Open an issue on [GitHub](https://github.com/armitage-labs/creem-betterauth/issues)
- Contact Creem support at [support@creem.io](mailto:support@creem.io)
- Join our [Discord community](https://discord.gg/q3GKZs92Av) for real-time support and discussion.
- Chat with us directly using the in-app live chat on the [Creem dashboard](https://creem.io/dashboard).
---
title: Phone Number
description: Phone number plugin
---

The phone number plugin extends the authentication system by allowing users to sign in and sign up using their phone number. It includes OTP (One-Time Password) functionality to verify phone numbers.

## Installation

<Steps>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { phoneNumber } from "better-auth/plugins" // [!code highlight]

        const auth = betterAuth({
            plugins: [ 
                phoneNumber({  // [!code highlight]
                    sendOTP: ({ phoneNumber, code }, ctx) => { // [!code highlight]
                        // Implement sending OTP code via SMS // [!code highlight]
                    } // [!code highlight]
                }) // [!code highlight]
            ] 
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { phoneNumberClient } from "better-auth/client/plugins" // [!code highlight]

        const authClient = createAuthClient({
            plugins: [
                phoneNumberClient() // [!code highlight]
            ]
        })
        ```
    </Step>
</Steps>

## Usage

### Send OTP for Verification

To send an OTP to a user's phone number for verification, you can use the `sendVerificationCode` endpoint.

<APIMethod path="/phone-number/send-otp" method="POST">
```ts
type sendPhoneNumberOTP = {
    /**
     * Phone number to send OTP. 
     */
    phoneNumber: string = "+1234567890"
}
```
</APIMethod>

### Verify Phone Number

After the OTP is sent, users can verify their phone number by providing the code.

<APIMethod path="/phone-number/verify" method="POST">
```ts
type verifyPhoneNumber = {
    /**
     * Phone number to verify.
     */
    phoneNumber: string = "+1234567890"
    /**
     * OTP code.
     */
    code: string = "123456"
    /**
     * Disable session creation after verification.
     */
    disableSession?: boolean = false
    /**
     * Update the phone number of an existing logged-in user.
     * Requires an active session.
     */
    updatePhoneNumber?: boolean = false
}
```
</APIMethod>

### Allow Sign-Up with Phone Number

To allow users to sign up using their phone number, you can pass `signUpOnVerification` option to your plugin configuration. It requires you to pass `getTempEmail` function to generate a temporary email for the user.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { phoneNumber } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        phoneNumber({
            sendOTP: ({ phoneNumber, code }, ctx) => {
                // Implement sending OTP code via SMS
            },
            signUpOnVerification: {
                getTempEmail: (phoneNumber) => {
                    return `${phoneNumber}@my-site.com`
                },
                //optionally, you can also pass `getTempName` function to generate a temporary name for the user
                getTempName: (phoneNumber) => {
                    return phoneNumber //by default, it will use the phone number as the name
                }
            }
        })
    ]
})
```

<Callout>
We highly recommend not awaiting the `sendOTP` function. If you await it, it'll slow down the request and could cause timing attacks. For serverless platforms, you can use `waitUntil` to ensure the OTP is sent.
</Callout>

If you have additional required fields in your user schema, you can pass them in the verify request body:

```ts title="auth-client.ts"
await authClient.phoneNumber.verify({
    phoneNumber: "+1234567890",
    code: "123456",
    customField: "custom-value", // additional field [!code highlight]
})
```

### Sign In with Phone Number

In addition to signing in a user using send-verify flow, you can also use phone number as an identifier and sign in a user using phone number and password.

<APIMethod path="/sign-in/phone-number" method="POST">
```ts
type signInPhoneNumber = {
    /**
     * Phone number to sign in. 
     */
    phoneNumber: string = "+1234567890"
    /**
     * Password to use for sign in. 
     */
    password: string
    /**
     * Remember the session. 
     */
    rememberMe?: boolean = true
}
```
</APIMethod>

### Update Phone Number

Already logged-in users can change their phone number to a new one. First, send an OTP to the new phone number:

```ts
import { authClient } from "@/lib/auth-client";

await authClient.phoneNumber.sendOtp({
    phoneNumber: "+1234567890" // New phone number // [!code highlight]
})
```

Then verify the new phone number with `updatePhoneNumber: true`:

```ts
import { authClient } from "@/lib/auth-client";

const isVerified = await authClient.phoneNumber.verify({
    phoneNumber: "+1234567890",
    code: "123456",
    updatePhoneNumber: true // [!code highlight]
})
```

### Disable Session Creation

By default, the plugin creates a session for the user after verifying the phone number. You can disable this behavior by passing `disableSession: true` to the `verify` method.

```ts
import { authClient } from "@/lib/auth-client";

const isVerified = await authClient.phoneNumber.verify({
    phoneNumber: "+1234567890",
    code: "123456",
    disableSession: true // [!code highlight]
})
```

### Request Password Reset

To initiate a request password reset flow using `phoneNumber`, you can start by calling `requestPasswordReset` on the client to send an OTP code to the user's phone number.

<APIMethod path="/phone-number/request-password-reset" method="POST">
```ts
type requestPasswordResetPhoneNumber = {
    /**
     * The phone number which is associated with the user. 
     */
    phoneNumber: string = "+1234567890"
}
```
</APIMethod>

Then, you can reset the password by calling `resetPassword` on the client with the OTP code and the new password.

<APIMethod path="/phone-number/reset-password" method="POST">
```ts
type resetPasswordPhoneNumber = {
    /**
     * The one time password to reset the password. 
     */
    otp: string = "123456"
    /**
     * The phone number to the account which intends to reset the password for. 
     */
    phoneNumber: string = "+1234567890"
    /**
     * The new password. 
     */
    newPassword: string = "new-and-secure-password"
}
```
</APIMethod>

## Options

### `otpLength`

The length of the OTP code to be generated. Default is `6`.

### `sendOTP`

A function that sends the OTP code to the user's phone number. It takes the phone number and the OTP code as arguments.

### `expiresIn`

The time in seconds after which the OTP code expires. Default is `300` seconds.

### `callbackOnVerification`

A function that is called after the phone number is verified. It takes the phone number and the user object as the first argument and a request object as the second argument.

```ts
import { betterAuth } from "better-auth";
import { phoneNumber } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        phoneNumber({
            sendOTP: ({ phoneNumber, code }, ctx) => {
                // Implement sending OTP code via SMS
            },
            callbackOnVerification: async ({ phoneNumber, user }, ctx) => { // [!code highlight]
                // Implement callback after phone number verification // [!code highlight]
            } // [!code highlight]
        })
    ]
})
```

### `sendPasswordResetOTP`

A function that sends the OTP code to the user's phone number for password reset. It takes the phone number and the OTP code as arguments.

### `phoneNumberValidator`

A custom function to validate the phone number. It takes the phone number as an argument and returns a boolean indicating whether the phone number is valid.

### `verifyOTP`

A custom function to verify the OTP code. When provided, this function will be used instead of the default internal verification logic. This is useful when you want to integrate with external SMS providers that handle OTP verification (e.g., Twilio Verify, AWS SNS). The function takes an object with `phoneNumber` and `code` properties and a request object, and returns a boolean or a promise that resolves to a boolean indicating whether the OTP is valid.

```ts
import { betterAuth } from "better-auth";
import { phoneNumber } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        phoneNumber({
            sendOTP: ({ phoneNumber, code }, ctx) => {
                // Send OTP via your SMS provider
            },
            verifyOTP: async ({ phoneNumber, code }, ctx) => { // [!code highlight]
                // Verify OTP with your desired logic (e.g., Twilio Verify) // [!code highlight]
                // This is just an example, not a real implementation. // [!code highlight]
                const isValid = await twilioClient.verify // [!code highlight]
                    .services('YOUR_SERVICE_SID') // [!code highlight]
                    .verificationChecks // [!code highlight]
                    .create({ to: phoneNumber, code }); // [!code highlight]
                return isValid.status === 'approved'; // [!code highlight]
            } // [!code highlight]
        })
    ]
})
```

<Callout type="warn">
When using this option, ensure that proper validation is implemented, as it overrides our internal verification logic.
</Callout>

### `signUpOnVerification`

An object with the following properties:
- `getTempEmail`: A function that generates a temporary email for the user. It takes the phone number as an argument and returns the temporary email.
- `getTempName`: A function that generates a temporary name for the user. It takes the phone number as an argument and returns the temporary name.

### `requireVerification`

When enabled, users cannot sign in with their phone number until it has been verified. If an unverified user attempts to sign in, the server will respond with a 401 error (PHONE_NUMBER_NOT_VERIFIED) and automatically trigger an OTP send to start the verification process.
    
## Schema

The plugin requires 2 fields to be added to the user table 

### User Table
<DatabaseTable
    fields={[
        { 
            name: "phoneNumber", 
            type: "string", 
            description: "The phone number of the user",
            isUnique: true,
            isOptional: true
        },
        { 
            name: "phoneNumberVerified", 
            type: "boolean", 
            description: "Whether the phone number is verified or not",
            defaultValue: false,
            isOptional: true
        },
    ]}
    />

### OTP Verification Attempts

The phone number plugin includes a built-in protection against brute force attacks by limiting the number of verification attempts for each OTP code.

```typescript
phoneNumber({
  allowedAttempts: 3, // default is 3
  // ... other options
})
```

When a user exceeds the allowed number of verification attempts:
- The OTP code is automatically deleted
- Further verification attempts will return a 403 (Forbidden) status with "Too many attempts" message
- The user will need to request a new OTP code to continue

Example error response after exceeding attempts:
```json
{
  "error": {
    "status": 403,
    "message": "Too many attempts"
  }
}
```

<Callout type="warning">
When receiving a 403 status, prompt the user to request a new OTP code
</Callout>
---
title: Bearer Token Authentication
description: Authenticate API requests using Bearer tokens instead of browser cookies
---

The Bearer plugin enables authentication using Bearer tokens as an alternative to browser cookies. It intercepts requests, adding the Bearer token to the Authorization header before forwarding them to your API.

<Callout type="warn">
  Use this cautiously; it is intended only for APIs that don't support cookies or require Bearer tokens for authentication. Improper implementation could easily lead to security vulnerabilities.
</Callout>

## Installing the Bearer Plugin

Add the Bearer plugin to your authentication setup:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { bearer } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [bearer()]
});
```

## How to Use Bearer Tokens

### 1. Obtain the Bearer Token

After a successful sign-in, you'll receive a session token in the response headers. Store this token securely (e.g., in `localStorage`):

```ts
import { authClient } from "@/lib/auth-client"

const { data } = await authClient.signIn.email({
    email: "user@example.com",
    password: "securepassword"
}, {
  onSuccess: (ctx)=>{
    const authToken = ctx.response.headers.get("set-auth-token") // get the token from the response headers
    // Store the token securely (e.g., in localStorage)
    localStorage.setItem("bearer_token", authToken);
  }
});
```

You can also set this up globally in your auth client:

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"

export const authClient = createAuthClient({
    fetchOptions: {
        onSuccess: (ctx) => {
            const authToken = ctx.response.headers.get("set-auth-token") // get the token from the response headers
            // Store the token securely (e.g., in localStorage)
            if(authToken){
              localStorage.setItem("bearer_token", authToken);
            }
        }
    }
});
```


You may want to clear the token based on the response status code or other conditions:

### 2. Configure the Auth Client

Set up your auth client to include the Bearer token in all requests:

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"

export const authClient = createAuthClient({
    fetchOptions: {
        auth: {
           type:"Bearer",
           token: () => localStorage.getItem("bearer_token") || "" // get the token from localStorage
        }
    }
});
```

### 3. Make Authenticated Requests

Now you can make authenticated API calls:

```ts
import { authClient } from "@/lib/auth-client"

// This request is automatically authenticated
const { data } = await authClient.listSessions();
```

### 4. Per-Request Token (Optional)

You can also provide the token for individual requests:

```ts
import { authClient } from "@/lib/auth-client"

const { data } = await authClient.listSessions({
    fetchOptions: {
        headers: {
            Authorization: `Bearer ${token}`
        }
    }
});
```

### 5. Using Bearer Tokens Outside the Auth Client

The Bearer token can be used to authenticate any request to your API, even when not using the auth client:

```ts title="api-call.ts"
const token = localStorage.getItem("bearer_token");

const response = await fetch("https://api.example.com/data", {
  headers: {
    Authorization: `Bearer ${token}`
  }
});

const data = await response.json();
```

On the server, you can authenticate requests using the `auth.api.getSession` function,
as long as the Authorization Bearer token header is present in the request:


```ts title="session.ts"
import { auth } from "@/lib/auth"

export async function handler(req, res) {
  // Make sure `req.headers` contains the Authorization Bearer token header!
  const session = await auth.api.getSession({
    headers: req.headers
  });
  
  if (!session) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  
  // Process authenticated request
  // ...
}
```


## Options

**requireSignature** (boolean): Require the token to be signed. Default: `false`.
---
title: OAuth 2.1 Provider
description: A Better Auth plugin that enables your auth server to serve as an OAuth 2.1 provider.
---

An **OAuth 2.1 Provider Plugin** that allows you to turn your authentication server into an OAuth provider with OIDC compatibility allowing users and other services to authenticate with your API.

The plugin has a secured configuration by default providing ease to users unfamiliar with the details of OAuth.

**Key Features**:

- **OAuth 2.1**: Restricted security practices to [OAuth 2.1](https://oauth.net/2.1/)
- **Issuer Validation**: Authorization responses include `iss` parameter to prevent [mix-up attacks](https://datatracker.ietf.org/doc/html/rfc9207)
- **MCP Enabled**: Support with [MCP authentication](#mcp)
- **OIDC compatibility**: [OIDC](https://openid.net/specs/openid-connect-core-1_0.html)-compliant with the `openid` scope
  - **UserInfo**: Endpoint providing current user details
  - **id_token**: JWT-signed user information
  - **OIDC Logout**: [RP-initiated](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)-compliant Logout
- **Dynamic Client Registration**: Allow clients to register clients dynamically.
  - **Public Clients**: Support public clients for native mobile clients and user-agent clients (like AI)
  - **Confidential Clients**: Supports confidential clients for web clients
  - **Trusted Clients**: Configure hard-coded trusted clients with optional consent bypass.
- **JWT Plugin compatibility**: required by default with an option to disable
  - **JWT Signing**: sign JWT tokens when requesting a `resource`
  - **JWKS Verifiable**: verify tokens remotely at the [`/jwks`](/docs/plugins/jwt#verifying-the-token) endpoint
- **Authorization Prompts**: prompts that initiate specific login flows
  - **Consent**: Ensure consent is granted for each scope. Forcible with `prompt=consent`.
  - **Select Account**: Ensure an account is selected prior when specific scopes being granted. Forcible with `prompt=select_account`.
- **Resource Endpoints**: Read and manage tokens.
  - **Introspection**: [RFC7662](https://datatracker.ietf.org/doc/html/rfc7662)-compliant Introspection.
  - **Revocation**: [RFC7009](https://datatracker.ietf.org/doc/html/rfc7009)-compliant Revocation.

**Grants Supported**

- **authorization_code**: Code for user token exchange with PKCE and S256 requirements.
- **refresh_token**: Issue refresh tokens and handle access token renewal using `offline_access` scope.
- **client_credentials**: Machine to Machine tokens for API communication.

## Installation

<Steps>
  <Step>
    ### Mount the Plugin

    Add the OIDC plugin to your auth config. See [Configuration Section](#configuration) on how to configure the plugin.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { jwt } from "better-auth/plugins";
    import { oauthProvider } from "@better-auth/oauth-provider"; // [!code highlight]

    const auth = betterAuth({
      disabledPaths: [
        "/token",
      ],
      plugins: [
        jwt(),
        oauthProvider({ // [!code highlight]
          loginPage: "/sign-in", // [!code highlight]
          consentPage: "/consent", // [!code highlight]
          // ...other options // [!code highlight]
        }) // [!code highlight]
      ],
    });
    ```
  </Step>

  <Step>
    ### Migrate the Database

    Run the migration or generate the schema to add the necessary fields and tables to the database.

    <Tabs items={["migrate", "generate"]}>
      <Tab value="migrate">
      ```bash
      npx auth migrate
      ```
      </Tab>
      <Tab value="generate">
      ```bash
      npx auth generate
      ```
      </Tab>
    </Tabs>
    See the [Schema](#schema) section to add the fields manually.
  </Step>

  <Step>
    ### Add `./well-known` endpoints

    Please add all [Well-Known endpoints](#well-known) to your project. The locations are provided as warnings if you are unsure.

    - You **MUST** add the OAuth Authorization Server metadata endpoint at your issuer path (root if no path).
    - If you are using the `openid` scope, you **MUST** add the openid configuration at your issuer path (root if no path).
    - If you are using the resource server (ie for MCP), you **MUST** add the resource server metadata to your API, with the issuer path appended.

  </Step>

  <Step>
    ### Create your first oauth client

    Create your first confidential oauth client.

    ```ts
    const client = await auth.api.createOAuthClient({
			headers,
			body: {
				redirect_uris: [redirectUri],
			}
		});
    console.log(client); // If you wish, you may add the `client_id` to `cachedTrustedClients`
    ```

    <Callout type="info">
    To create a public client (ie. without a client secret), set `token_endpoint_auth_method: "none"`.
    </Callout>
  </Step>
</Steps>


## Client Plugins

There exists two clients. You may wish to add one or both depending on your setup.

### OAuth Client

The OAuth Client is the connecting `oauthClient` such a mobile or web application.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { oauthProviderClient } from "@better-auth/oauth-provider/client" // [!code highlight]

export const authClient = createAuthClient({
  plugins: [
    oauthProviderClient(), // [!code highlight]
  ],
});
```

### Resource Client

The Resource Server is a client that operates on your API server to perform actions like token verification and provide metadata.

```ts title="server-client.ts"
import { auth } from "@/lib/auth";
import { createAuthClient } from "better-auth/client";
import { oauthProviderResourceClient } from "@better-auth/oauth-provider/resource-client" // [!code highlight]

export const serverClient = createAuthClient({
  plugins: [
    oauthProviderResourceClient(auth) // auth optional // [!code highlight]
  ],
});
```


## Usage

The plugin operates as an OAuth 2.1 server with OIDC compatible endpoints and JWT verifiable access tokens. The following provides more detailed information about each endpoint.


### OAuth Clients

In OAuth there are two types of clients:
- **Public Clients**: Cannot store a client secret such as native mobile clients and user-agent clients (like AI)
- **Confidential Clients**: Can store a client secret such as web clients

#### Get Client

To obtain client information owned by a specific user or organization use the following endpoint:

<APIMethod path="/oauth2/get-client" method="GET" requireSession>
```ts
type getOAuthClient = {
  /**
   * The OAuth client's client_id
   */
  client_id: string,
}
```
</APIMethod>

#### Get Public Client

To obtain public client fields to display on login flow pages such as consent, use the following endpoint. Note: the user must be signed in to use this endpoint.:

<APIMethod path="/oauth2/public-client" method="GET" requireSession>
```ts
type getOAuthClientPublic = {
  /**
   * The OAuth client's client_id
   */
  client_id: string,
}
```
</APIMethod>

#### List Clients

To obtain a list of clients owned by a specific user or organization, use the following endpoint:

<APIMethod path="/oauth2/get-clients" method="GET" requireSession>
```ts
type getOAuthClients = {
}
```
</APIMethod>

#### Create Client

To create an oauth client tied to a specific user or organization, use the `/oauth2/create-client` endpoint (eg. `createOAuthClient`). The parameters are equivalent to the registration endpoint described by [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591).

The following fields on the database are considered restricted and should only be editable by admin users.
- `client_secret_expires_at`: The expiration time for a secret of a confidential client
- `skip_consent`: Allows the ability to skip user consent flow. Useful for trusted clients.
- `enable_end_session`: Allows a user to logout of a session from the client via their `id_token` at the `/oauth2/end-session` endpoint. Used in OIDC-setups and specified trusted clients.
- `metadata`: Additional private metadata to attach to the client.

In some cases, you may wish to create logic to create oauth clients with restricted fields through custom APIs, company admin portals, or server initialization, you may use the following server-only endpoint:

```ts title="admin-create-oauth.ts"
import { auth } from "@/lib/auth"

await auth.api.adminCreateOAuthClient({
  headers,
  body: {
    redirect_uris: [redirectUri],
    client_secret_expires_at: 0, // [!code highlight]
    skip_consent: true, // [!code highlight]
    enable_end_session: true, // [!code highlight]
  }
});
```

#### Update Client

To update an oauth client tied to a specific user or organization, use the `/oauth2/update-client` endpoint (eg. `updateOAuthClient`). The parameters are equivalent to the registration endpoint described by [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591).

<APIMethod path="/oauth2/update-client" method="POST" requireSession>
```ts
type updateOAuthClient = {
  /**
   * The OAuth client's client_id
   */
  client_id: string,
  /**
   * The fields to update
   */
  update: OAuthClient,
}
```
</APIMethod>

Restrictions on this endpoint:
- You are unable to switch between confidential and public clients. The client type must be determined at creation.
- You cannot update the client secret. To rotate the `client_secret` use the rotate client secret endpoint.

In some cases, you may wish to create logic to update oauth clients with restricted fields through custom APIs, company admin portals, or server initialization, you may use the following server-only endpoint. The fields are described in the create section.:

```ts title="admin-update-oauth.ts"
import { auth } from "@/lib/auth"

await auth.api.adminUpdateOAuthClient({
  headers,
  body: {
    redirect_uris: [redirectUri],
    client_secret_expires_at: 0, // [!code highlight]
    skip_consent: true, // [!code highlight]
    enable_end_session: true, // [!code highlight]
  }
});
```

#### Rotate Client Secret

<Callout type="warn">
The current implementation rotates the client secret immediately and the previous secret is invalidated immediately.
</Callout>

To rotate a client secret, you must use the following endpoint:

<APIMethod path="/oauth2/client/rotate-secret" method="POST" requireSession>
```ts
type rotateClientSecret = {
  /**
   * The OAuth client's client_id
   */
  client_id: string,
}
```
</APIMethod>

#### Delete Client

To delete a user or organization's client, use the following endpoint:

<APIMethod path="/oauth2/delete-client" method="POST" requireSession>
```ts
type deleteOAuthClient = {
  /**
   * The OAuth client's client_id
   */
  client_id: string,
}
```
</APIMethod>


### OAuth Consent

Consent is required on all non-trusted clients, specifically those without `skip_consent`. The following endpoints allow users or `reference_id` manage their given consents.

#### Get Consent

To obtain details of a specific consent, use the following endpoint:

<APIMethod path="/oauth2/get-consent" method="GET" requireSession>
```ts
type getOAuthConsent = {
  /**
   * The consent id
   */
  id: string,
}
```
</APIMethod>

#### List Consent

To obtain a list of user consents, use the following endpoint:

<APIMethod path="/oauth2/get-consents" method="GET" requireSession>
```ts
type getOAuthConsents = {
}
```
</APIMethod>

#### Update Consent

To update a specific consent, use the following endpoint:

<APIMethod path="/oauth2/update-consent" method="POST" requireSession>
```ts
type updateOAuthClient = {
  /**
   * The consent id
   */
  id: string,
  /**
   * The values to update
   */
  update: OAuthConsent,
}
```
</APIMethod>

#### Delete Consent

Revokes a user's consent for a specific client.

<APIMethod path="/oauth2/delete-consent" method="POST" requireSession>
```ts
type deleteOAuthConsent = {
  /**
   * The consent id
   */
  id: string,
}
```
</APIMethod>


### Dynamic Registration Endpoint

<Callout type="info">
This endpoint supports [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591) compliant client registration.
</Callout>

Once installed, you can utilize the OAuth Provider to manage authentication flows within your application.

After the client is created, you will receive a `client_id` and `client_secret` that you can display to the user. The `client_secret` can only be provided once, ensure the user saves it.

#### Setup

To enable client registration set `allowDynamicClientRegistration: true` in your BetterAuth config.

```ts title="auth.ts"
oauthProvider({
  allowDynamicClientRegistration: true,
  // ... other options
})
```

To enable unauthenticated client registration which allows for dynamically registered public clients, additionally set `allowUnauthenticatedClientRegistration: true` in your auth config.

<Callout type="warn">
Support for `allowUnauthenticatedClientRegistration` **will be deprecated** when the MCP protocol standardizes unauthenticated dynamic client registration. As of writing, both [Client ID Metadata Documents](https://github.com/modelcontextprotocol/modelcontextprotocol/issues/991) and [`software_statement` and `jwks_uri`](https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1032) are under debate.
</Callout>

```ts title="auth.ts"
oauthProvider({
  allowDynamicClientRegistration: true,
  allowUnauthenticatedClientRegistration: true,
  // ... other options
})
```

#### Basic Example

To register a new OIDC client, use the `oauth2.register` method.

```ts
import { authClient } from "@/lib/auth-client"

const client = await authClient.oauth2.register({
  client_name: "My Client",
  redirect_uris: ["https://client.example.com/callback"],
});
```

For all endpoint parameters, see [RFC 7591 Registration](https://datatracker.ietf.org/doc/html/rfc7591#section-2).

Note the following parameters are not yet supported:
- `jwks`
- `jwks_uri`

### Authorize Endpoint

An [OAuth 2.1 authorization endpoint](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#name-authorization-endpoint). Since many of the details are not yet fully described, parts are adapted from the legacy [OAuth 2.0 Authorization Endpoint Section](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1) but always implements the [differences from OAuth 2.0](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#name-differences-from-oauth-20).

The Authorization Endpoint is the entry point for initiating an OAuth 2.1 authorization flows.

Important notes:
- In OAuth 2.1, only `response_type: "code"` is supported.
- `code_challenge_method: "plain"` will not be supported since this is a security vulnerability.
- All authorization responses (success and error) include the `iss` parameter for issuer validation ([RFC 9207](https://datatracker.ietf.org/doc/html/rfc9207)).

**State**

We require sending a state to mitigate cross-site request forgery (CSRF) attacks. This works by ensuring your client only responds to requests that your client initially requested.

Generate a state value from your client and store on your client such as in a secure, HTTP-only cookie or database.

**Code Challenge**

Code challenges helps protect the authorization `code` returned from the authorization endpoint.

To do so, a code challenge is derived from a code verifier and sent in a [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) to the Authorization Server.

Now at your `redirect_uri` (ie callback), check to see if the returned state matches the initial state, use the `authorization_code` grant and original code verifier at the [Token Endpoint](#token-endpoint) to obtain the tokens.


### Token Endpoint

By default, the token endpoint supports providing tokens for the following grants:

- "authorization_code"
- "client_credentials"
- "refresh_token"

#### Authorization code grant

The authorization code grant enables clients to obtain access user access tokens and optionally refresh tokens (with the "offline_access" scope).

#### Client credentials grant

The client credentials grant enables clients to obtain machines to obtain access tokens.

#### Refresh token grant

The refresh token grant enables clients to update their access token without needing the user to login again.

This implementation currently issues a new refresh token for every refresh request.


### Consent Endpoint

Accept or deny user consent for a set of scopes. Note that when denying scopes, the consent cancels and pre-existing consent remains. To remove consent, delete that user's "oauthConsent" for that client.

<APIMethod path="/oauth2/consent" method="POST" requireSession>
```ts
type oauth2Consent = {
  /**
   * Accept or deny user consent for a set of scopes
   */
  accept: boolean,
  /**
   * Space-separated list of accepted scopes. If not provided, the originally requested scopes are accepted.
   */
  scope?: string,
}
```
</APIMethod>

### Continue Endpoint

Sign up registration pages must be [configured](#sign-up-account-screen) to perform account registration steps.
Account selection must be [configured](#select-account-screen) to perform account selection.
Post login must be [configured](#post-login-screen) to perform post login selection.

<APIMethod path="/oauth2/continue" method="POST" requireSession>
```ts
type oauth2Continue = {
  /**
   * Confirms an account was selected.
   */
  selected?: boolean,
  /**
   * Confirms an account was registered
   */
  created?: boolean,
  /**
   * Confirms completion of post login activity
   */
  postLogin?: boolean,
}
```
</APIMethod>


### Introspect Endpoint

[RFC7662](https://datatracker.ietf.org/doc/html/rfc7662)-compliant Introspection.

This endpoint provides details of the provided token. If the token is additionally tied to a session, the endpoint will ensure the session is `active`.

To provide resource specific claims via `customAccessTokenClaims`, store the allowed resources that a confidential client can use in its `resources` field.


### Revoke Endpoint

[RFC7009](https://datatracker.ietf.org/doc/html/rfc7009)-compliant Revocation.

This endpoint revokes the provided token.

- opaque `access_token`: immediately removes that `access_token` from the database. `refresh_token` is still valid.
- JWT `access_token`: verifies that token is safe to remove from client storage.
- `refresh_token`: removes all `access_tokens` granted using that `refresh_token` and removes the `refresh_token` to prevent further token issuance.

For an `access_token` type, 


### End Session Endpoint

[RP-initiated](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)-compliant Logout

This endpoint allows specified trusted clients to logout remotely.

To allow rp-initiated logout, a trusted client must specifically be created to perform session logout.

```ts title="admin-create-oauth.ts"
import { auth } from "@/lib/auth"

await auth.api.adminCreateOAuthClient({
  headers,
  body: {
    redirect_uris: [redirectUri],
    enable_end_session: true, // [!code highlight]
  }
});
```

<Callout type="info">
If `disableJwtPlugin: true`, public clients will never be able to logout using this endpoint since no `id_token` is sent.
</Callout>


### UserInfo Endpoint

The UserInfo Endpoint provides [OIDC](https://openid.net/specs/openid-connect-core-1_0.html)-compliant user information. Available at `/oauth2/userinfo`, the endpoint requires a valid access token with at least the scope `openid`.

```ts
// Example of how a client would use the UserInfo endpoint
const response = await fetch('https://your-domain.com/api/auth/oauth2/userinfo', {
  headers: {
    'Authorization': 'Bearer ACCESS_TOKEN'
  }
});

const userInfo = await response.json();
// userInfo contains user details based on the scopes granted
```

The UserInfo endpoint returns different claims based on the scopes that were granted during authorization:

- `openid`: Returns the user's ID (`sub` claim)
- `profile`: Returns `name`, `picture`, `given_name`, `family_name`
- `email`: Returns `email` and `email_verified`

The `customUserInfoClaims` function receives the user object, requested scopes array, and the passed access token, allowing you to add additional information to the response.


### Well known

#### Openid Configuration

Provides [OpenID connect discovery metadata](https://openid.net/specs/openid-connect-discovery-1_0.html) located at `/.well-known/openid-configuration`.

This endpoint requires the scope `openid`.

You **must** add the configuration at the issuer path. If an issuer is unset, this will be your basePath `/api/auth`.
If this path is not at the root and you don't have an openid-configuration already at the root, we recommend you to add one in case a client incorrectly hard-coded `/.well-known/openid-configuration` (ignoring the issuer path in the spec).

NOTE: For issuers with paths, OpenId utilizes path appending, thus any path on the issuer should be prepended before `/.well-known/openid-configuration`. If no issuer path is specified, the path should start at the root.

```ts title="[issuer-path]/.well-known/openid-configuration/route.ts"
import { oauthProviderOpenIdConfigMetadata } from "@better-auth/oauth-provider";
import { auth } from "@/lib/auth";

export const GET = oauthProviderOpenIdConfigMetadata(auth);
```

<Callout type="info">
If you get a CORS issue when testing locally such as with the [MCP Inspector](https://modelcontextprotocol.io/docs/tools/inspector), this is due to the frontend calling the endpoint instead of the backend. Add `Access-Control-Allow-Methods": "GET"` and `"Access-Control-Allow-Origin": "*"` for testing.
</Callout>


#### OAuth Authorization Server

Provides [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)-compliant metadata located at `/.well-known/oauth-authorization-server`.

You **must** add the configuration at the issuer path. If an issuer is unset, this will be your basePath `/api/auth`.

NOTE: For issuers with paths, OAuth 2.1 Authorization Server utilizes path insertion, thus any path on the issuer should be appended after `/.well-known/oauth-authorization-server`. If no issuer path is specified, the path should start at the root.

```ts title="/.well-known/oauth-authorization-server/[issuer-path]/route.ts"
import { oauthProviderAuthServerMetadata } from "@better-auth/oauth-provider";
import { auth } from "@/lib/auth";

export const GET = oauthProviderAuthServerMetadata(auth);
```

<Callout type="info">
If you get a CORS issue when testing locally such as with the [MCP Inspector](https://modelcontextprotocol.io/docs/tools/inspector), this is due to the frontend calling the endpoint instead of the backend. Add `Access-Control-Allow-Methods": "GET"` and `"Access-Control-Allow-Origin": "*"` for testing.
</Callout>


## API Server

This section shows how your API should verify tokens received from your clients.

### Verification

Verification can be performed using `verifyAccessToken` available through the `oauthProviderResourceClient` plugin or `better-auth/oauth2` package.

With `better-auth` package:

```ts title="api/[endpoint].ts"
import { verifyAccessToken } from "better-auth/oauth2";

export const GET = async (req: Request) => {
  const authorization = req.headers?.get("authorization") ?? undefined;
  const accessToken = authorization?.startsWith("Bearer ")
    ? authorization.replace("Bearer ", "")
    : authorization;
  const payload = await verifyAccessToken(
    accessToken, {
      verifyOptions: {
        issuer: "https://auth.example.com",
        audience: "https://api.example.com",
      },
      scopes: ["read:post"], // optional
    }
  );
  // ...continue
}
```

With `oauthProviderResourceClient` plugin:

```ts title="api/[endpoint].ts"
import { serverClient } from "@/lib/server-client";

export const POST = async (req: Request) => {
  const authorization = req.headers?.get("authorization") ?? undefined;
  const accessToken = authorization?.startsWith("Bearer ")
    ? authorization.replace("Bearer ", "")
    : authorization;
  const payload = await serverClient.verifyAccessToken(
    accessToken, {
      verifyOptions: {
        issuer: "https://auth.example.com",
        audience: "https://api.example.com",
      },
      scopes: ["write:post"], // optional
    }
  );
  // ...continue
}
```

#### JWT Verification

- Verify the token is valid:
  - Validate the _signature_ using the JWKS.
  - Check the `iss` (issuer) and `aud` (audience) claims.
  - Verify the `exp` (expiration) and (if sent) `nbf` claim.
- Validate the appropriate `scope` for each endpoint.

#### Opaque Access Tokens

- Send the received token to `/oauth2/introspect` and assert that `active: true` is returned.
- Validate the appropriate `scope` for each endpoint.

#### Recommendations

The simplest approach is to _only accept JWT-formatted access tokens_ for your API and deny opaque tokens.

**Benefits**:
- **Fast**: locally verifiable, no network call required.
- **Future-proof**: independent of the authorization server after issuance.
- **No client secret needed**: the API can validate tokens without confidential client credentials.

Accepting _opaque access tokens in addition to JWT tokens_ is possible, but comes with trade-offs.

**Benefits**:
- Immediate token and client validation.
- Client does not require a `resource` parameter (depending on authorization server configuration).

**Drawbacks**:
- **DOS**: If the client is external (ie external APIs, MCP agents), opaque `access_token` verifications can overload your authorization server.
- **Performance**: Every received opaque `access_token` requires a network call to the introspection endpoint.
- **Secret required**: Introspection typically requires a `client_secret`, which public clients cannot safely provide.
  - NOTE: Introspection bearer token and Private Key JWT methods are not yet implemented.


### Scopes vs. Permissions

- **Scopes** define what a client application *requests* on behalf of a user. They are usually coarse-grained labels included in an access token.
- **Permissions** define the fine-grained actions a user (or service) is actually allowed to perform on resources, typically enforced at the resource server.

In practice, you may also combine approaches depending on system complexity and how your resource server handles authorization.

**Scopes and Permissions are the Same**

Each scope directly represents a permission.
- Example: A scope `read:post` corresponds exactly to the permission `read:post`.

_Pros_:
- Simple to implement and reason about.
- No extra mapping logic required.

_Cons_:
- Access tokens can become large if permissions are very detailed, especially with JWTs.
- Limited flexibility for future, more granular permissions.

**Scopes and Permissions are Different**

Scopes represent high-level access categories, and each scope maps to one or more underlying permissions.

- **Example:** A scope `view:post` could map to:
  - `read:post:content`
  - `read:post:metadata` (but only for posts the user owns)

_Pros_:
- Flexible and scalable for complex systems.
- Tokens remain compact, since only scopes are included, not all permissions.

_Cons_:
- The resource server must resolve scopes into permissions for each request.
- Adds complexity to implementation and authorization checks.


## Configuration


### Redirect Screens

During the OAuth flow, users are likely redirected between pages. For example, a user may start on a login screen then redirect to a consent screen before returning to the application. The following outlines possible login flows and configurations needed to provide each flow.

To process each redirect step in the login flow, we verify the signed query provided in the initial `/oauth2/authorize` redirect. All parameters sent to the authorize endpoint (including any custom ones), are signed and verified.

If your sign-in pages include any custom query parameters, you may append them to the end of the signed query (ie after the `sig` field).

If you utilize the Client Plugin `oauthProviderClient`, then the `oauth_query` parameter is automatically sent to every endpoint that requires it. If you have custom sign-in endpoints, you would need to manually add the window's signed query in the request body `oauth_query`. This should only include the signed query parameters.


#### Login Screen

When a user is redirected to the OIDC provider for authentication, if they are not already logged in, they will be redirected to the login page. You can customize the login page by providing a `loginPage` option during initialization.

```ts title="auth.ts"
oauthProvider({
  loginPage: "/sign-in" // [!code highlight]
})
```

You don't need to handle anything from your side; when a new session is created, the plugin will handle continuing the authorization flow.


#### Consent Screen

When a user is redirected to the OIDC provider for authentication, they may be prompted to authorize the application to access their data.

**Note**: Trusted clients with `skipConsent: true` will bypass the consent screen entirely, providing a seamless experience for first-party applications.

```ts title="auth.ts"
oauthProvider({
  consentPage: "/consent" // [!code highlight]
})
```

The plugin will redirect the user to the specified path with `client_id` and `scope` query parameters. You can use this information to display a custom consent screen. Once the user consents, you can call `oauth2.consent` to complete the authorization.

```ts title="consent-page.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.oauth2.consent({
	accept: true,
  // optional scopes accepted (if not sent, accepted scopes matches the original request)
  scope: "openid profile email"
});
```


#### Sign Up Account Screen

To direct users from the client to a sign up page using `prompt: create`, use `signup`.

```ts title="auth.ts"
oauthProvider({
  signUp: {
    page: "/sign-up", // [!code highlight]
  }
})
```

To stop sign in process to complete registration forms, use the `shouldRedirect` function.

```ts title="auth.ts"
import { userRegistered } from "@lib/registered";

oauthProvider({
  signUp: {
    page: "/sign-up",
    shouldRedirect: async ({ headers }) => { // [!code highlight]
      const isUserRegistered = await userRegistered(headers);
      return isUserRegistered ? false : "/setup";
    },
  }
})
```


#### Select Account Screen

When a user is redirected to the select account page during authentication, they may be prompted to select an account before consenting. To enable account selection, you must add the following configuration to your settings.

The following example uses the multi-session plugin and automatically redirects to the select-account page if more than one session is logged in:

```ts title="auth.ts"
oauthProvider({
  selectAccount: {
    page: "/select-account", // [!code highlight]
    shouldRedirect: async ({ headers }) => { // [!code highlight]
      const allSessions = await auth.api.listDeviceSessions({
        headers,
      })
      return allSessions?.length >= 1;
    },
  }
})
```

The plugin will redirect the user to the `selectAccount.page`. This page should prompt for account selection and upon completion of selection, should call `oauth2Continue`.

```ts title="select-account.ts"
import { authClient } from "@/lib/auth-client"

await authClient.multiSession.setActive({
  sessionToken,
});
await client.oauth2.oauth2Continue({
  selected: true,
});
```

#### Post Login Screen

If a requested scope requires an organization. You would need to provide all of the following options to tie the `reference_id` (ie organization id, team id) to the login flow. This step occurs post login and prior to consent.

The following example uses the organization plugin to automatically redirect to the select-organization page for organization specific scopes.

```ts title="auth.ts"
oauthProvider({
  scopes: ["openid", "profile", "email", "read:organization"]
  postLogin: {
    page: "/select-organization", // [!code highlight]
    shouldRedirect: async ({ session, scopes, headers }) => { // [!code highlight]
      const userOnlyScopes = ["openid", "profile", "email", "offline_access"];
      if (scopes.every((sc) => userOnlyScopes.includes(sc))) {
        return false;
      }
      const organizations = await auth.api.listOrganizations({
        headers,
      });
      return organizations.length > 1 || !(
        organizations.length === 1 && organizations.at(0)?.id === session.activeOrganizationId
      )
    },
    consentReferenceId: ({ session, scopes }) => { // [!code highlight]
      if (scopes.includes("read:organization")) {
        const activeOrganizationId = (session?.activeOrganizationId ?? undefined) as string | undefined;
        if (!activeOrganizationId) {
          throw new APIError("BAD_REQUEST", {
            error: "set_organization",
            error_description: "must set organization for these scopes",
          })
        }
        return activeOrganizationId;
      } else {
        return undefined;
      }
    },
  }
})
```

The plugin will redirect the user to the `postLogin.page` to provide a prompt for account selection. Upon completion, you should call `oauth2Continue`.

```ts title="select-organization.ts"
import { authClient } from "@/lib/auth-client"

await authClient.organization.setActive({
  organizationId,
});
await client.oauth2.oauth2Continue({
  postLogin: true,
});
```


### Cached Trusted Clients

For first-party applications and internal services, you can cache trusted clients for better performance. Values are cached in memory for all mentioned clients. Additionally, they prevent changes through the CRUD endpoints.

```ts title="auth.ts"
oauthProvider({
  // List of clientIds of the clients
  cachedTrustedClients: new Set([
    "internal-dashboard",
    "mobile-app",
  ]),
})
```

### Valid Audiences

A list of valid audiences (ie resources) for this oauth server. If not specified, the default audience is the baseUrl. It is recommended to specify an audience other than the baseUrl such as your API.

```ts title="auth.ts"
oauthProvider({
  validAudiences: [
    "https://api.example.com",
    "https://api.example.com/mcp",
  ]
})
```

### Scopes

Scopes allow clients specific access to specific resources.
By default, we support the following scopes are supported:

- `openid`: Returns the user's ID (`sub` claim).
- `profile`: Returns name, picture, given_name, family_name
- `email`: Returns email and email_verified
- `offline_access`: Returns a refresh token

The scopes configuration can contain as many or as few scopes as you wish! Note that `openid` is required to be considered an OIDC server, otherwise this is a standard OAuth 2.1 server. All supported scopes must be in this array.

```ts title="auth.ts"
oauthProvider({
  scopes: [ "openid", "profile", "offline_access", "read:post", "write:post" ],
})
```

### Claims

Internally, we support the following claims are supported: ["sub", "iss", "aud", "exp", "iat", "sid", "scope", "azp"].

Id token and user info claims should be namespaced when possible to avoid potential future conflicts.

Claims added inside `customIdTokenClaims` and `customUserInfoClaims` should be added to the `advertisedMetadata.claims_supported` so clients can validate that claim received. In the following example, it would be the base claims plus "locale" and "https://example.com/org".

Pro tip: these functions can may also throw errors such as a user is no longer a member of the organization or no longer has the requested permissions.

```ts title="auth.ts"
oauthProvider({
  // Attach claims to id tokens
  customIdTokenClaims: ({ user, scopes, metadata }) => {
    return {
      locale: "en-GB",
    };
  },
  // Attach claims to access tokens
  customAccessTokenClaims: ({ user, scopes, referenceId, resource, metadata }) => {
    return {
      "https://example.com/org": referenceId,
      "https://example.com/roles": ["editor"],
    };
  },
  // Additional user info claims
  customUserInfoClaims: ({ user, scopes, jwt }) => {
    return {
      locale: "en-GB",
    };
  },
})
```

### Expirations

Each token type and grant type can independently can set a default expiration.

- `accessTokenExpiresIn` defaults 1 hour
- `m2mAccessTokenExpiresIn` defaults 1 hour
- `idTokenExpiresIn` defaults 10 hours
- `refreshTokenExpiresIn` defaults 30 days
- `codeExpiresIn` defaults 10 minutes

Additionally, Access Tokens can set lower expirations based on scopes. This is useful for higher-privilege scopes that require shorter expiration times. The earliest expiration will take precedence. If not specified, the default will take place. Note: values should be lower than the defaults `accessTokenExpiresIn` and `m2mAccessTokenExpiresIn`.

```ts title="auth.ts"
oauthProvider({
  scopeExpirations: {
    "write:payments": "5m",
    "read:payments": "30m",
  },
})
```


### Registration

#### Dynamic Client Registration

Dynamic registration allows for authorized registration of both public and confidential clients.

```ts title="auth.ts"
oauthProvider({
  allowDynamicClientRegistration: true, // [!code highlight]
})
```

Unauthenticated client registration additionally allows for public clients (never confidential) to register without an authorization header. This is especially useful for an MCP to dynamically register themselves as a public client.

```ts title="auth.ts"
oauthProvider({
  allowDynamicClientRegistration: true,
  allowUnauthenticatedClientRegistration: true, // [!code highlight]
})
```

<Callout type="warn">
Support for `allowUnauthenticatedClientRegistration` **will be deprecated** when the MCP protocol standardizes unauthenticated dynamic client registration. As of writing, both [Client ID Metadata Documents](https://github.com/modelcontextprotocol/modelcontextprotocol/issues/991) and [`software_statement` and `jwks_uri`](https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1032) are under debate.
</Callout>

#### Dynamic Client Registration Expiration

You can set an expiration time for how long a dynamically registered confidential client should last for. By default, dynamically registered confidential clients do not expire.

```ts title="auth.ts"
oauthProvider({
  allowDynamicClientRegistration: true,
  clientRegistrationClientSecretExpiration: "30d", // [!code highlight]
})
```

#### Dynamic Client Registration Scopes

To set a list of default scopes for newly registered clients when scopes parameter is not sent, set the `clientRegistrationDefaultScopes` field. All scopes must be defined in `scopes`.

```ts title="auth.ts"
oauthProvider({
  scopes: ["reader", "editor"],
  clientRegistrationDefaultScopes: ["reader"], // [!code highlight]
})
```

To also set a list of allowed scopes for newly registered clients when scopes parameter is not sent, set the `clientRegistrationAllowedScopes` field. These are **in addition** to the `clientRegistrationDefaultScopes`. All scopes must be defined in `scopes`.

```ts title="auth.ts"
oauthProvider({
  scopes: ["reader", "editor"],
  clientRegistrationDefaultScopes: ["reader"],
  clientRegistrationAllowedScopes: ["editor"], // [!code highlight]
})
```


### PKCE Configuration

PKCE (Proof Key for Code Exchange) is a security mechanism that prevents authorization code interception attacks. This plugin follows the OAuth 2.1 specification, which requires PKCE by default for all authorization code flows.

#### Default Behavior

By default, PKCE is required for all clients. This provides maximum security and follows OAuth 2.1 best practices.

**PKCE is always required for:**
- Public clients (native/user-agent-based applications)
- Any authorization request with the `offline_access` scope (refresh tokens)

#### Per-Client PKCE Configuration

Individual clients can opt-out of PKCE requirement during registration if needed for compatibility:

```ts title="register-client.ts"
// Register a confidential client that doesn't support PKCE
const response = await auth.api.createOAuthClient({
  headers,
  body: {
    client_name: 'Legacy Backend Service',
    redirect_uris: ['https://app.example.com/callback'],
    token_endpoint_auth_method: 'client_secret_post',
    grant_types: ['authorization_code'],
    require_pkce: false, // Opt-out of PKCE requirement
  }
});
```

The `require_pkce` field:
- Defaults to `true` (PKCE required)
- Only applies to confidential clients
- Ignored for public clients (PKCE always required)
- Ignored for `offline_access` scope (PKCE always required)

**When to use `require_pkce: false`:**
- Migrating from OAuth 2.0 with legacy confidential clients that don't support PKCE
- Backend-to-backend integrations where updating the client is not feasible
- Temporary compatibility during a phased migration

**Recommendation:** Keep PKCE enabled (default) whenever possible. PKCE provides defense-in-depth even for confidential clients.

#### Migrating from oidc-provider

If you're migrating from the deprecated `oidc-provider` plugin and have confidential clients that don't support PKCE:

1. **For legacy clients, opt-out per-client:**
   Set `require_pkce: false` when registering clients that cannot be updated to support PKCE.

2. **For new clients, use PKCE:**
   New client registrations should always use PKCE (the default) for better security.

3. **Phase out non-PKCE clients:**
   Plan to upgrade or replace clients that don't support PKCE over time.

4. **Monitor usage:**
   Track which clients have `require_pkce: false` for migration planning.

#### Security Considerations

PKCE prevents authorization code interception attacks. Even for confidential clients with client_secret authentication, PKCE provides additional security:

- **Defense in depth**: Multiple security layers
- **Protection against misconfiguration**: Accidental secret exposure
- **Future-proof**: Aligns with OAuth 2.1 best practices

Only disable PKCE for confidential clients when absolutely necessary for legacy compatibility.


### Organizations

OAuth Clients are tied to either a user or `reference_id` at registration and is immutable. If you are utilizing the [organization plugin](/docs/plugins/organization), you must ensure that the [`activeOrganizationId`](/docs/plugins/organization#active-organization) is set on your active session when you create new clients.

```ts title="auth.ts"
oauthProvider({
  clientReference: ({ session }) => {
    return (session?.activeOrganizationId as string | undefined) ?? undefined;
  },
})
```

To set user-specific permissions and roles on tokens see [Claims](#claims).


### Client CRUD Privileges

To determine whether a logged in user has the ability to perform specific actions in client creation, you can utilize the `clientPrivileges` configuration setting. By default, CRUD actions are allowed for users with matching `userId` or `clientReference`.

The following is a basic example that allows all OAuth Client CRUD actions for organization owners assuming ordinary users cannot create clients:

```ts title="auth.ts"
oauthProvider({
  clientPrivileges: async ({ action, headers, user, session }) => {
    if (!session?.activeOrganizationId) return false;
    const { data: member } = await auth.api.getActiveMember({
      headers,
    });
    return member.role === 'owner';
  },
})
```


### Storage

By default all secrets are `hashed` by default on the database. This helps protect the `client_secret` in case of a database leak.

- **storeClientSecret**: the storage method of application `client_secrets`. Only when `disableJwtPlugin: true`, the client secret shall rather be `encrypted`.
- **storeTokens**: the storage method of token values, specifically session refresh tokens and opaque access tokens.


### Rate Limiting

The OAuth Provider includes built-in rate limiting for all OAuth endpoints to protect against abuse and denial-of-service attacks.

<Callout type="info">
Rate limiting is **per-IP per-endpoint**. Each client IP address has its own rate limit counter for each endpoint. Rate limits reset after the window period expires.
</Callout>

<Callout type="warn">
These rate limits only apply when Better Auth's global rate limiting is enabled. By default, rate limiting is only enabled in production. See [Rate Limiting](/docs/concepts/rate-limit) for global configuration.
</Callout>

**Default limits:**

| Endpoint | Window | Max Requests |
|----------|--------|--------------|
| `/oauth2/token` | 60s | 20 |
| `/oauth2/authorize` | 60s | 30 |
| `/oauth2/introspect` | 60s | 100 |
| `/oauth2/revoke` | 60s | 30 |
| `/oauth2/register` | 60s | 5 |
| `/oauth2/userinfo` | 60s | 60 |

You can customize the rate limits for each endpoint:

```ts title="auth.ts"
oauthProvider({
  rateLimit: {
    token: { window: 60, max: 20 },        // 20 requests per minute
    authorize: { window: 60, max: 30 },    // 30 requests per minute
    introspect: { window: 60, max: 100 },  // 100 requests per minute
    revoke: { window: 60, max: 30 },       // 30 requests per minute
    register: { window: 60, max: 5 },      // 5 requests per minute
    userinfo: { window: 60, max: 60 },     // 60 requests per minute
  },
})
```

To remove the per-endpoint rate limit override and fall back to global rate limits, set it to `false`:

```ts title="auth.ts"
oauthProvider({
  rateLimit: {
    introspect: false, // Uses global rate limits instead of per-endpoint limits
  },
})
```

<Callout type="info">
Setting an endpoint to `false` removes the OAuth Provider's stricter per-endpoint limit. The endpoint will still be subject to Better Auth's global rate limiting if enabled.
</Callout>


### Refresh Token Customization

You can choose to format your session tokens in a different string format using the `formatRefreshToken`.

These functions allow you to add additional functionality on the refresh token itself such as refresh token encryption.

Example with change in refresh token format with backwards compatibility with original token-only format:

```ts title="auth.ts"
oauthProvider({
  formatRefreshToken: {
    encrypt: (token, sessionId) => {
      const res = sessionId ? `1.${token}.${sessionId}` : token;
      return res;
    },
    decrypt: (token) => {
      const tokenSplit = token.split('.');
      if (tokenSplit.length === 3 && tokenSplit.at(0) === '1') {
        return {
          token: tokenSplit.at(1),
          sessionId: tokenSplit.at(2),
        };
      }
      return { token };
    },
  }
})
```

Pseudocode for a token encryption method:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { CompactEncrypt, compactDecrypt } from 'jose'
import { oauthProvider } from "@better-auth/oauth-provider"; 

const secret = "SOME_SECRET_OR_KEY"
const alg = "A256KW"
const enc = "A256GCM"

const auth = betterAuth({
  plugins: [
    oauthProvider({
    formatRefreshToken: {
      encrypt: (token, sessionId) {
        const value = JSON.stringify({
          sessionId,
          token,
        });
        const jwe = await new CompactEncrypt(Buffer.from(value))
          .setProtectedHeader({ alg, enc })
          .encrypt(secret);
        return jwe;
      },
      decrypt: (token) {
        const { plaintext } = await compactDecrypt(token, secret);
        const payload = new TextDecoder().decode(plaintext);
        return JSON.parse(payload);
      },
    }
  })
]
})
```


### Advertised Metadata

The metadata endpoint can be customized so that the publicized scopes and claims differ from those which the server can deliver. This can prevent showcasing all your supported scopes and claims on your metadata endpoint.

All scopes inside the advertisedMetadata section MUST be listed in `scopes` otherwise initialization will fail.

#### Scopes

```ts title="auth.ts"
oauthProvider({
  scopes: ["openid", "profile", "email", "offline_access", "read:post"],
  advertisedMetadata: {
    scopes_supported: ["openid", "profile", "read:post"],
  },
})
```

#### Claims

Claims are in addition to the internally supported claims which are automatically determined by `scopes`. Claims are only applicable for the OIDC (ie "openid" scope).

```ts title="auth.ts"
oauthProvider({
  advertisedMetadata: {
    claims_supported: ["https://example.com/roles"],
  },
})
```

### Disable JWT Plugin

By default, access and id tokens can be issued and verified through the JWT plugin.

You can disable the JWT requirement in which access tokens will always be opaque and id tokens are always signed in `HS256` using the `client_secret`. Note that disabling the JWT Plugin is still OIDC compliant, `/userinfo` still works and signed `id_token` is still provided.

Key Differences:
- Providing a valid `resource` will always provide you with an opaque access token instead of an JWT formatted token.
- `id_token` is not returned for public clients, but the `access_token` returned can still utilize the `/oauth2/userinfo` endpoint to obtain the user data.
- `id_token` for a confidential client is signed by their `client_secret`.

```ts title="auth.ts"
oauthProvider({
  disableJwtPlugin: true, // [!code highlight]
})
```


### MCP

You can easily make your APIs [MCP-compatible](https://modelcontextprotocol.io/specification/draft/basic/authorization) simply by adding a resource server which directs users to this OAuth 2.1 authorization server.

<Callout type="info">
If you are using "openid" and confidential MCP clients, you cannot disable the JWT plugin since `id_token` verification may not necessarily be supported via a `client_secret`.
</Callout>

#### Installation

<Steps>
  <Step>
    ### Ensure Well Known Paths are correct

    See [well-known endpoints](#well-known).
  </Step>

  <Step>
    ### Add Resource Server Client

    (Optional) If you have your auth configuration available locally, add the configuration as a parameter to the client to fill in these values and warn you about configuration errors. You can always override these values in the function call. If this is not supplied, typescript will guide you with the minimal configuration values needed.

    ```ts title="server-client.ts"
    import { auth } from "@/lib/auth";
    import { createAuthClient } from "better-auth/client";
    import { oauthProviderResourceClient } from "@better-auth/oauth-provider/resource-client"

    export const serverClient = createAuthClient({
      plugins: [oauthProviderResourceClient(auth)], // auth optional
    });
    ```
  </Step>

  <Step>
    ### Add OAuth Protected Resource Metadata to your API

    ```ts title="/.well-known/oauth-protected-resource/[resource-path]/route.ts"
    import { serverClient } from "@/lib/server-client";

    export const GET = async () => {
      const metadata = await serverClient.getProtectedResourceMetadata({
        resource: "https://api.example.com", // `aud` claim
        authorization_servers: ["https://auth.example.com"],
      })

      return new Response(JSON.stringify(metadata), {
        headers: {
          "Content-Type": "application/json",
          "Cache-Control":
            "public, max-age=15, stale-while-revalidate=15, stale-if-error=86400",
        },
      });
    };
    ```
  </Step>

  <Step>
  If you use `allowUnauthenticatedClientRegistration`, you must ensure that your API Server is a confidential client itself:

  ```ts
  await auth.api.createOAuthClient({
    headers,
    body: {
      redirect_uris: [redirectUri],
    }
  });
  ```

  These values should be used in the verify options `remoteVerify.clientId` and `remoteVerify.clientSecret`. Additionally, `remoteVerify.introspectUrl` would be something like `${BASE_URL}/${AUTH_PATH}/oauth2/introspect`.

  <Callout type="info">
  If you choose to not support `allowUnauthenticatedClientRegistration` (and only `allowDynamicClientRegistration`), the MCP client (ie. ChatGPT, Anthropic, Gemini) would need to allow you to put in a public client_id in their UI or at runtime while chatting with the AI.
  </Callout>
  </Step>

  <Step>
    ### Handle MCP Errors for your API

    Always verify against a specified `audience`, the default will compare against all `validAudiences` or `baseUrl`.

    - Using the client `verifyAccessToken` function

    See [Verification](#verification) for verification examples.

    - With auth available, use the client `verifyAccessToken` function to automatically determine endpoints

    ```ts title="api/[endpoint].ts"
    import { auth } from "@/lib/auth";
    import { serverClient } from "@/lib/server-client";

    export const GET = async (req: Request) => {
      const authorization = req.headers?.get("authorization") ?? undefined;
      const accessToken = authorization?.startsWith("Bearer ")
        ? authorization.replace("Bearer ", "")
        : authorization;
      const payload = await serverClient.verifyAccessToken(
        accessToken, {
          verifyOptions: {
            audience: "https://api.example.com",
          }
        }
      );
      // ...continue
    }
    ```

    - Using `mcpHandler` helper

    ```ts title="api/[transport]/route.ts"
    import { createMcpHandler } from "mcp-handler";
    import { mcpHandler } from "@better-auth/oauth-provider";
    import { z } from "zod";

    const handler = mcpHandler({
      jwksUrl: "https://auth.example.com/api/auth/jwks",
      verifyOptions: {
        issuer: "https://auth.example.com",
        audience: "https://api.example.com",
      },
    }, (req, jwt) => {
      return createMcpHandler(
        (server) => {
          server.registerTool(
            "echo", {
              description: "Echo a message",
              inputSchema: {
                message: z.string(),
              },
            },
            async ({ message }) => {
              return {
                content: [
                  {
                    type: "text",
                    text: `Echo: ${message}${
                      jwt?.sub
                        ? ` for user ${jwt.sub}`
                        : ""
                    }`,
                  },
                ],
              };
            }
          );
        }, {
          serverInfo: {
            name: "demo-better-auth",
            version: "1.0.0",
          }
        }, {
          basePath: "/api",
          maxDuration: 60,
          verboseLogs: true,
        }
      )(req);
    });

    export { handler as GET, handler as POST, handler as DELETE };
    ```
  </Step>
</Steps>


## Schema

The OAuth Provider plugin adds the following tables to the database:

### OAuth Client

Table Name: `oauthClient`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the OAuth client",
      isPrimaryKey: true,
    },
    {
      name: "clientId",
      type: "string",
      description: "Unique identifier for each OAuth client",
      isPrimaryKey: true,
    },
    {
      name: "clientSecret",
      type: "string",
      description: "Secret key for the OAuth client. Optional for public clients using PKCE.",
      isOptional: true,
    },
    {
      name: "disabled",
      type: "boolean",
      description: "Field that indicates if the current application is disabled",
      isOptional: true,
    },
    {
      name: "skipConsent",
      type: "boolean",
      description: "Field that indicates if the application can skip consent. You may choose to enable this for trusted applications.",
      isOptional: true,
    },
    {
      name: "enableEndSession",
      type: "boolean",
      description: "Field that indicates if the application can logout via an id_token. You may choose to enable this for trusted applications.",
      isOptional: true,
    },
    {
      name: "scopes",
      type: "string[]",
      description: "Scopes this client is allowed to use",
      isOptional: true,
    },
    {
      name: "userId",
      type: "string",
      description: "ID of the client owner. (optional)",
      isOptional: true,
      isForeignKey: true,
      references: { model: "user", field: "id" },
    },
    {
      name: "referenceId",
      type: "string",
      description: "ID of the reference of the client owner if not a user. (optional)",
      isOptional: true,
      isForeignKey: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was last updated",
    },
    {
      name: "name",
      type: "string",
      description: "Name of the OAuth client",
      isOptional: true,
    },
    {
      name: "uri",
      type: "string",
      description: "Website Uri displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "icon",
      type: "string",
      description: "Website Icon displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "contacts",
      type: "string[]",
      description: "Client contact list (ie customer service emails, phone numbers) to be displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "tos",
      type: "string",
      description: "Client Terms of Service displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "policy",
      type: "string",
      description: "Client Privacy policy displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "softwareId",
      type: "string",
      description: "Client-defined software identifier. This should remain the same across multiple versions for the same piece of software.",
      isOptional: true,
    },
    {
      name: "softwareVersion",
      type: "string",
      description: "Client-defined version number of the softwareId.",
      isOptional: true,
    },
    {
      name: "softwareStatement",
      type: "string",
      description: "Signed JWT containing the software metadata as signed claims.",
      isOptional: true,
    },
    {
      name: "redirectUris",
      type: "string[]",
      description: "Array of of redirect uris",
      isRequired: true,
    },
    {
      name: "tokenEndpointAuthMethod",
      type: "string",
      description: "Indicator of requested authentication method for the token endpoint. Supports: ['none', 'client_secret_basic', 'client_secret_post']",
      isOptional: true,
    },
    {
      name: "grantTypes",
      type: "string[]",
      description: "Array of supported grant types. Supports: ['authorization_code', 'client_credentials', 'refresh_token']",
      isOptional: true,
    },
    {
      name: "responseTypes",
      type: "string[]",
      description: "Array of supported grant types. Supports: ['code']",
      isOptional: true,
    },
    {
      name: "public",
      type: "boolean",
      description: "Indication if the client is confidential or public",
      isOptional: true,
    },
    {
      name: "type",
      type: "string",
      description: "Type of OAuth client. Supports: ['web', 'native', 'user-agent-based']",
      isOptional: true,
    },
    {
      name: "metadata",
      type: "json",
      description: "Additional metadata for the OAuth client",
      isOptional: true,
    },
  ]}
/>

### OAuth Refresh Token

Table Name: `oauthRefreshToken`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the refresh token",
      isPrimaryKey: true,
    },
    {
      name: "token",
      type: "string",
      description: "Hashed/encrypted refresh token",
      isRequired: true,
    },
    {
      name: "clientId",
      type: "string",
      description: "ID of the OAuth client",
      isForeignKey: true,
      isRequired: true,
      references: { model: "oauthClient", field: "clientId" },
    },
    {
      name: "sessionId",
      type: "string",
      description: "ID of the session used at issuance of the token (and still active)",
      isForeignKey: true,
      isRequired: false,
      references: { model: "session", field: "id" },
    },
    {
      name: "userId",
      type: "string",
      description: "ID of the user associated with the token",
      isForeignKey: true,
      isRequired: true,
      references: { model: "user", field: "id" },
    },
    {
      name: "referenceId",
      type: "string",
      description: "ID of the consented reference",
      isOptional: true,
      isForeignKey: true,
    },
    {
      name: "scopes",
      type: "string[]",
      description: "Array of granted scopes",
      isRequired: true,
    },
    {
      name: "revoked",
      type: "Date",
      description: "Timestamp when the token was revoked",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp when the token was created",
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "Timestamp when the token will expire",
    },
  ]}
/>

### OAuth Access Token

Table Name: `oauthAccessToken`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the opaque access token",
      isPrimaryKey: true,
    },
    {
      name: "token",
      type: "string",
      description: "Hashed/encrypted access token",
      isRequired: true,
    },
    {
      name: "clientId",
      type: "string",
      description: "ID of the OAuth client",
      isForeignKey: true,
      isRequired: true,
      references: { model: "oauthClient", field: "clientId" }
    },
    {
      name: "sessionId",
      type: "string",
      description: "ID of the session used at issuance of the token (and still active)",
      isForeignKey: true,
      isOptional: true,
      references: { model: "session", field: "id" },
    },
    {
      name: "refreshId",
      type: "string",
      description: "ID of the refresh associated with the token",
      isForeignKey: true,
      isOptional: true,
      references: { model: "oauthRefreshToken", field: "id" },
    },
    {
      name: "userId",
      type: "string",
      description: "ID of the user associated with the token",
      isForeignKey: true,
      isOptional: true,
      references: { model: "user", field: "id" },
    },
    {
      name: "referenceId",
      type: "string",
      description: "ID of the consented reference",
      isOptional: true,
      isForeignKey: true,
    },
    {
      name: "scopes",
      type: "string[]",
      description: "Array of granted scopes",
      isRequired: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp when the token was created" 
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "Timestamp when the token will expire",
    },
  ]}
/>

### OAuth Consent

Table Name: `oauthConsent`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the consent",
      isPrimaryKey: true
    },
    {
      name: "userId",
      type: "string",
      description: "ID of the user who gave consent",
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    {
      name: "clientId",
      type: "string",
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthClient", field: "clientId" }
    },
    {
      name: "referenceId",
      type: "string",
      description: "ID of the consented reference",
      isOptional: true,
      isForeignKey: true,
    },
    {
      name: "scopes",
      type: "string",
      description: "Comma-separated list of scopes consented to",
      isRequired: true
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the consent was given" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the consent was last updated"
    },
  ]}
/>

## Options

### Prefix

Add a `prefix` to opaque access tokens, refresh tokens, or client secrets. This is useful for Secret Scanners (ie. [GitHub Secret Scanners](https://docs.github.com/code-security/secret-scanning), [GitGuardian](https://www.gitguardian.com/solutions/secrets-scanning), [Trufflehog](https://github.com/trufflesecurity/trufflehog)) that may rely on the prefix to help determine the token format.

We recommend to add a prefix to each of the following prior to your first production deployment. Once deployed consider them immutable, otherwise the following generate functions as specified:

The following are available under the `prefix` configuration setting:
- **opaqueAccessToken**: `string | undefined` - add a prefix onto opaque access tokens. If previously deployed, utilize `generateOpaqueAccessToken` to perform this functionality instead.
- **refreshToken**: `string | undefined` - add a prefix onto refresh tokens.  If previously deployed, utilize `generateRefreshToken` to perform this functionality instead.
- **clientSecret**:: `string | undefined` - add a prefix onto client secrets.  If previously deployed, utilize `generateClientSecret` to perform this functionality instead.

## Optimizations

To improve lookup performance, database adapters may map the field `client_id` on the table `oauthClient` to `id`. Note that `id` should support strings formatted like UUIDs and urls.

## Migrations

### From [OIDC Provider Plugin](/docs/plugins/oidc-provider)

#### Configuration

- **`idTokenExpiresIn`** now defaults to `10 hours` (previously `1 hour` through `accessTokenExpiresIn`)
- **`refreshTokenExpiresIn`** now defaults to `30 days` (previously `7 days`)
- **`advertisedMetadata`** (previously `metadata`) no longer supports changing metadata fields to prevent accidental misconfiguration.
- **`clientRegistrationDefaultScopes`** (previously `defaultScope`) is now in array format instead of a space-separated string
- **`consentPage`** is now required
- **`getConsentHTML`** is removed in favor of the `consentPage` as raw html is not a response type supported by the authorize endpoint in OAuth
- **`requirePKCE`** (global option) is removed. PKCE is now required by default per OAuth 2.1. Individual clients can opt-out using `require_pkce: false` during registration if needed for legacy compatibility.
- **`allowPlainCodeChallengeMethod`** is removed as the `plain` code challenge is considered less secure than the default `S256` method
- **`customUserInfoClaims`** (previously `getAdditionalUserInfoClaim`) passes the jwt payload instead of the client of the access token used in the request.
- **`storeClientSecret`** now defaults to `hashed`, or `encrypted` if `disableJwtPlugin: true` (previously `plain`).
- JWT plugin now is enabled by default. To disable the plugin, set `disableJwtPlugin: true`.
- Authorization query `code_challenge_method` "S256" must be in caps as described by OAuth 2.1

#### Database

##### Table: `oauthClient`

Previously `oauthApplication`

- If `storeClientSecret` was unset or `plain`, you must hash all the stored `clientSecret` values into its "SHA-256" representation then convert it into base64Url format or use another storage method specified by `storeClientSecret`.
The following function will convert a `plain` representation into the default hash:
```ts
import { createHash } from "@better-auth/utils/hash";
import { base64Url } from "@better-auth/utils/base64";

const defaultHasher = async (value: string) => {
	const hash = await createHash("SHA-256").digest(
		new TextEncoder().encode(value),
	);
	const hashed = base64Url.encode(new Uint8Array(hash), {
		padding: false,
	});
	return hashed;
};
```
- `type` field is no longer a required field. Instead, the schema requires `public` of type `boolean`. Migrate with the following rules:
    - Clients with `type: "public"`: set `type: undefined`, `public: true`, and `clientSecret: undefined`
    - Clients with `type: "native"`: set `public: true` and `clientSecret: undefined`
    - Clients with `type: "user-agent-based"`: set `public: true` and `clientSecret: undefined`
    - Clients with `clientSecret: undefined`: set `public: true`
- `redirectURLs` renamed to `redirectUris`
- `requirePkce` field added (optional, defaults to `true`). For existing confidential clients that don't support PKCE, set `requirePkce: false`.
- `metadata` is now stored in database as individual fields instead of a JSON object. Parse the metadata into their respective fields. The OIDC plugin did not utilize this field but this OAuth plugin may utilize them in the future.

##### Table: `oauthAccessToken`

Option 1 (simple):

You may choose to opt-out of this table conversion with minimal impact. By doing so, users of the existing application will simply need to login again. Simply delete the existing table `oauthAccessToken`.

Option 2 (more complex):

Migrate all tables (you may need to create a clone of `oauthAccessToken` into `oauthRefreshToken` before a migration).

- Convert `oauthAccessToken` with `refreshToken` field into a new `oauthRefreshToken` entry.
```ts
{
  token: defaultHasher(refreshToken),
  expiresAt: refreshTokenExpiresAt,
  clientId: clientId,
  scopes: scopes,
  userId: userId,
  createdAt: createdAt,
  updatedAt: updatedAt,
}
```

- Keep `oauthAccessToken` but reference new `oauthRefreshToken`.
```ts
{
  token: defaultHasher(accessToken),
  expiresAt: accessTokenExpiresAt,
  clientId: clientId,
  scopes: scopes,
  refreshId: oauthRefreshToken.id, // `undefined` if no refreshToken
  createdAt: createdAt,
  updatedAt: updatedAt,
}
```


### From [MCP Plugin](/docs/plugins/mcp)

The MCP endpoints moved from `/mcp` to the `/oauth2` equivalent.

- `/oauth2/authorize` (previously `/mcp/authorize`)
- `/oauth2/token` (previously `/mcp/token`)
- `/oauth2/register` (previously `/mcp/register`)
- `/mcp/get-session` removed as not OAuth 2 compliant, use `/oauth2/introspect` instead
- `/.well-known/oauth-protected-resource` removed, use the helper `mcpHandler` (or manually with the server `api.oAuth2introspectVerify` or the resource client `verifyAccessToken`)
-  Database changes are equivalent to the [From OIDC Provider Plugin](#from-oidc-provider-plugin) section.
---
title: Email OTP
description: Email OTP plugin for Better Auth.
---

The Email OTP plugin allows user to sign in, verify their email, or reset their password using a one-time password (OTP) sent to their email address.


## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    Add the `emailOTP` plugin to your auth config and implement the `sendVerificationOTP()` method.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { emailOTP } from "better-auth/plugins" // [!code highlight]
    
    export const auth = betterAuth({
        // ... other config options
        plugins: [
            emailOTP({ // [!code highlight]
                async sendVerificationOTP({ email, otp, type }) { // [!code highlight]
                    if (type === "sign-in") { // [!code highlight]
                        // Send the OTP for sign in // [!code highlight]
                    } else if (type === "email-verification") { // [!code highlight]
                        // Send the OTP for email verification // [!code highlight]
                    } else { // [!code highlight]
                        // Send the OTP for password reset // [!code highlight]
                    } // [!code highlight]
                }, // [!code highlight]
            }) // [!code highlight]
        ]
    })
    ```
    </Step>
    <Step>
    ### Add the client plugin

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { emailOTPClient } from "better-auth/client/plugins" // [!code highlight]
    
    export const authClient = createAuthClient({
        plugins: [
            emailOTPClient() // [!code highlight]
        ]
    })
    ```
  </Step>
</Steps>

## Usage

### Send an OTP

Use the `sendVerificationOtp()` method to send an OTP to the user's email address.

<APIMethod path="/email-otp/send-verification-otp" method="POST">
```ts
type sendVerificationOTP = {
    /**
     * Email address to send the OTP. 
     */
    email: string = "user@example.com"
    /**
     * Type of the OTP. `sign-in`, `email-verification`, or `forget-password`. 
     */
    type: "email-verification" | "sign-in" | "forget-password" = "sign-in"
}
```
</APIMethod>

### Check an OTP (optional)

Use the `checkVerificationOtp()` method to check if an OTP is valid.

<APIMethod path="/email-otp/check-verification-otp" method="POST">
```ts
type checkVerificationOTP = {
    /**
     * Email address to send the OTP. 
     */
    email: string = "user@example.com"
    /**
     * Type of the OTP. `sign-in`, `email-verification`, or `forget-password`. 
     */
    type: "email-verification" | "sign-in" | "forget-password" = "sign-in"
    /**
     * OTP sent to the email. 
     */
    otp: string = "123456"
}
```
</APIMethod>

### Sign In with OTP

To sign in with OTP, use the `sendVerificationOtp()` method to send a "sign-in" OTP to the user's email address.

<APIMethod path="/email-otp/send-verification-otp" method="POST">
```ts
type sendVerificationOTP = {
    /**
     * Email address to send the OTP. 
     */
    email: string = "user@example.com"
    /**
     * Type of the OTP.
     */
    type: "sign-in" = "sign-in"
}
```
</APIMethod>

Once the user provides the OTP, you can sign in the user using the `signIn.emailOtp()` method.

<APIMethod path="/sign-in/email-otp" method="POST">
```ts
type signInEmailOTP = {
    /**
     * Email address to sign in.
     */
    email: string = "user@example.com"
    /**
     * OTP sent to the email.
     */
    otp: string = "123456"
    /**
     * User display name. Only used when the user is registering for the first time.
     */
    name?: string = "John Doe"
    /**
     * User profile image URL. Only used when the user is registering for the first time.
     */
    image?: string = "https://example.com/image.png"
}
```
</APIMethod>

<Callout>
If the user is not registered, they'll be automatically registered. Configured [additional fields](/docs/concepts/typescript#additional-fields) are also accepted for new users. To prevent automatic sign-up, pass `disableSignUp` as `true` in the [options](#options).
</Callout>

### Verify Email with OTP

To verify the user's email address with OTP, use the `sendVerificationOtp()` method to send an "email-verification" OTP to the user's email address.

<APIMethod path="/email-otp/send-verification-otp" method="POST">
```ts
type sendVerificationOTP = {
    /**
     * Email address to send the OTP. 
     */
    email: string = "user@example.com"
    /**
     * Type of the OTP.
     */
    type: "email-verification" = "email-verification"
}
```
</APIMethod>

Once the user provides the OTP, use the `verifyEmail()` method to complete email verification.

<APIMethod path="/email-otp/verify-email" method="POST">
```ts
type verifyEmailOTP = {
    /**
     * Email address to verify. 
     */
    email: string = "user@example.com"
    /**
     * OTP to verify. 
     */
    otp: string = "123456"
}
```
</APIMethod>

### Reset Password with OTP

To reset the user's password with OTP, use the `emailOtp.requestPasswordReset()` method to send a "forget-password" OTP to the user's email address.

<APIMethod path="/email-otp/request-password-reset" method="POST">
```ts
type requestPasswordResetEmailOTP = {
    /**
     * Email address to send the OTP.
     */
    email: string = "user@example.com"
}
```
</APIMethod>

<Callout type="warn">
The `/forget-password/email-otp` endpoint is deprecated. Please use `/email-otp/request-password-reset` instead.
</Callout>

Once the user provides the OTP, use the `checkVerificationOtp()` method to check if it's valid (optional).

<APIMethod path="/email-otp/check-verification-otp" method="POST">
```ts
type checkVerificationOTP = {
    /**
     * Email address to send the OTP. 
     */
    email: string = "user@example.com"
    /**
     * Type of the OTP.
     */
    type: "forget-password" = "forget-password"
    /**
     * OTP sent to the email. 
     */
    otp: string = "123456"
}
```
</APIMethod>

Then, use the `resetPassword()` method to reset the user's password.

<APIMethod path="/email-otp/reset-password" method="POST">
```ts
type resetPasswordEmailOTP = {
    /**
     * Email address to reset the password. 
     */
    email: string = "user@example.com"
    /**
     * OTP sent to the email. 
     */
    otp: string = "123456"
    /**
     * New password. 
     */
    password: string = "new-secure-password"
}
```
</APIMethod>

### Override Default Email Verification

To override the default email verification, pass `overrideDefaultEmailVerification: true` in the options. This will make the system use an email OTP instead of the default verification link whenever email verification is triggered. In other words, the user will verify their email using an OTP rather than clicking a link.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { emailOTP } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    emailOTP({
      overrideDefaultEmailVerification: true, // [!code highlight]
      async sendVerificationOTP({ email, otp, type }) {
        // Implement the sendVerificationOTP method to send the OTP to the user's email address
      },
    }),
  ],
});
```


## Options

- `sendVerificationOTP`: A function that sends the OTP to the user's email address. The function receives an object with the following properties:
  - `email`: The user's email address.
  - `otp`: The OTP to send.
  - `type`: The type of OTP to send. Can be "sign-in", "email-verification", or "forget-password".

  <Callout type="warn">
  It is recommended to not await the email sending to avoid timing attacks. On serverless platforms, use `waitUntil` or similar to ensure the email is sent.
  </Callout>

- `otpLength`: The length of the OTP. Defaults to `6`.

- `expiresIn`: The expiry time of the OTP in seconds. Defaults to `300` seconds.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { emailOTP } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        emailOTP({
            otpLength: 8,
            expiresIn: 600
        })
    ]
})
```

- `sendVerificationOnSignUp`: A boolean value that determines whether to send the OTP when a user signs up. Defaults to `false`.

- `disableSignUp`: A boolean value that determines whether to prevent automatic sign-up when the user is not registered. Defaults to `false`.

- `generateOTP`: A function that generates the OTP. Defaults to a random 6-digit number.

- `allowedAttempts`: The maximum number of attempts allowed for verifying an OTP. Defaults to `3`. After exceeding this limit, the OTP becomes invalid and the user needs to request a new one.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { emailOTP } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        emailOTP({
            allowedAttempts: 5, // Allow 5 attempts before invalidating the OTP
            expiresIn: 300
        })
    ]
})
```

When the maximum attempts are exceeded, the `verifyOTP`, `signIn.emailOtp`, `verifyEmail`, and `resetPassword` methods will return an error with code `TOO_MANY_ATTEMPTS`.

- `storeOTP`: The method to store the OTP in your database, whether `encrypted`, `hashed` or `plain` text. Default is `plain` text.

<Callout>
Note: This will not affect the OTP sent to the user, it will only affect the OTP stored in your database.
</Callout>

Alternatively, you can pass a custom encryptor or hasher to store the OTP in your database.

**Custom encryptor**

```ts title="auth.ts"
emailOTP({
    storeOTP: { 
        encrypt: async (otp) => {
            return myCustomEncryptor(otp);
        },
        decrypt: async (otp) => {
            return myCustomDecryptor(otp);
        },
    }
})
```

**Custom hasher**

```ts title="auth.ts"
emailOTP({
    storeOTP: {
        hash: async (otp) => {
            return myCustomHasher(otp);
        },
    }
})
```
---
title: Sign In With Ethereum (SIWE)
description: Sign in with Ethereum plugin for Better Auth
---

The Sign in with Ethereum (SIWE) plugin allows users to authenticate using their Ethereum wallets following the [ERC-4361 standard](https://eips.ethereum.org/EIPS/eip-4361). This plugin provides flexibility by allowing you to implement your own message verification and nonce generation logic.

## Installation

<Steps>
    <Step>
        ### Add the Server Plugin

        Add the SIWE plugin to your auth configuration:

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { siwe } from "better-auth/plugins"; // [!code highlight]

        export const auth = betterAuth({
            plugins: [
                siwe({
                    domain: "example.com",
                    emailDomainName: "example.com", // optional
                    anonymous: false, // optional, default is true
                    getNonce: async () => {
                        // Implement your nonce generation logic here
                        return "your-secure-random-nonce";
                    },
                    verifyMessage: async (args) => {
                        // Implement your SIWE message verification logic here
                        // This should verify the signature against the message
                        return true; // return true if signature is valid
                    },
                    ensLookup: async (args) => {
                        // Optional: Implement ENS lookup for user names and avatars
                        return {
                            name: "user.eth",
                            avatar: "https://example.com/avatar.png"
                        };
                    },
                }),
            ],
        });
        ```
    </Step>

    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

    <Step>
        ### Add the Client Plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client";
        import { siweClient } from "better-auth/client/plugins"; // [!code highlight]

        export const authClient = createAuthClient({
        plugins: [
            siweClient() // [!code highlight]
        ]
        });
        ```
    </Step>

</Steps>

## Usage

### Generate a Nonce

Before signing a SIWE message, you need to generate a nonce for the wallet address:

```ts
import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.siwe.nonce({
  walletAddress: "0x1234567890abcdef1234567890abcdef12345678",
  chainId: 1, // optional for Ethereum mainnet, required for other chains. Defaults to 1
});

if (data) {
  console.log("Nonce:", data.nonce);
}
```

### Sign In with Ethereum

After generating a nonce and creating a SIWE message, verify the signature to authenticate:

```ts
import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.siwe.verify({
  message: "Your SIWE message string",
  signature: "0x...", // The signature from the user's wallet
  walletAddress: "0x1234567890abcdef1234567890abcdef12345678",
  chainId: 1, // optional for Ethereum mainnet, required for other chains. Must match Chain ID in SIWE message
  email: "user@example.com", // optional, required if anonymous is false
});

if (data) {
  console.log("Authentication successful:", data.user);
}
```

### Chain-Specific Examples

Here are examples for different blockchain networks:

```ts
// Ethereum Mainnet (chainId can be omitted, defaults to 1)
import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.siwe.verify({
  message,
  signature,
  walletAddress,
  // chainId: 1 (default)
});
```

```ts
// Polygon (chainId REQUIRED)
import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.siwe.verify({
  message,
  signature,
  walletAddress,
  chainId: 137, // Required for Polygon
});
```

```ts
// Arbitrum (chainId REQUIRED)
import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.siwe.verify({
  message,
  signature,
  walletAddress,
  chainId: 42161, // Required for Arbitrum
});
```

```ts
// Base (chainId REQUIRED)
import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.siwe.verify({
  message,
  signature,
  walletAddress,
  chainId: 8453, // Required for Base
});
```

<Callout type="warning">
  The `chainId` must match the Chain ID specified in your SIWE message. Verification will fail with a 401 error if there's a mismatch between the message's Chain ID and the `chainId` parameter.
</Callout>

## Configuration Options

### Server Options

The SIWE plugin accepts the following configuration options:

- **domain**: The domain name of your application (required for SIWE message generation)
- **emailDomainName**: The email domain name for creating user accounts when not using anonymous mode. Defaults to the domain from your base URL
- **anonymous**: Whether to allow anonymous sign-ins without requiring an email. Default is `true`
- **getNonce**: Function to generate a unique nonce for each sign-in attempt. You must implement this function to return a cryptographically secure random string. Must return a `Promise<string>`
- **verifyMessage**: Function to verify the signed SIWE message. Receives message details and should return `Promise<boolean>`
- **ensLookup**: Optional function to lookup ENS names and avatars for Ethereum addresses

### Client Options

The SIWE client plugin doesn't require any configuration options, but you can pass them if needed for future extensibility:

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { siweClient } from "better-auth/client/plugins";

export const authClient = createAuthClient({
  plugins: [
    siweClient({
      // Optional client configuration can go here
    }),
  ],
});
```

## Schema

The SIWE plugin adds a `walletAddress` table to store user wallet associations:

| Field     | Type    | Description                               |
| --------- | ------- | ----------------------------------------- |
| id        | string  | Primary key                               |
| userId    | string  | Reference to user.id                      |
| address   | string  | Ethereum wallet address                   |
| chainId   | number  | Chain ID (e.g., 1 for Ethereum mainnet)   |
| isPrimary | boolean | Whether this is the user's primary wallet |
| createdAt | date    | Creation timestamp                        |

## Example Implementation

Here's a complete example showing how to implement SIWE authentication:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { siwe } from "better-auth/plugins";
import { generateRandomString } from "better-auth/crypto";
import { verifyMessage, createPublicClient, http } from "viem";
import { mainnet } from "viem/chains";

export const auth = betterAuth({
  database: {
    // your database configuration
  },
  plugins: [
    siwe({
      domain: "myapp.com",
      emailDomainName: "myapp.com",
      anonymous: false,
      getNonce: async () => {
        // Generate a cryptographically secure random nonce
        return generateRandomString(32, "a-z", "A-Z", "0-9");
      },
      verifyMessage: async ({ message, signature, address }) => {
        try {
          // Verify the signature using viem (recommended)
          const isValid = await verifyMessage({
            address: address as `0x${string}`,
            message,
            signature: signature as `0x${string}`,
          });
          return isValid;
        } catch (error) {
          console.error("SIWE verification failed:", error);
          return false;
        }
      },
      ensLookup: async ({ walletAddress }) => {
        try {
          // Optional: lookup ENS name and avatar using viem
          // You can use viem's ENS utilities here
          const client = createPublicClient({
            chain: mainnet,
            transport: http(),
          });

          const ensName = await client.getEnsName({
            address: walletAddress as `0x${string}`,
          });

          const ensAvatar = ensName
            ? await client.getEnsAvatar({
                name: ensName,
              })
            : null;

          return {
            name: ensName || walletAddress,
            avatar: ensAvatar || "",
          };
        } catch {
          return {
            name: walletAddress,
            avatar: "",
          };
        }
      },
    }),
  ],
});
```
---
title: Passkey
description: Passkey
---

Passkeys are a secure, passwordless authentication method using cryptographic key pairs, supported by WebAuthn and FIDO2 standards in web browsers. They replace passwords with unique key pairs: a private key stored on the user's device and a public key shared with the website. Users can log in using biometrics, PINs, or security keys, providing strong, phishing-resistant authentication without traditional passwords.

The passkey plugin implementation is powered by [SimpleWebAuthn](https://simplewebauthn.dev/) behind the scenes.

## Installation

<Steps>
    <Step>
        ### Install the plugin

        ```package-install
        npm install @better-auth/passkey
        ```
    </Step>
    <Step>
        ### Add the plugin to your auth config
        To add the passkey plugin to your auth config, you need to import the plugin and pass it to the `plugins` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { passkey } from "@better-auth/passkey" // [!code highlight]

        export const auth = betterAuth({
            plugins: [ 
                passkey(), // [!code highlight]
            ],
        })
        ```
    </Step>
      <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { passkeyClient } from "@better-auth/passkey/client" // [!code highlight]

        export const authClient = createAuthClient({
            plugins: [
                passkeyClient() // [!code highlight]
            ]
        })
        ```
    </Step>

</Steps>

## Usage

### Add/Register a passkey

To add or register a passkey make sure a user is authenticated and then call the `passkey.addPasskey` function provided by the client.

<APIMethod path="/passkey/add-passkey" method="POST" isClientOnly>
```ts
type addPasskey = {
    /**
     * An optional name to label the authenticator account being registered. If not provided, it will default to the user's email address or user ID
    */
    name?: string = "example-passkey-name"
    /**
     * You can also specify the type of authenticator you want to register. Default behavior allows both platform and cross-platform passkeys
    */
    authenticatorAttachment?: "platform" | "cross-platform" = "cross-platform"
}
```
</APIMethod>

<Callout>
 Setting `throw: true` in the fetch options has no effect for the register and sign-in passkey responses — they will always return a data object containing the error object.
</Callout>


### Sign in with a passkey

To sign in with a passkey you can use the `signIn.passkey` method. This will prompt the user to sign in with their passkey.


<APIMethod path="/sign-in/passkey" method="POST" isClientOnly>
```ts
type signInPasskey = {
    /**
     * Browser autofill, a.k.a. Conditional UI. Read more: https://simplewebauthn.dev/docs/packages/browser#browser-autofill-aka-conditional-ui
    */
    autoFill?: boolean = true
}
```
</APIMethod>

#### Example Usage
```ts
import { authClient } from "@/lib/auth-client";

// With post authentication redirect
await authClient.signIn.passkey({
    autoFill: true,
    fetchOptions: {
        onSuccess(context) {
            // Redirect to dashboard after successful authentication
            window.location.href = "/dashboard";
        },
        onError(context) {
            // Handle authentication errors
            console.error("Authentication failed:", context.error.message);
        }
    }
});
```

### List passkeys

You can list all of the passkeys for the authenticated user by calling `passkey.listUserPasskeys`:

<APIMethod
  path="/passkey/list-user-passkeys"
  method="GET"
  requireSession
  resultVariable="passkeys"
>
```ts
type listPasskeys = {
}
```
</APIMethod>

### Deleting passkeys

You can delete a passkey by calling `passkey.delete` and providing the passkey ID.

<APIMethod
  path="/passkey/delete-passkey"
  method="POST"
  requireSession
>
```ts
type deletePasskey = {
    /**
     * The ID of the passkey to delete. 
     */
    id: string = "some-passkey-id"
}
```
</APIMethod>

### Updating passkey names

<APIMethod
  path="/passkey/update-passkey"
  method="POST"
  requireSession
>
```ts
type updatePasskey = {
    /**
     * The ID of the passkey which you want to update.
     */
    id: string = "id of passkey"
    /**
     * The new name which the passkey will be updated to. 
     */
    name: string = "my-new-passkey-name"
}
```
</APIMethod>

### Conditional UI

The plugin supports conditional UI, which allows the browser to autofill the passkey if the user has already registered a passkey.

There are two requirements for conditional UI to work:

<Steps>
    <Step>
        #### Update input fields

        Add the `autocomplete` attribute with the value `webauthn` to your input fields. You can add this attribute to multiple input fields, but at least one is required for conditional UI to work.

        The `webauthn` value should also be the last entry of the `autocomplete` attribute.

        ```html
        <label for="name">Username:</label>
        <input type="text" name="name" autocomplete="username webauthn">
        <label for="password">Password:</label>
        <input type="password" name="password" autocomplete="current-password webauthn">
        ```
    </Step>
    <Step>
        #### Preload the passkeys

        When your component mounts, you can preload the user's passkeys by calling the `authClient.signIn.passkey` method with the `autoFill` option set to `true`.

        To prevent unnecessary calls, we will also add a check to see if the browser supports conditional UI.

        <Tabs items={["React"]}>
            <Tab value="React">
            ```ts
            useEffect(() => {
               if (!PublicKeyCredential.isConditionalMediationAvailable ||
                   !PublicKeyCredential.isConditionalMediationAvailable()) {
                 return;
               }

              void authClient.signIn.passkey({ autoFill: true })
            }, [])
            ```
            </Tab>
        </Tabs>

    </Step>

   </Steps>

Depending on the browser, a prompt will appear to autofill the passkey. If the user has multiple passkeys, they can select the one they want to use.

Some browsers also require the user to first interact with the input field before the autofill prompt appears.

### Debugging

To test your passkey implementation you can use [emulated authenticators](https://developer.chrome.com/docs/devtools/webauthn). This way you can test the registration and sign-in process without even owning a physical device.

## Schema

The plugin require a new table in the database to store passkey data.

Table Name: `passkey`

<DatabaseTable
    fields={[
        { 
            name: "id", 
            type: "string", 
            description: "Unique identifier for each passkey",
            isPrimaryKey: true
        },
        {
            name: "name",
            type: "string",
            description: "The name of the passkey",
            isOptional: true
        },
        { 
            name: "publicKey", 
            type: "string", 
            description: "The public key of the passkey",
        },
        { 
            name: "userId", 
            type: "string", 
            description: "The ID of the user",
            isForeignKey: true
        },
        {
            name: "credentialID",
            type: "string",
            description: "The unique identifier of the registered credential",
        },
        { 
            name: "counter", 
            type: "number", 
            description: "The counter of the passkey",
        },
        {
            name: "deviceType",
            type: "string",
            description: "The type of device used to register the passkey",
        },
        {
            name: "backedUp",
            type: "boolean",
            description: "Whether the passkey is backed up",
        },
        {
            name: "transports",
            type: "string",
            description: "The transports used to register the passkey",
            isOptional: true
        },
        { 
            name: "createdAt", 
            type: "Date", 
            description: "The time when the passkey was created",
            isOptional: true
        },
        {
                name: "aaguid",
                type: "string",
                description: "Authenticator's Attestation GUID indicating the type of the authenticator",
                isOptional: true
        },
    ]}
    />

## Options

**rpID**: A unique identifier for your website based on your auth server origin.
`'localhost'` is okay for local dev. RP ID can be formed by discarding zero or more labels from the left of its effective domain
until it hits an effective TLD. So `www.example.com` can use the RP IDs `www.example.com` or `example.com`. But not `com`, because that's an eTLD.

**rpName**: Human-readable title for your website.

**origin**: The origin URL at which your better-auth server is hosted. `http://localhost` and `http://localhost:PORT` are also valid. Do NOT include any trailing /.

**authenticatorSelection**: Allows customization of WebAuthn authenticator selection criteria. Leave unspecified for default settings.

- `authenticatorAttachment`: Specifies the type of authenticator
    - `platform`: Authenticator is attached to the platform (e.g., fingerprint reader)
    - `cross-platform`: Authenticator is not attached to the platform (e.g., security key)
    - Default: `not set` (both platform and cross-platform allowed, with platform preferred)
- `residentKey`: Determines credential storage behavior.
    - `required`: User MUST store credentials on the authenticator (highest security)
    - `preferred`: Encourages credential storage but not mandatory
    - `discouraged`: No credential storage required (fastest experience)
    - Default: `preferred`
- `userVerification`: Controls biometric/PIN verification during authentication:
    - `required`: User MUST verify identity (highest security)
    - `preferred`: Verification encouraged but not mandatory
    - `discouraged`: No verification required (fastest experience)
    - Default: `preferred`

**advanced**: Advanced options

- `webAuthnChallengeCookie`: Cookie name for storing WebAuthn challenge ID during authentication flow (Default: `better-auth-passkey`)

## Expo Integration

When using the passkey plugin with Expo, you need to configure the `cookiePrefix` option in the Expo client to ensure passkey cookies are properly detected and stored.

By default, the passkey plugin uses `"better-auth-passkey"` as the challenge cookie name. Since this starts with `"better-auth"`, it will work with the default Expo client configuration. However, if you customize the `webAuthnChallengeCookie` option, you must also update the `cookiePrefix` in your Expo client configuration.

### Example Configuration

If you're using a custom cookie name:

```ts title="Server: auth.ts"
import { betterAuth } from "better-auth";
import { passkey } from "@better-auth/passkey";

export const auth = betterAuth({
    plugins: [
        passkey({
            advanced: {
                webAuthnChallengeCookie: "my-app-passkey" // Custom cookie name
            }
        })
    ]
});
```

Make sure to configure your Expo client with the matching prefix:

```ts title="Client: auth-client.ts"
import { createAuthClient } from "better-auth/react";
import { expoClient } from "@better-auth/expo/client";
import { passkeyClient } from "@better-auth/passkey/client";
import * as SecureStore from "expo-secure-store";

export const authClient = createAuthClient({
    baseURL: "http://localhost:8081",
    plugins: [
        expoClient({
            storage: SecureStore,
            cookiePrefix: "my-app" // Must match the prefix of your custom cookie name
        }),
        passkeyClient()
    ]
});
```

If you're using multiple authentication systems or custom cookie names, you can provide an array of prefixes:

```ts title="Client: auth-client.ts"
expoClient({
    storage: SecureStore,
    cookiePrefix: ["better-auth", "my-app", "custom-auth"]
})
```

<Callout type="warn">
  If the `cookiePrefix` doesn't match the prefix of your `webAuthnChallengeCookie`, the passkey authentication flow will fail because the challenge cookie won't be stored and sent back to the server during verification.
</Callout>

For more information on Expo integration, see the [Expo documentation](/docs/integrations/expo).
---
title: Dodo Payments
description: Better Auth Plugin for Dodo Payments
---

[Dodo Payments](https://dodopayments.com) is a global Merchant-of-Record platform that lets AI, SaaS and digital businesses sell in 150+ countries without touching tax, fraud, or compliance. A single, developer-friendly API powers checkout, billing, and payouts so you can launch worldwide in minutes.

<Callout>
  This plugin is maintained by the Dodo Payments team. For bugs, issues or feature requests,
  please visit the [Dodo Payments GitHub repo](https://github.com/dodopayments/dodo-adapters).
</Callout>

<Card
  href="https://discord.gg/bYqAp4ayYh"
  title="Get support on Dodo Payments' Discord"
>
  Have questions? Our team is available on Discord to assist you anytime.
</Card>

## Features

- Automatic customer creation on sign-up
- Type-safe checkout flows with product slug mapping
- Self-service customer portal
- Real-time webhook event processing with signature verification

<Card href="https://app.dodopayments.com" title="Get started with Dodo Payments">
  You need a Dodo Payments account and API keys to use this integration.
</Card>

## Installation

<Steps>
  <Step title="Install dependencies">
    Run the following command in your project root:
```bash
npm install @dodopayments/better-auth dodopayments better-auth zod
```
  
  </Step>
  <Step title="Configure environment variables">
    Add these to your `.env` file:
```txt
DODO_PAYMENTS_API_KEY=your_api_key_here
DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here
```
  </Step>

  <Step title="Set up server-side integration">
    Create or update `src/lib/auth.ts`:
```typescript
import { betterAuth } from "better-auth";
import {
  dodopayments,
  checkout,
  portal,
  webhooks,
} from "@dodopayments/better-auth";
import DodoPayments from "dodopayments";

export const dodoPayments = new DodoPayments({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY!,
  environment: "test_mode"
});

export const auth = betterAuth({
  plugins: [
    dodopayments({
      client: dodoPayments,
      createCustomerOnSignUp: true,
      use: [
        checkout({
          products: [
            {
              productId: "pdt_xxxxxxxxxxxxxxxxxxxxx",
              slug: "premium-plan",
            },
          ],
          successUrl: "/dashboard/success",
          authenticatedUsersOnly: true,
        }),
        portal(),
        webhooks({
          webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!,
          onPayload: async (payload) => {
            console.log("Received webhook:", payload.event_type);
          },
        }),
      ],
    }),
  ],
});
```
    <Card>
      Set `environment` to `live_mode` for production.
    </Card>
  </Step>

  <Step title="Set up client-side integration">
    Create or update `src/lib/auth-client.ts`:
```typescript
import { dodopaymentsClient } from "@dodopayments/better-auth";

export const authClient = createAuthClient({
  baseURL: process.env.BETTER_AUTH_URL || "http://localhost:3000",
  plugins: [dodopaymentsClient()],
});
```
  </Step>
</Steps>

## Usage

### Creating a Checkout Session

```typescript
const { data: checkout, error } = await authClient.dodopayments.checkout({
  slug: "premium-plan",
  customer: {
    email: "customer@example.com",
    name: "John Doe",
  },
  billing: {
    city: "San Francisco",
    country: "US",
    state: "CA",
    street: "123 Market St",
    zipcode: "94103",
  },
  referenceId: "order_123",
});

if (checkout) {
  window.location.href = checkout.url;
}
```

### Accessing the Customer Portal

```typescript
const { data: customerPortal, error } = await authClient.dodopayments.customer.portal();
if (customerPortal && customerPortal.redirect) {
  window.location.href = customerPortal.url;
}
```

### Listing Customer Data

```typescript
// Get subscriptions
const { data: subscriptions, error } =
  await authClient.dodopayments.customer.subscriptions.list({
    query: {
      limit: 10,
      page: 1,
      active: true,
    },
  });

// Get payment history
const { data: payments, error } = await authClient.dodopayments.customer.payments.list({
  query: {
    limit: 10,
    page: 1,
    status: "succeeded",
  },
});
```

### Webhooks

<Card>
  The webhooks plugin processes real-time payment events from Dodo Payments with secure signature verification. The default endpoint is `/api/auth/dodopayments/webhooks`.
</Card>

<Steps>
  <Step title="Generate and set webhook secret">
    Generate a webhook secret for your endpoint URL (e.g., `https://your-domain.com/api/auth/dodopayments/webhooks`) in the Dodo Payments Dashboard and set it in your .env file:
```txt
DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here
```
  </Step>

  <Step title="Handle webhook events">
    Example handler:
```typescript
webhooks({
  webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!,
  onPayload: async (payload) => {
    console.log("Received webhook:", payload.event_type);
  },
});
```
  </Step>
</Steps>

## Configuration Reference

### Plugin Options

- **client** (required): DodoPayments client instance
- **createCustomerOnSignUp** (optional): Auto-create customers on user signup  
- **use** (required): Array of plugins to enable (checkout, portal, webhooks)

### Checkout Plugin Options

- **products**: Array of products or async function returning products
- **successUrl**: URL to redirect after successful payment
- **authenticatedUsersOnly**: Require user authentication (default: false)

If you encounter any issues, please refer to the [Dodo Payments documentation](https://docs.dodopayments.com) for troubleshooting steps.
---
title: Device Authorization
description: OAuth 2.0 Device Authorization Grant for limited-input devices
---

`RFC 8628` `CLI` `Smart TV` `IoT`

The Device Authorization plugin implements the OAuth 2.0 Device Authorization Grant ([RFC 8628](https://datatracker.ietf.org/doc/html/rfc8628)), enabling authentication for devices with limited input capabilities such as smart TVs, CLI applications, IoT devices, and gaming consoles.

## Try It Out

You can test the device authorization flow right now using the Better Auth CLI:

```package-install
npx auth login
```

This will demonstrate the complete device authorization flow by:
1. Requesting a device code from the Better Auth demo server
2. Displaying a user code for you to enter
3. Opening your browser to the verification page
4. Polling for authorization completion

<Callout type="info">
  The CLI login command is a demo feature that connects to the Better Auth demo server to showcase the device authorization flow in action.
</Callout>

## Installation

<Steps>
    <Step>
        ### Add the plugin to your auth config
        
        Add the device authorization plugin to your server configuration.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { deviceAuthorization } from "better-auth/plugins"; // [!code highlight]

        export const auth = betterAuth({
          // ... other config
          plugins: [
            deviceAuthorization({ // [!code highlight]
              verificationUri: "/device", // [!code highlight]
            }), // [!code highlight]
          ],
        });
        ```
    </Step>
    
    <Step>
        ### Migrate the database
        
        Run the migration or generate the schema to add the necessary tables to the database.
        
        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

    <Step>
        ### Add the client plugin
        
        Add the device authorization plugin to your client.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client";
        import { deviceAuthorizationClient } from "better-auth/client/plugins"; // [!code highlight]

        export const authClient = createAuthClient({
          plugins: [
            deviceAuthorizationClient(), // [!code highlight]
          ],
        });
        ```
    </Step>
</Steps>

## How It Works

The device flow follows these steps:

1. **Device requests codes**: The device requests a device code and user code from the authorization server
2. **User authorizes**: The user visits a verification URL and enters the user code
3. **Device polls for token**: The device polls the server until the user completes authorization
4. **Access granted**: Once authorized, the device receives an access token

## Basic Usage

### Requesting Device Authorization

To initiate device authorization, call `device.code` with the client ID:

<APIMethod
  path="/device/code"
  method="POST"
>
```ts
type deviceCode = {
    /**
     * The OAuth client identifier
     */
    client_id: string;
    /**
     * Space-separated list of requested scopes (optional)
     */
    scope?: string;
}
```
</APIMethod>

Example usage:
```ts
import { authClient } from "@/lib/auth-client"

const { data } = await authClient.device.code({
  client_id: "your-client-id",
  scope: "openid profile email",
});

if (data) {
  console.log(`User code: ${data.user_code}`);
  console.log(`Verification URL: ${data.verification_uri}`);
  console.log(`Complete verification URL: ${data.verification_uri_complete}`);
}
```

### Polling for Token

After displaying the user code, poll for the access token:

<APIMethod
  path="/device/token"
  method="POST"
>
```ts
type deviceToken = {
    /**
     * Must be "urn:ietf:params:oauth:grant-type:device_code"
     */
    grant_type: string;
    /**
     * The device code from the initial request
     */
    device_code: string;
    /**
     * The OAuth client identifier
     */
    client_id: string;
}
```
</APIMethod>

Example polling implementation:
```ts
let pollingInterval = 5; // Start with 5 seconds
const pollForToken = async () => {
  const { data, error } = await authClient.device.token({
    grant_type: "urn:ietf:params:oauth:grant-type:device_code",
    device_code,
    client_id: yourClientId,
    fetchOptions: {
      headers: {
        "user-agent": `My CLI`,
      },
    },
  });

  if (data?.access_token) {
    console.log("Authorization successful!");
  } else if (error) {
    switch (error.error) {
      case "authorization_pending":
        // Continue polling
        break;
      case "slow_down":
        pollingInterval += 5;
        break;
      case "access_denied":
        console.error("Access was denied by the user");
        return;
      case "expired_token":
        console.error("The device code has expired. Please try again.");
        return;
      default:
        console.error(`Error: ${error.error_description}`);
        return;
    }
    setTimeout(pollForToken, pollingInterval * 1000);
  }
};

pollForToken();
```

### User Authorization Flow

The user authorization flow requires two steps:
1. **Code Verification**: Check if the entered user code is valid
2. **Authorization**: User must be authenticated to approve/deny the device

<Callout type="warn">
  Users must be authenticated before they can approve or deny device authorization requests. If not authenticated, redirect them to the login page with a return URL.
</Callout>

Create a page where users can enter their code:

```tsx title="app/device/page.tsx"
export default function DeviceAuthorizationPage() {
  const [userCode, setUserCode] = useState("");
  const [error, setError] = useState(null);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      // Format the code: remove dashes and convert to uppercase
      const formattedCode = userCode.trim().replace(/-/g, "").toUpperCase();

      // Check if the code is valid using GET /device endpoint
      const response = await authClient.device({
        query: { user_code: formattedCode },
      });
      
      if (response.data) {
        // Redirect to approval page
        window.location.href = `/device/approve?user_code=${formattedCode}`;
      }
    } catch (err) {
      setError("Invalid or expired code");
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={userCode}
        onChange={(e) => setUserCode(e.target.value)}
        placeholder="Enter device code (e.g., ABCD-1234)"
        maxLength={12}
      />
      <button type="submit">Continue</button>
      {error && <p>{error}</p>}
    </form>
  );
}
```

### Approving or Denying Device

Users must be authenticated to approve or deny device authorization requests:

#### Approve Device

<APIMethod
  path="/device/approve"
  method="POST"
  requireSession
>
```ts
type deviceApprove = {
    /**
     * The user code to approve
     */
    userCode: string;
}
```
</APIMethod>

#### Deny Device

<APIMethod
  path="/device/deny"
  method="POST"
  requireSession
>
```ts
type deviceDeny = {
    /**
     * The user code to deny
     */
    userCode: string;
}
```
</APIMethod>

#### Example Approval Page

```tsx title="app/device/approve/page.tsx"
export default function DeviceApprovalPage() {
  const { user } = useAuth(); // Must be authenticated
  const searchParams = useSearchParams();
  const userCode = searchParams.get("userCode");
  const [isProcessing, setIsProcessing] = useState(false);
  
  const handleApprove = async () => {
    setIsProcessing(true);
    try {
      await authClient.device.approve({
        userCode: userCode,
      });
      // Show success message
      alert("Device approved successfully!");
      window.location.href = "/";
    } catch (error) {
      alert("Failed to approve device");
    }
    setIsProcessing(false);
  };
  
  const handleDeny = async () => {
    setIsProcessing(true);
    try {
      await authClient.device.deny({
        userCode: userCode,
      });
      alert("Device denied");
      window.location.href = "/";
    } catch (error) {
      alert("Failed to deny device");
    }
    setIsProcessing(false);
  };

  if (!user) {
    // Redirect to login if not authenticated
    window.location.href = `/login?redirect=/device/approve?user_code=${userCode}`;
    return null;
  }
  
  return (
    <div>
      <h2>Device Authorization Request</h2>
      <p>A device is requesting access to your account.</p>
      <p>Code: {userCode}</p>
      
      <button onClick={handleApprove} disabled={isProcessing}>
        Approve
      </button>
      <button onClick={handleDeny} disabled={isProcessing}>
        Deny
      </button>
    </div>
  );
}
```

## Advanced Configuration

### Client Validation

You can validate client IDs to ensure only authorized applications can use the device flow:

```ts
deviceAuthorization({
  validateClient: async (clientId) => {
    // Check if client is authorized
    const client = await db.oauth_clients.findOne({ id: clientId });
    return client && client.allowDeviceFlow;
  },
  
  onDeviceAuthRequest: async (clientId, scope) => {
    // Log device authorization requests
    await logDeviceAuthRequest(clientId, scope);
  },
})
```

### Custom Code Generation

Customize how device and user codes are generated:

```ts
deviceAuthorization({
  generateDeviceCode: async () => {
    // Custom device code generation
    return crypto.randomBytes(32).toString("hex");
  },
  
  generateUserCode: async () => {
    // Custom user code generation
    // Default uses: ABCDEFGHJKLMNPQRSTUVWXYZ23456789
    // (excludes 0, O, 1, I to avoid confusion)
    const charset = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let code = "";
    for (let i = 0; i < 8; i++) {
      code += charset[Math.floor(Math.random() * charset.length)];
    }
    return code;
  },
})
```

## Error Handling

The device flow defines specific error codes:

| Error Code | Description |
|------------|-------------|
| `authorization_pending` | User hasn't approved yet (continue polling) |
| `slow_down` | Polling too frequently (increase interval) |
| `expired_token` | Device code has expired |
| `access_denied` | User denied the authorization |
| `invalid_grant` | Invalid device code or client ID |

## Example: CLI Application

Here's a complete example for a CLI application based on the actual demo:

<Callout type="info">
  To use the access token for API requests, ensure you have added the [Bearer plugin](/docs/plugins/bearer) to your auth instance.
</Callout>

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { deviceAuthorizationClient } from "better-auth/client/plugins";
import open from "open";

const authClient = createAuthClient({
  baseURL: "http://localhost:3000",
  plugins: [deviceAuthorizationClient()],
});

async function authenticateCLI() {
  console.log("🔐 Better Auth Device Authorization Demo");
  console.log("⏳ Requesting device authorization...");
  
  try {
    // Request device code
    const { data, error } = await authClient.device.code({
      client_id: "demo-cli",
      scope: "openid profile email",
    });
    
    if (error || !data) {
      console.error("❌ Error:", error?.error_description);
      process.exit(1);
    }
    
    const {
      device_code,
      user_code,
      verification_uri,
      verification_uri_complete,
      interval = 5,
    } = data;
    
    console.log("\n📱 Device Authorization in Progress");
    console.log(`Please visit: ${verification_uri}`);
    console.log(`Enter code: ${user_code}\n`);
    
    // Open browser to verification page
    const urlToOpen = verification_uri_complete || verification_uri;
    console.log("🌐 Opening browser...");
    await open(urlToOpen);
    
    console.log(`⏳ Waiting for authorization... (polling every ${interval}s)`);
    
    // Poll for token
    await pollForToken(device_code, interval);
  } catch (err) {
    console.error("❌ Error:", err.message);
    process.exit(1);
  }
}

async function pollForToken(deviceCode: string, interval: number) {
  let pollingInterval = interval;
  
  return new Promise<void>((resolve) => {
    const poll = async () => {
      try {
        const { data, error } = await authClient.device.token({
          grant_type: "urn:ietf:params:oauth:grant-type:device_code",
          device_code: deviceCode,
          client_id: "demo-cli",
        });
        
        if (data?.access_token) {
          console.log("\nAuthorization Successful!");
          console.log("Access token received!");
          
          // Get user session
          const { data: session } = await authClient.getSession({
            fetchOptions: {
              headers: {
                Authorization: `Bearer ${data.access_token}`,
              },
            },
          });
          
          console.log(`Hello, ${session?.user?.name || "User"}!`);
          resolve();
          process.exit(0);
        } else if (error) {
          switch (error.error) {
            case "authorization_pending":
              // Continue polling silently
              break;
            case "slow_down":
              pollingInterval += 5;
              console.log(`⚠️  Slowing down polling to ${pollingInterval}s`);
              break;
            case "access_denied":
              console.error("❌ Access was denied by the user");
              process.exit(1);
              break;
            case "expired_token":
              console.error("❌ The device code has expired. Please try again.");
              process.exit(1);
              break;
            default:
              console.error("❌ Error:", error.error_description);
              process.exit(1);
          }
        }
      } catch (err) {
        console.error("❌ Network error:", err.message);
        process.exit(1);
      }
      
      // Schedule next poll
      setTimeout(poll, pollingInterval * 1000);
    };
    
    // Start polling
    setTimeout(poll, pollingInterval * 1000);
  });
}

// Run the authentication flow
authenticateCLI().catch((err) => {
  console.error("❌ Fatal error:", err);
  process.exit(1);
});
```

## Security Considerations

1. **Rate Limiting**: The plugin enforces polling intervals to prevent abuse
2. **Code Expiration**: Device and user codes expire after the configured time (default: 30 minutes)
3. **Client Validation**: Always validate client IDs in production to prevent unauthorized access
4. **HTTPS Only**: Always use HTTPS in production for device authorization
5. **User Code Format**: User codes use a limited character set (excluding similar-looking characters like 0/O, 1/I) to reduce typing errors
6. **Authentication Required**: Users must be authenticated before they can approve or deny device requests

## Options

### Server

**verificationUri**: The URL of the verification page where users can enter their device code. Match this to the route of your verification page. Returned as `verification_uri` in the response. Can be an absolute URL (e.g., `https://example.com/device`) or relative path (e.g., `/device`). Default: `/device`.

**expiresIn**: The expiration time for device codes. Default: `"30m"` (30 minutes).

**interval**: The minimum polling interval. Default: `"5s"` (5 seconds).

**userCodeLength**: The length of the user code. Default: `8`.

**deviceCodeLength**: The length of the device code. Default: `40`.

**generateDeviceCode**: Custom function to generate device codes. Returns a string or `Promise<string>`.

**generateUserCode**: Custom function to generate user codes. Returns a string or `Promise<string>`.

**validateClient**: Function to validate client IDs. Takes a clientId and returns boolean or `Promise<boolean>`.

**onDeviceAuthRequest**: Hook called when device authorization is requested. Takes clientId and optional scope.

### Client

No client-specific configuration options. The plugin adds the following methods:

- **device()**: Verify user code validity
- **device.code()**: Request device and user codes
- **device.token()**: Poll for access token  
- **device.approve()**: Approve device (requires authentication)
- **device.deny()**: Deny device (requires authentication)

## Schema

The plugin requires a new table to store device authorization data.

Table Name: `deviceCode`

<DatabaseTable
    fields={[
        { 
            name: "id", 
            type: "string", 
            description: "Unique identifier for the device authorization request",
            isPrimaryKey: true
        },
        {
            name: "deviceCode",
            type: "string",
            description: "The device verification code",
        },
        {
            name: "userCode",
            type: "string",
            description: "The user-friendly code for verification",
        },
        { 
            name: "userId", 
            type: "string", 
            description: "The ID of the user who approved/denied",
            isOptional: true,
            isForeignKey: true
        },
        {
            name: "clientId",
            type: "string",
            description: "The OAuth client identifier",
            isOptional: true
        },
        {
            name: "scope",
            type: "string",
            description: "Requested OAuth scopes",
            isOptional: true
        },
        {
            name: "status",
            type: "string",
            description: "Current status: pending, approved, or denied",
        },
        {
            name: "expiresAt",
            type: "Date",
            description: "When the device code expires",
        },
        {
            name: "lastPolledAt",
            type: "Date",
            description: "Last time the device polled for status",
            isOptional: true
        },
        {
            name: "pollingInterval",
            type: "number",
            description: "Minimum seconds between polls",
            isOptional: true
        },
        {
            name: "createdAt",
            type: "Date",
            description: "When the request was created",
        },
        {
            name: "updatedAt",
            type: "Date",
            description: "When the request was last updated",
        }
    ]}
/>
---
title: Two-Factor Authentication (2FA)
description: Enhance your app's security with two-factor authentication.
---

`OTP` `TOTP` `Backup Codes` `Trusted Devices`

Two-Factor Authentication (2FA) adds an extra security step when users log in. Instead of just using a password, they'll need to provide a second form of verification. This makes it much harder for unauthorized people to access accounts, even if they've somehow gotten the password.

This plugin offers two main methods to do a second factor verification:

1. **OTP (One-Time Password)**: A temporary code sent to the user's email or phone.
2. **TOTP (Time-based One-Time Password)**: A code generated by an app on the user's device.

**Additional features include:**
- Generating backup codes for account recovery
- Enabling/disabling 2FA
- Managing trusted devices

## Installation

<Steps>
    <Step>
        ### Add the plugin to your auth config

        Add the two-factor plugin to your auth configuration and specify your app name as the issuer.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { twoFactor } from "better-auth/plugins" // [!code highlight]

        export const auth = betterAuth({
            // ... other config options
            appName: "My App", // provide your app name. It'll be used as an issuer. // [!code highlight]
            plugins: [
                twoFactor() // [!code highlight]
            ]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

        <Step>
        ### Add the client plugin

        Add the client plugin and Specify where the user should be redirected if they need to verify 2nd factor

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { twoFactorClient } from "better-auth/client/plugins" // [!code highlight]

        export const authClient = createAuthClient({
            plugins: [
                twoFactorClient() // [!code highlight]
            ]
        })
        ```
        </Step>
</Steps>

## Usage

### Enabling 2FA

To enable two-factor authentication, call `twoFactor.enable` with the user's password and issuer (optional):

<APIMethod
  path="/two-factor/enable"
  method="POST"
  requireSession
>
```ts
type enableTwoFactor = {
    /**
     * The user's password
     */
    password: string = "secure-password"
    /**
     * An optional custom issuer for the TOTP URI. Defaults to app-name defined in your auth config.
     */
    issuer?: string = "my-app-name"
}
```
</APIMethod>

When 2FA is enabled:
- An encrypted `secret` and `backupCodes` are generated.
- `enable` returns `totpURI` and `backupCodes`.

Note: `twoFactorEnabled` won’t be set to `true` until the user verifies their TOTP code. Learn more about verifying TOTP [here](#totp). You can skip verification by setting `skipVerificationOnEnable` to true in your plugin config.

<Callout type="warn">
Two Factor can only be enabled for credential accounts at the moment. For social accounts, it's assumed the provider already handles 2FA.
</Callout>

### Sign In with 2FA

When a user with 2FA enabled tries to sign in via email, the response object will contain `twoFactorRedirect` set to `true`. This indicates that the user needs to verify their 2FA code.

You can handle this in the `onSuccess` callback or by providing a `onTwoFactorRedirect` callback in the plugin config.

```tsx
import { authClient } from "@/lib/auth-client"

await authClient.signIn.email({
        email: "user@example.com",
        password: "password123",
    },
    {
        async onSuccess(context) {
            if (context.data.twoFactorRedirect) {
                // Handle the 2FA verification in place
            }
        },
    }
)
```

Using the `onTwoFactorRedirect` config:

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { twoFactorClient } from "better-auth/client/plugins";

const authClient = createAuthClient({
    plugins: [
        twoFactorClient({
            onTwoFactorRedirect(){
                // Handle the 2FA verification globally
            },
        }),
    ],
});
```




<Callout type="warn">
**With `auth.api`**

When you call `auth.api.signInEmail` on the server, and the user has 2FA enabled, it will return an object where `twoFactorRedirect` is set to `true`. This behavior isn’t inferred in TypeScript, which can be misleading. You can check using `in` instead to check if `twoFactorRedirect` is set to `true`.

```ts title="sign-in.ts"
import { auth } from "@/lib/auth"

const response = await auth.api.signInEmail({
	body: {
		email: "test@test.com",
		password: "test",
	},
});

if ("twoFactorRedirect" in response) {
	// Handle the 2FA verification in place
}
```
</Callout>

### Disabling 2FA

To disable two-factor authentication, call `twoFactor.disable` with the user's password:

<APIMethod
  path="/two-factor/disable"
  method="POST"
  requireSession
>
```ts
type disableTwoFactor = {
    /**
     * The user's password
     */
    password: string
}
```
</APIMethod>

### TOTP

TOTP (Time-Based One-Time Password) is an algorithm that generates a unique password for each login attempt using time as a counter. Every fixed interval (Better Auth defaults to 30 seconds), a new password is generated. This addresses several issues with traditional passwords: they can be forgotten, stolen, or guessed. OTPs solve some of these problems, but their delivery via SMS or email can be unreliable (or even risky, considering it opens new attack vectors).

TOTP, however, generates codes offline, making it both secure and convenient. You just need an authenticator app on your phone.

#### Getting TOTP URI

After enabling 2FA, you can get the TOTP URI to display to the user. This URI is generated by the server using the `secret` and `issuer` and can be used to generate a QR code for the user to scan with their authenticator app.

<APIMethod
  path="/two-factor/get-totp-uri"
  method="POST"
  requireSession
>
```ts
type getTOTPURI = {
    /**
     * The user's password
     */
    password: string
}
```
</APIMethod>


**Example: Using React**

Once you have the TOTP URI, you can use it to generate a QR code for the user to scan with their authenticator app.

```tsx
import { authClient } from "@/lib/auth-client"
import QRCode from "react-qr-code";

export default function UserCard({ password }: { password: string }){
    const { data: session } = authClient.useSession();
	const { data: qr } = useQuery({
		queryKey: ["two-factor-qr"],
		queryFn: async () => {
			const res = await authClient.twoFactor.getTotpUri({ password });
			return res.data;
		},
		enabled: !!session?.user.twoFactorEnabled,
	});
    return (
        <QRCode value={qr?.totpURI || ""} />
   )
}
```

<Callout>
By default the issuer for TOTP is set to the app name provided in the auth config or if not provided it will be set to `Better Auth`. You can override this by passing `issuer` to the plugin config.
</Callout>

#### Verifying TOTP

After the user has entered their 2FA code, you can verify it using `twoFactor.verifyTotp` method. `Better Auth` follows standard practice by accepting TOTP codes from one period before and one after the current code, ensuring users can authenticate even with minor time delays on their end.

<APIMethod path="/two-factor/verify-totp" method="POST">
```ts
type verifyTOTP = {
    /**
     * The otp code to verify. 
     */
    code: string = "012345"
    /**
     * If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. 
     */
    trustDevice?: boolean = true
}
```
</APIMethod>

### OTP

OTP (One-Time Password) is similar to TOTP but a random code is generated and sent to the user's email or phone.

Before using OTP to verify the second factor, you need to configure `sendOTP` in your Better Auth instance. This function is responsible for sending the OTP to the user's email, phone, or any other method supported by your application.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { twoFactor } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        twoFactor({
          	otpOptions: {
				async sendOTP({ user, otp }, ctx) {
                    // send otp to user
				},
			},
        })
    ]
})
```

#### Sending OTP

Sending an OTP is done by calling the `twoFactor.sendOtp` function. This function will trigger your sendOTP implementation that you provided in the Better Auth configuration.

<APIMethod path="/two-factor/send-otp" method="POST">
```ts
type send2FaOTP = {
    /**
     * If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. 
     */
    trustDevice?: boolean = true
}

if (data) {
    // redirect or show the user to enter the code
}
```
</APIMethod>

#### Verifying OTP

After the user has entered their OTP code, you can verify it

<APIMethod path="/two-factor/verify-otp" method="POST">
```ts
type verifyOTP = {
    /**
     * The otp code to verify. 
     */
    code: string = "012345"
    /**
     * If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. 
     */
    trustDevice?: boolean = true
}
```
</APIMethod>

### Backup Codes

Backup codes are generated and stored in the database. This can be used to recover access to the account if the user loses access to their phone or email.

#### Generating Backup Codes
Generate backup codes for account recovery:

<APIMethod
  path="/two-factor/generate-backup-codes"
  method="POST"
  requireSession
>
```ts
type generateBackupCodes = {
    /**
     * The users password. 
     */
    password: string
}

if (data) {
    // Show the backup codes to the user
}
```
</APIMethod>


<Callout type="warn">
When you generate backup codes, the old backup codes will be deleted and new ones will be generated.
</Callout>

#### Using Backup Codes

You can now allow users to provide a backup code as an account recovery method.


<APIMethod path="/two-factor/verify-backup-code" method="POST">
```ts
type verifyBackupCode = {
    /**
     * A backup code to verify. 
     */
    code: string = "123456"
    /**
     * If true, the session cookie will not be set. 
     */
    disableSession?: boolean = false
    /**
     * If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. 
     */
    trustDevice?: boolean = true
}
```
</APIMethod>

<Callout>
Once a backup code is used, it will be removed from the database and can't be used again.
</Callout>

#### Viewing Backup Codes

To display the backup codes to the user, you can call `viewBackupCodes` on the server. This will return the backup codes in the response. You should only do this if the user has a fresh session - a session that was just created.

<APIMethod
  path="/two-factor/view-backup-codes"
  method="POST"
  isServerOnly
  forceAsBody
>
```ts
type viewBackupCodes = {
    /**
     * The user ID to view all backup codes. 
     */
    userId?: string | null = "user-id"
}
```
</APIMethod>

### Trusted Devices

You can mark a device as trusted by passing `trustDevice` to `verifyTotp` or `verifyOtp`.

```ts
const verify2FA = async (code: string) => {
    const { data, error } = await authClient.twoFactor.verifyTotp({
        code,
        trustDevice: true, // Mark this device as trusted // [!code highlight]
    })
    if (data) {
        // 2FA verified and device trusted
    }
}
```

When `trustDevice` is set to `true`, the current device will be remembered for 30 days. During this period, the user won't be prompted for 2FA on subsequent sign-ins from this device. The trust period is refreshed each time the user signs in successfully.

### Issuer

By adding an `issuer` you can set your application name for the 2fa application.

For example, if your user uses Google Auth, the default appName will show up as `Better Auth`. However, by using the following code, it will show up as `my-app-name`.

```ts
twoFactor({
    issuer: "my-app-name" // [!code highlight]
})
```
---

## Schema

The plugin requires 1 additional field in the `user` table and 1 additional table to store the two factor authentication data.

Table: `user`

<DatabaseTable
    fields={[
        { name: "twoFactorEnabled", type: "boolean", description: "Whether two factor authentication is enabled for the user.", isOptional: true },
    ]}
/>

Table: `twoFactor`

<DatabaseTable
    fields={[
        { name: "id", type: "string", description: "The ID of the two factor authentication.", isPrimaryKey: true },
        { name: "userId", type: "string", description: "The ID of the user", isForeignKey: true },
        { name: "secret", type: "string", description: "The secret used to generate the TOTP code.", isOptional: true },
        { name: "backupCodes", type: "string", description: "The backup codes used to recover access to the account if the user loses access to their phone or email.", isOptional: true },
    ]}
/>

## Options

### Server

**twoFactorTable**: The name of the table that stores the two factor authentication data. Default: `twoFactor`.

**skipVerificationOnEnable**: Skip the verification process before enabling two factor for a user.

**Issuer**: The issuer is the name of your application. It's used to generate TOTP codes. It'll be displayed in the authenticator apps.

**TOTP options**

these are options for TOTP.

<TypeTable
  type={{
    digits:{
        description: "The number of digits the otp to be",
        type: "number",
        default: 6,
    },
    period: {
        description: "The period for totp in seconds.",
        type: "number",
        default: 30,
    },
  }}
/>

**OTP options**

these are options for OTP.

<TypeTable
  type={{
    sendOTP: {
        description: "a function that sends the otp to the user's email or phone number. It takes two parameters: user and otp",
        type: "function",
    },
    period: {
        description: "The period for otp in minutes.", 
        type: "number",
        default: 3,
    },
    storeOTP: {
        description: "How to store the otp in the database. Whether to store it as plain text, encrypted or hashed. You can also provide a custom encryptor or hasher.",
        type: "string",
        default: "plain",
    },
  }}
  />

**Backup Code Options**

backup codes are generated and stored in the database when the user enabled two factor authentication. This can be used to recover access to the account if the user loses access to their phone or email.

<TypeTable
    type={{
        amount: {
            description: "The amount of backup codes to generate",
            type: "number",
            default: 10,
        },
        length: {
            description: "The length of the backup codes",
            type: "number",
            default: 10,
        },
        customBackupCodesGenerate: {
            description: "A function that generates custom backup codes. It takes no parameters and returns an array of strings.",
            type: "function",
        },
        storeBackupCodes: {
            description: "How to store the backup codes in the database. Whether to store it as plain text or encrypted. You can also provide a custom encryptor.",
            type: "string",
            default: "plain",
        },
    }}
/>

### Client

To use the two factor plugin in the client, you need to add it on your plugins list.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { twoFactorClient } from "better-auth/client/plugins"

const authClient =  createAuthClient({
    plugins: [
        twoFactorClient({ // [!code highlight]
            onTwoFactorRedirect(){ // [!code highlight]
                window.location.href = "/2fa" // Handle the 2FA verification redirect // [!code highlight]
            } // [!code highlight]
        }) // [!code highlight]
    ]
})
```


**Options**

`onTwoFactorRedirect`: A callback that will be called when the user needs to verify their 2FA code. This can be used to redirect the user to the 2FA page.
---
title: API Key
description: API Key plugin for Better Auth.
---

The API Key plugin allows you to create and manage API keys for your application. It provides a way to authenticate and authorize API requests by verifying API keys.

## Features

- Create, manage, and verify API keys
- [Built-in rate limiting](/docs/plugins/api-key#rate-limiting)
- [Custom expiration times, remaining count, and refill systems](/docs/plugins/api-key#remaining-refill-and-expiration)
- [metadata for API keys](/docs/plugins/api-key#metadata)
- Custom prefix
- [Sessions from API keys](/docs/plugins/api-key#sessions-from-api-keys)
- [Secondary storage support](/docs/plugins/api-key#secondary-storage) for high-performance API key lookups

## Installation

<Steps>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { apiKey } from "better-auth/plugins" // [!code highlight]

        export const auth = betterAuth({
            plugins: [
                apiKey() // [!code highlight]
            ]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { apiKeyClient } from "better-auth/client/plugins"  // [!code highlight]

        export const authClient = createAuthClient({
            plugins: [
                apiKeyClient() // [!code highlight]
            ]
        })
        ```
    </Step>

</Steps>

## Usage

You can view the list of API Key plugin options [here](/docs/plugins/api-key#api-key-plugin-options).

### Create an API key

<APIMethod
  path="/api-key/create"
  method="POST"
  serverOnlyNote="If you're creating an API key on the server, without access to headers, you must pass the `userId` property. This is the ID of the user that the API key is associated with."
  clientOnlyNote="You can adjust more specific API key configurations by using the server method instead."
>
```ts
type createApiKey = {
    /**
     * Name of the Api Key.
     */
    name?: string = 'project-api-key'
    /**
     * Expiration time of the Api Key in seconds.
     */
    expiresIn?: number = 60 * 60 * 24 * 7
    /**
     * User Id of the user that the Api Key belongs to. server-only.
     * @serverOnly
     */
    userId?: string = "user-id"
    /**
     * Prefix of the Api Key.
     */
    prefix?: string = 'project-api-key'
    /**
     * Remaining number of requests. server-only.
     * @serverOnly
     */
    remaining?: number = 100
    /**
     * Metadata of the Api Key.
     */
    metadata?: any | null = { someKey: 'someValue' }
    /**
     * Amount to refill the remaining count of the Api Key. server-only.
     * @serverOnly
     */
    refillAmount?: number = 100
    /**
     * Interval to refill the Api Key in milliseconds. server-only.
     * @serverOnly
     */
    refillInterval?: number = 1000
    /**
     * The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only.
     * @serverOnly
     */
    rateLimitTimeWindow?: number = 1000
    /**
     * Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only.
     * @serverOnly
     */
    rateLimitMax?: number = 100
    /**
     * Whether the key has rate limiting enabled. server-only.
     * @serverOnly
     */
    rateLimitEnabled?: boolean = true
    /**
     * Permissions of the Api Key.
     * @serverOnly
     */
    permissions?: Record<string, string[]>
}
```
</APIMethod>

<Callout>API keys are assigned to a user.</Callout>

#### Result

It'll return the `ApiKey` object which includes the `key` value for you to use.
Otherwise if it throws, it will throw an `APIError`.

---

### Verify an API key

<APIMethod
  path="/api-key/verify"
  method="POST"
  isServerOnly
>
```ts
const permissions = { // Permissions to check are optional.
  projects: ["read", "read-write"],
}

type verifyApiKey = {
    /**
     * The key to verify.
     */
    key: string = "your_api_key_here"
    /**
     * The permissions to verify. Optional.
     */
    permissions?: Record<string, string[]>
}
```
</APIMethod>


#### Result

```ts
type Result = {
  valid: boolean;
  error: { message: string; code: string } | null;
  key: Omit<ApiKey, "key"> | null;
};
```

---

### Get an API key

<APIMethod
  path="/api-key/get"
  method="GET"
  requireSession
>
```ts
type getApiKey = {
    /**
     * The id of the Api Key.
     */
    id: string = "some-api-key-id"
}
```
</APIMethod>

#### Result

You'll receive everything about the API key details, except for the `key` value itself.
If it fails, it will throw an `APIError`.

```ts
type Result = Omit<ApiKey, "key">;
```

---

### Update an API key

<APIMethod path="/api-key/update" method="POST">
```ts
type updateApiKey = {
    /**
     * The id of the Api Key to update.
     */
    keyId: string = "some-api-key-id"
    /**
     * The id of the user which the api key belongs to. server-only.
     * @serverOnly
     */
    userId?: string = "some-user-id"
    /**
     * The name of the key.
     */
    name?: string = "some-api-key-name"
    /**
     * Whether the Api Key is enabled or not. server-only.
     * @serverOnly
     */
    enabled?: boolean = true
    /**
     * The number of remaining requests. server-only.
     * @serverOnly
     */
    remaining?: number = 100
    /**
     * The refill amount. server-only.
     * @serverOnly
     */
    refillAmount?: number = 100
    /**
     * The refill interval in milliseconds. server-only.
     * @serverOnly
     */
    refillInterval?: number = 1000
    /**
     * The metadata of the Api Key. server-only.
     * @serverOnly
     */
    metadata?: any | null = { "key": "value" }
    /**
     * Expiration time of the Api Key in seconds. server-only.
     * @serverOnly
     */
    expiresIn?: number = 60 * 60 * 24 * 7
    /**
     * Whether the key has rate limiting enabled. server-only.
     * @serverOnly
     */
    rateLimitEnabled?: boolean = true
    /**
     * The duration in milliseconds where each request is counted. server-only.
     * @serverOnly
     */
    rateLimitTimeWindow?: number = 1000
    /**
     * Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only.
     * @serverOnly
     */
    rateLimitMax?: number = 100
    /**
     * Update the permissions on the API Key. server-only.
     * @serverOnly
     */
    permissions?: Record<string, string[]>
}
```
</APIMethod>

#### Result

If fails, throws `APIError`.
Otherwise, you'll receive the API Key details, except for the `key` value itself.

---

### Delete an API Key

<APIMethod
  path="/api-key/delete"
  method="POST"
  requireSession
  note="This endpoint is attempting to delete the API key from the perspective of the user. It will check if the user's ID matches the key owner to be able to delete it. If you want to delete a key without these checks, we recommend you use an ORM to directly mutate your DB instead."
>
```ts
type deleteApiKey = {
    /**
     * The id of the Api Key to delete.
     */
    keyId: string = "some-api-key-id"
}
```
</APIMethod>

#### Result

If fails, throws `APIError`.
Otherwise, you'll receive:

```ts
type Result = {
  success: boolean;
};
```

---

### List API keys

<APIMethod
  path="/api-key/list"
  method="GET"
  requireSession
>
```ts
type listApiKeys = {
    /**
     * The number of API keys to return.
     */
    limit?: number
    /**
     * The offset to start from (for pagination).
     */
    offset?: number
    /**
     * The field to sort by (e.g., "createdAt", "name", "expiresAt").
     */
    sortBy?: string
    /**
     * The direction to sort by.
     */
    sortDirection?: "asc" | "desc"
}
```
</APIMethod>

#### Result

If fails, throws `APIError`.
Otherwise, you'll receive a paginated response:

```ts
type Result = {
  apiKeys: Omit<ApiKey, "key">[];
  total: number;
  limit?: number;
  offset?: number;
};
```

#### Pagination Examples

```ts
// Get first 10 API keys
const result = await authClient.apiKey.list({
  query: { limit: 10 }
});

// Get second page (10 items per page)
const page2 = await authClient.apiKey.list({
  query: { limit: 10, offset: 10 }
});

// Sort by creation date (newest first)
const sorted = await authClient.apiKey.list({
  query: { sortBy: "createdAt", sortDirection: "desc" }
});

// Combined pagination and sorting
const combined = await authClient.apiKey.list({
  query: { 
    limit: 20, 
    offset: 0, 
    sortBy: "name", 
    sortDirection: "asc" 
  }
});
```

---

### Delete all expired API keys

This function will delete all API keys that have an expired expiration date.

<APIMethod
  path="/api-key/delete-all-expired-api-keys"
  method="POST"
  isServerOnly
>
```ts
type deleteAllExpiredApiKeys = {
}
```
</APIMethod>

<Callout>
  We automatically delete expired API keys every time any apiKey plugin
  endpoints were called, however they are rate-limited to a 10 second cool down
  each call to prevent multiple calls to the database.
</Callout>

---

## Sessions from API keys

Any time an endpoint in Better Auth is called that has a valid API key in the headers, you can automatically create a mock session to represent the user by enabling `sessionForAPIKeys` option.

<Callout type="warn">
 This is generally not recommended, as it can lead to security issues if not used carefully. A leaked api key can be used to impersonate a user.
</Callout>

<Callout>
  **Rate Limiting Note**: When `enableSessionForAPIKeys` is enabled, the API key is validated once per request, and rate limiting is applied accordingly.
  If you manually verify an API key and then fetch a session separately, both operations will increment the rate limit counter. Using `enableSessionForAPIKeys` avoids this double increment.
</Callout>

```ts
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      enableSessionForAPIKeys: true,
    }),
  ],
});
```

<Tabs items={['Server']}>
    <Tab value="Server">
      ```ts
      import { auth } from "@/lib/auth"
      
      const session = await auth.api.getSession({
            headers: new Headers({
                  'x-api-key': apiKey,
            }),
      });
      ```
    </Tab>
</Tabs>


The default header key is `x-api-key`, but this can be changed by setting the `apiKeyHeaders` option in the plugin options.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      apiKeyHeaders: ["x-api-key", "xyz-api-key"], // or you can pass just a string, eg: "x-api-key"
    }),
  ],
});
```

Or optionally, you can pass an `apiKeyGetter` function to the plugin options, which will be called with the `GenericEndpointContext`, and from there, you should return the API key, or `null` if the request is invalid.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      apiKeyGetter: (ctx) => {
        const has = ctx.request.headers.has("x-api-key");
        if (!has) return null;
        return ctx.request.headers.get("x-api-key");
      },
    }),
  ],
});
```

## Storage Modes

The API Key plugin supports multiple storage modes for flexible API key management, allowing you to choose the best strategy for your use case.

### Storage Mode Options

#### `"database"` (Default)

Store API keys only in the database adapter. This is the default mode and requires no additional configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      storage: "database", // Default, can be omitted
    }),
  ],
});
```

#### `"secondary-storage"`

Store API keys only in secondary storage (e.g., Redis).
No fallback to database. Best for high-performance scenarios where all keys are migrated to secondary storage.

```ts title="auth.ts"
import { createClient } from "redis";
import { betterAuth } from "better-auth";
import { apiKey } from "better-auth/plugins";

const redis = createClient();
await redis.connect();

export const auth = betterAuth({
  secondaryStorage: {
    get: async (key) => await redis.get(key),
    set: async (key, value, ttl) => {
      if (ttl) await redis.set(key, value, { EX: ttl });
      else await redis.set(key, value);
    },
    delete: async (key) => await redis.del(key),
  },
  plugins: [
    apiKey({
      storage: "secondary-storage",
    }),
  ],
});
```

#### Secondary Storage with Fallback

Check secondary storage first, then fallback to database if not found.

**Read behavior:**
- Checks secondary storage first
- If not found, queries the database
- **Automatically populates secondary storage** when falling back to database (cache warming)
- Ensures frequently accessed keys stay in cache over time

**Write behavior:**
- Writes to **both** database and secondary storage
- Ensures consistency between both storage layers

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { createClient } from "redis";

const redis = createClient();
await redis.connect();

export const auth = betterAuth({
  secondaryStorage: {
    get: async (key) => await redis.get(key),
    set: async (key, value, ttl) => {
      if (ttl) await redis.set(key, value, { EX: ttl });
      else await redis.set(key, value);
    },
    delete: async (key) => await redis.del(key),
  },
  plugins: [
    apiKey({
      storage: "secondary-storage",
      fallbackToDatabase: true,
    }),
  ],
});
```

### Custom Storage Methods

You can provide custom storage methods specifically for API keys, overriding the global `secondaryStorage` configuration:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      storage: "secondary-storage",
      customStorage: {
        get: async (key) => {
          // Custom get logic for API keys
          return await customStorage.get(key);
        },
        set: async (key, value, ttl) => {
          // Custom set logic for API keys
          await customStorage.set(key, value, ttl);
        },
        delete: async (key) => {
          // Custom delete logic for API keys
          await customStorage.delete(key);
        },
      },
    }),
  ],
});
```

## Rate Limiting

Every API key can have its own rate limit settings. The built-in rate-limiting applies whenever an API key is validated, which includes:
- When verifying an API key via the `/api-key/verify` endpoint
- When using API keys for session creation (if `enableSessionForAPIKeys` is enabled), rate limiting applies to all endpoints that use the API key

For other endpoints/methods that don't use API keys, you should utilize Better Auth's [built-in rate-limiting](/docs/concepts/rate-limit).

<Callout type="warn">
  **Double Rate-Limit Increment**: If you manually verify an API key using `verifyApiKey()` and then fetch a session using `getSession()` with the same API key header, both operations will increment the rate limit counter, resulting in two increments for a single request. To avoid this, either:
  
  - Use `enableSessionForAPIKeys: true` and let Better Auth handle session creation automatically (recommended)
  - Or verify the API key once and reuse the validated result instead of calling both methods separately
</Callout>

You can refer to the rate-limit default configurations below in the API Key plugin options.

An example default value:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      rateLimit: {
        enabled: true,
        timeWindow: 1000 * 60 * 60 * 24, // 1 day
        maxRequests: 10, // 10 requests per day
      },
    }),
  ],
});
```

For each API key, you can customize the rate-limit options on create.

<Callout>
  You can only customize the rate-limit options on the server auth instance.
</Callout>

```ts title="create-api-key.ts"
import { auth } from "@/lib/auth"

const apiKey = await auth.api.createApiKey({
  body: {
    rateLimitEnabled: true,
    rateLimitTimeWindow: 1000 * 60 * 60 * 24, // 1 day
    rateLimitMax: 10, // 10 requests per day
  },
  headers: await headers() // headers containing the user's session token
});
```

### How does it work?

The rate limiting system uses a sliding window approach:

1. **First Request**: When an API key is used for the first time (no previous `lastRequest`), the request is allowed and `requestCount` is set to 1.

2. **Within Window**: For subsequent requests within the `timeWindow`, the `requestCount` is incremented. If `requestCount` reaches `rateLimitMax`, the request is rejected with a `RATE_LIMITED` error code.

3. **Window Reset**: If the time since the last request exceeds the `timeWindow`, the window resets: `requestCount` is reset to 1 and `lastRequest` is updated to the current time.

4. **Rate Limit Exceeded**: When a request is rejected due to rate limiting, the error response includes a `tryAgainIn` value (in milliseconds) indicating how long to wait before the window resets.

**Disabling Rate Limiting**:
- **Globally**: Set `rateLimit.enabled: false` in plugin options
- **Per Key**: Set `rateLimitEnabled: false` when creating or updating an API key
- **Null Values**: If `rateLimitTimeWindow` or `rateLimitMax` is `null`, rate limiting is effectively disabled for that key

When rate limiting is disabled (globally or per-key), requests are still allowed but `lastRequest` is updated for tracking purposes.

## Remaining, refill, and expiration

The remaining count is the number of requests left before the API key is disabled.
The refill interval is the interval in milliseconds where the `remaining` count is refilled when the interval has passed since the last refill (or since creation if no refill has occurred yet).
The expiration time is the expiration date of the API key.

### How does it work?

#### Remaining:

Whenever an API key is used, the `remaining` count is updated.
If the `remaining` count is `null`, then there is no cap to key usage.
Otherwise, the `remaining` count is decremented by 1.
If the `remaining` count is 0, then the API key is disabled & removed.

#### refillInterval & refillAmount:

Whenever an API key is created, the `refillInterval` and `refillAmount` are set to `null` by default.
This means that the API key will not be refilled automatically.
However, if both `refillInterval` & `refillAmount` are set, then whenever the API key is used:
- The system checks if the time since the last refill (or since creation if no refill has occurred) exceeds the `refillInterval`
- If the interval has passed, the `remaining` count is reset to `refillAmount` (not incremented)
- The `lastRefillAt` timestamp is updated to the current time

#### Expiration:

Whenever an API key is created, the `expiresAt` is set to `null`.
This means that the API key will never expire.
However, if the `expiresIn` is set, then the API key will expire after the `expiresIn` time.

## Custom Key generation & verification

You can customize the key generation and verification process straight from the plugin options.

Here's an example:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      customKeyGenerator: (options: {
        length: number;
        prefix: string | undefined;
      }) => {
        const apiKey = mySuperSecretApiKeyGenerator(
          options.length,
          options.prefix
        );
        return apiKey;
      },
      customAPIKeyValidator: async ({ ctx, key }) => {
        const res = await keyService.verify(key)
        return res.valid
      },
    }),
  ],
});
```

<Callout>
If you're **not** using the `length` property provided by `customKeyGenerator`, you **must** set the `defaultKeyLength` property to how long generated keys will be.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      customKeyGenerator: () => {
        return crypto.randomUUID();
      },
      defaultKeyLength: 36, // Or whatever the length is
    }),
  ],
});
```

</Callout>

If an API key is validated from your `customAPIKeyValidator`, we still must match that against the database's key.
However, by providing this custom function, you can improve the performance of the API key verification process,
as all failed keys can be invalidated without having to query your database.

## Metadata

We allow you to store metadata alongside your API keys. This is useful for storing information about the key, such as a subscription plan for example.

To store metadata, make sure you haven't disabled the metadata feature in the plugin options.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      enableMetadata: true,
    }),
  ],
});
```

Then, you can store metadata in the `metadata` field of the API key object.

```ts title="create-api-key.ts"
import { auth } from "@/lib/auth"

const apiKey = await auth.api.createApiKey({
  body: {
    metadata: { // [!code highlight]
      plan: "premium", // [!code highlight]
    }, // [!code highlight]
  },
});
```

You can then retrieve the metadata from the API key object.

```ts title="get-api-key.ts"
import { auth } from "@/lib/auth"

const apiKey = await auth.api.getApiKey({
  body: {
    keyId: "your_api_key_id_here",
  },
});

console.log(apiKey.metadata.plan); // "premium"
```

## API Key plugin options

`apiKeyHeaders` <span className="opacity-70">`string | string[];`</span>

The header name to check for API key. Default is `x-api-key`.

`customAPIKeyGetter` <span className="opacity-70">`(ctx: GenericEndpointContext) => string | null`</span>

A custom function to get the API key from the context.

`customAPIKeyValidator` <span className="opacity-70">`(options: { ctx: GenericEndpointContext; key: string; }) => boolean | Promise<boolean>`</span>

A custom function to validate the API key.

`customKeyGenerator` <span className="opacity-70">`(options: { length: number; prefix: string | undefined; }) => string | Promise<string>`</span>

A custom function to generate the API key.

`startingCharactersConfig` <span className="opacity-70">`{ shouldStore?: boolean; charactersLength?: number; }`</span>

Customize the starting characters configuration.

<Accordions>
  <Accordion title="startingCharactersConfig Options">
    `shouldStore` <span className="opacity-70">`boolean`</span>

    Whether to store the starting characters in the database.
    If false, we will set `start` to `null`.
    Default is `true`.

    `charactersLength` <span className="opacity-70">`number`</span>

    The length of the starting characters to store in the database.
    This includes the prefix length.
    Default is `6`.

  </Accordion>
</Accordions>

`defaultKeyLength` <span className="opacity-70">`number`</span>

The length of the API key. Longer is better. Default is 64. (Doesn't include the prefix length)

`defaultPrefix` <span className="opacity-70">`string`</span>

The prefix of the API key.

Note: We recommend you append an underscore to the prefix to make the prefix more identifiable. (eg `hello_`)

`maximumPrefixLength` <span className="opacity-70">`number`</span>

The maximum length of the prefix.

`minimumPrefixLength` <span className="opacity-70">`number`</span>

The minimum length of the prefix.

`requireName` <span className="opacity-70">`boolean`</span>

Whether to require a name for the API key. Default is `false`.

`maximumNameLength` <span className="opacity-70">`number`</span>

The maximum length of the name.

`minimumNameLength` <span className="opacity-70">`number`</span>

The minimum length of the name.

`enableMetadata` <span className="opacity-70">`boolean`</span>

Whether to enable metadata for an API key.

`keyExpiration` <span className="opacity-70">`{ defaultExpiresIn?: number | null; disableCustomExpiresTime?: boolean; minExpiresIn?: number; maxExpiresIn?: number; }`</span>

Customize the key expiration.

<Accordions>
  <Accordion title="keyExpiration options">
    `defaultExpiresIn` <span className="opacity-70">`number | null`</span>

    The default expires time in milliseconds.
    If `null`, then there will be no expiration time.
    Default is `null`.

    `disableCustomExpiresTime` <span className="opacity-70">`boolean`</span>

    Whether to disable the expires time passed from the client.
    If `true`, the expires time will be based on the default values.
    Default is `false`.

    `minExpiresIn` <span className="opacity-70">`number`</span>

    The minimum expiresIn value allowed to be set from the client. in days.
    Default is `1`.

    `maxExpiresIn` <span className="opacity-70">`number`</span>

    The maximum expiresIn value allowed to be set from the client. in days.
    Default is `365`.

  </Accordion>
</Accordions>

`rateLimit` <span className="opacity-70">`{ enabled?: boolean; timeWindow?: number; maxRequests?: number; }`</span>

Customize the rate-limiting.

<Accordions>
  <Accordion title="rateLimit options">
    `enabled` <span className="opacity-70">`boolean`</span>

    Whether to enable rate limiting. (Default true)

    `timeWindow` <span className="opacity-70">`number`</span>

    The duration in milliseconds where each request is counted.
    Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset.

    `maxRequests` <span className="opacity-70">`number`</span>

    Maximum amount of requests allowed within a window.
    Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset.

  </Accordion>
</Accordions>

`schema` <span className="opacity-70">`InferOptionSchema<ReturnType<typeof apiKeySchema>>`</span>

Custom schema for the API key plugin.

`enableSessionForAPIKeys` <span className="opacity-70">`boolean`</span>

An API Key can represent a valid session, so we can mock a session for the user if we find a valid API key in the request headers. Default is `false`.

`storage` <span className="opacity-70">`"database" | "secondary-storage"`</span>

Storage backend for API keys. Default is `"database"`.

- `"database"`: Store API keys in the database adapter (default)
- `"secondary-storage"`: Store API keys in the configured secondary storage (e.g., Redis)

`fallbackToDatabase` <span className="opacity-70">`boolean`</span>

When `storage` is `"secondary-storage"`, enable fallback to database if key is not found in secondary storage.
Default is `false`.

<Callout>
  When `storage` is set to `"secondary-storage"`, you must configure `secondaryStorage` in your Better Auth options. API keys will be stored using key-value patterns:
  - `api-key:${hashedKey}` - Primary lookup by hashed key
  - `api-key:by-id:${id}` - Lookup by ID
  - `api-key:by-user:${userId}` - User's API key list
  
  If an API key has an expiration date (`expiresAt`), a TTL will be automatically set in secondary storage to ensure automatic cleanup.
</Callout>

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  secondaryStorage: {
    get: async (key) => {
      return await redis.get(key);
    },
    set: async (key, value, ttl) => {
      if (ttl) await redis.set(key, value, { EX: ttl });
      else await redis.set(key, value);
    },
    delete: async (key) => {
      await redis.del(key);
    },
  },
  plugins: [
    apiKey({
      storage: "secondary-storage",
    }),
  ],
});
```

`customStorage` <span className="opacity-70">`{ get: (key: string) => Promise<unknown> | unknown; set: (key: string, value: string, ttl?: number) => Promise<void | null | unknown> | void; delete: (key: string) => Promise<void | null | string> | void; }`</span>

Custom storage methods for API keys. If provided, these methods will be used instead of `ctx.context.secondaryStorage`. Custom methods take precedence over global secondary storage.

Useful when you want to use a different storage backend specifically for API keys, or when you need custom logic for storage operations.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      storage: "secondary-storage",
      customStorage: {
        get: async (key) => await customStorage.get(key),
        set: async (key, value, ttl) => await customStorage.set(key, value, ttl),
        delete: async (key) => await customStorage.delete(key), 
      },
    }),
  ],
});
```

`deferUpdates` <span className="opacity-70">`boolean`</span>

Defer non-critical updates (rate limiting counters, timestamps, remaining count) to run after the response is sent using the global `backgroundTasks` handler. This can significantly improve response times on serverless platforms. Default is `false`.

Requires `backgroundTasks.handler` to be configured in the main auth options.

<Callout type="warn">
  Enabling this introduces eventual consistency where the response returns optimistic data before the database is updated. Only enable if your application can tolerate this trade-off for improved latency.
</Callout>

<Tabs items={["Vercel", "Cloudflare Workers"]}>
  <Tab value="Vercel">
    ```ts
    import { waitUntil } from "@vercel/functions";

    export const auth = betterAuth({
      advanced: { 
          backgroundTasks: {
             handler: waitUntil,
          },
      }
      plugins: [
        apiKey({
          deferUpdates: true,
        }),
      ],
    });
    ```
  </Tab>
  <Tab value="Cloudflare Workers">
    ```ts
    import { AsyncLocalStorage } from "node:async_hooks";

    const execCtxStorage = new AsyncLocalStorage<ExecutionContext>();

    export const auth = betterAuth({
      advanced: { 
          backgroundTasks: {
             handler: waitUntil,
          },
      }
      plugins: [
        apiKey({
          deferUpdates: true,
        }),
      ],
    });

    // In your request handler, wrap with execCtxStorage.run(ctx, ...)
    ```
  </Tab>
</Tabs>

`permissions` <span className="opacity-70">`{ defaultPermissions?: Statements | ((userId: string, ctx: GenericEndpointContext) => Statements | Promise<Statements>) }`</span>

Permissions for the API key.

Read more about permissions [here](/docs/plugins/api-key#permissions).

<Accordions>
  <Accordion title="permissions Options">
    `defaultPermissions` <span className="opacity-70">`Statements | ((userId: string, ctx: GenericEndpointContext) => Statements | Promise<Statements>)`</span>

    The default permissions for the API key.

  </Accordion>
</Accordions>

`disableKeyHashing` <span className="opacity-70">`boolean`</span>

Disable hashing of the API key.

<Callout type="warn">
Security Warning: It's strongly recommended to not disable hashing.
Storing API keys in plaintext makes them vulnerable to database breaches, potentially exposing all your users' API keys.
</Callout>

---

## Permissions

API keys can have permissions associated with them, allowing you to control access at a granular level. Permissions are structured as a record of resource types to arrays of allowed actions.

### Setting Default Permissions

You can configure default permissions that will be applied to all newly created API keys:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      permissions: {
        defaultPermissions: {
          files: ["read"],
          users: ["read"],
        },
      },
    }),
  ],
});
```

You can also provide a function that returns permissions dynamically:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { apiKey } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    apiKey({
      permissions: {
        defaultPermissions: async (userId, ctx) => {
          // Fetch user role or other data to determine permissions
          return {
            files: ["read"],
            users: ["read"],
          };
        },
      },
    }),
  ],
});
```

### Creating API Keys with Permissions

When creating an API key, you can specify custom permissions:

```ts title="create-api-key.ts"
import { auth } from "@/lib/auth"

const apiKey = await auth.api.createApiKey({
  body: {
    name: "My API Key",
    permissions: {
      files: ["read", "write"],
      users: ["read"],
    },
    userId: "userId",
  },
});
```

### Verifying API Keys with Required Permissions

When verifying an API key, you can check if it has the required permissions:

```ts title="verify-api-key.ts"
import { auth } from "@/lib/auth"

const result = await auth.api.verifyApiKey({
  body: {
    key: "your_api_key_here",
    permissions: {
      files: ["read"],
    },
  },
});

if (result.valid) {
  // API key is valid and has the required permissions
} else {
  // API key is invalid or doesn't have the required permissions
}
```

### Updating API Key Permissions

You can update the permissions of an existing API key:

```ts title="update-api-key.ts"
import { auth } from "@/lib/auth"

const apiKey = await auth.api.updateApiKey({
  body: {
    keyId: existingApiKeyId,
    permissions: {
      files: ["read", "write", "delete"],
      users: ["read", "write"],
    },
  },
  headers: user_headers,
});
```

### Permissions Structure

Permissions follow a resource-based structure:

```ts
type Permissions = {
  [resourceType: string]: string[];
};

// Example:
const permissions = {
  files: ["read", "write", "delete"],
  users: ["read"],
  projects: ["read", "write"],
};
```

When verifying an API key, all required permissions must be present in the API key's permissions for validation to succeed.

## Schema

Table: `apikey`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "The ID of the API key.",
      isUnique: true,
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "The name of the API key.",
      isOptional: true,
    },
    {
      name: "start",
      type: "string",
      description:
        "The starting characters of the API key. Useful for showing the first few characters of the API key in the UI for the users to easily identify.",
      isOptional: true,
    },
    {
      name: "prefix",
      type: "string",
      description: "The API Key prefix. Stored as plain text.",
      isOptional: true,
    },
    {
      name: "key",
      type: "string",
      description: "The hashed API key itself.",
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user associated with the API key.",
      isForeignKey: true,
    },
    {
      name: "refillInterval",
      type: "number",
      description: "The interval to refill the key in milliseconds.",
      isOptional: true,
    },
    {
      name: "refillAmount",
      type: "number",
      description: "The amount to refill the remaining count of the key.",
      isOptional: true,
    },
    {
      name: "lastRefillAt",
      type: "Date",
      description: "The date and time when the key was last refilled.",
      isOptional: true,
    },
    {
      name: "enabled",
      type: "boolean",
      description: "Whether the API key is enabled.",
    },
    {
      name: "rateLimitEnabled",
      type: "boolean",
      description: "Whether the API key has rate limiting enabled.",
    },
    {
      name: "rateLimitTimeWindow",
      type: "number",
      description: "The time window in milliseconds for the rate limit.",
      isOptional: true,
    },
    {
      name: "rateLimitMax",
      type: "number",
      description:
        "The maximum number of requests allowed within the `rateLimitTimeWindow`.",
      isOptional: true,
    },
    {
      name: "requestCount",
      type: "number",
      description:
        "The number of requests made within the rate limit time window.",
    },
    {
      name: "remaining",
      type: "number",
      description: "The number of requests remaining.",
      isOptional: true,
    },
    {
      name: "lastRequest",
      type: "Date",
      description: "The date and time of the last request made to the key.",
      isOptional: true,
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "The date and time when the key will expire.",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "The date and time the API key was created.",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "The date and time the API key was updated.",
    },
    {
      name: "permissions",
      type: "string",
      description: "The permissions of the key.",
      isOptional: true,
    },
    {
      name: "metadata",
      type: "Object",
      isOptional: true,
      description: "Any additional metadata you want to store with the key.",
    },
  ]}
/>
---
title: JWT
description: Authenticate users with JWT tokens in services that can't use the session
---

The JWT plugin provides endpoints to retrieve a JWT token and a JWKS endpoint to verify the token.

<Callout type="info">
  This plugin is not meant as a replacement for the session. It's meant to be used for services that require JWT tokens. If you're looking to use JWT tokens for authentication, check out the [Bearer Plugin](/docs/plugins/bearer).
</Callout>

## Installation

<Steps>
<Step>
### Add the plugin to your **auth** config
```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { jwt } from "better-auth/plugins" // [!code highlight]

export const auth = betterAuth({
    plugins: [
        jwt(), // [!code highlight]
    ]
})
```
</Step>

<Step>
    ### Migrate the database

    Run the migration or generate the schema to add the necessary fields and tables to the database.

    <Tabs items={["migrate", "generate"]}>
        <Tab value="migrate">
        ```package-install
        npx auth migrate
        ```
        </Tab>
        <Tab value="generate">
        ```package-install
        npx auth generate
        ```
        </Tab>
    </Tabs>
    See the [Schema](#schema) section to add the fields manually.
</Step>
<Step>
### Add the client plugin to your auth client

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { jwtClient } from "better-auth/client/plugins" // [!code highlight]

export const authClient = createAuthClient({
  plugins: [
    jwtClient() // [!code highlight]
  ]
})
```
</Step>
</Steps>    


## Usage

Once you've installed the plugin, you can start using the JWT & JWKS plugin to get the token and the JWKS through their respective endpoints.

## JWT

### Retrieve the token

There are multiple ways to retrieve JWT tokens:

1. **Using the client plugin (recommended)**

```ts
import { authClient } from "@/lib/auth-client"

const { data, error } = await authClient.token()
if (error) {
  // handle error
}
if (data) {
  const jwtToken = data.token
  // Use this token for authenticated requests to external services
}
```

This is the recommended approach for client applications that need JWT tokens for external API authentication.

2. **Using your session token**

To get the token, call the `/token` endpoint. This will return the following:
  
```json
  { 
    "token": "ey..."
  }
```

Make sure to include the token in the `Authorization` header of your requests if the `bearer` plugin is added in your auth configuration.

```ts
await fetch("/api/auth/token", {
  headers: {
    "Authorization": `Bearer ${token}`
  },
})
```

3. **From `set-auth-jwt` header**

When you call `getSession` method, a JWT is returned in the `set-auth-jwt` header, which you can use to send to your services directly.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.getSession({
  fetchOptions: {
    onSuccess: (ctx)=>{
      const jwt = ctx.response.headers.get("set-auth-jwt")
    }
  }
})
```

### Verifying the token
The token can be verified in your own service, without the need for an additional verify call or database check.
For this JWKS is used. The public key can be fetched from the `/api/auth/jwks` endpoint.

Since this key is not subject to frequent changes, it can be cached indefinitely.
The key ID (`kid`) that was used to sign a JWT is included in the header of the token.
In case a JWT with a different `kid` is received, it is recommended to fetch the JWKS again.

```json
  {
    "keys": [
        {
            "crv": "Ed25519",
            "x": "bDHiLTt7u-VIU7rfmcltcFhaHKLVvWFy-_csKZARUEU",
            "kty": "OKP",
            "kid": "c5c7995d-0037-4553-8aee-b5b620b89b23"
        }
    ]
  }
```

#### Example using jose with remote JWKS

```ts
import { jwtVerify, createRemoteJWKSet } from 'jose'

async function validateToken(token: string) {
  try {
    const JWKS = createRemoteJWKSet(
      new URL('http://localhost:3000/api/auth/jwks')
    )
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: 'http://localhost:3000', // Should match your JWT issuer, which is the BASE_URL
      audience: 'http://localhost:3000', // Should match your JWT audience, which is the BASE_URL by default
    })
    return payload
  } catch (error) {
    console.error('Token validation failed:', error)
    throw error
  }
}

// Usage example
const token = 'your.jwt.token' // this is the token you get from the /api/auth/token endpoint
const payload = await validateToken(token)
```

#### Example with local JWKS

```ts
import { jwtVerify, createLocalJWKSet } from 'jose'


async function validateToken(token: string) {
  try {
    /**
     * This is the JWKS that you get from the /api/auth/
     * jwks endpoint
     */
    const storedJWKS = {
      keys: [{
        //...
      }]
    };
    const JWKS = createLocalJWKSet({
      keys: storedJWKS.data?.keys!,
    })
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: 'http://localhost:3000', // Should match your JWT issuer, which is the BASE_URL
      audience: 'http://localhost:3000', // Should match your JWT audience, which is the BASE_URL by default
    })
    return payload
  } catch (error) {
    console.error('Token validation failed:', error)
    throw error
  }
}

// Usage example
const token = 'your.jwt.token' // this is the token you get from the /api/auth/token endpoint
const payload = await validateToken(token)
```

### OAuth Provider Mode

If you are making your system oAuth compliant (such as when utilizing the OIDC or MCP plugins), you **MUST** disable the `/token` endpoint (oAuth equivalent `/oauth2/token`) and disable setting the jwt header (oAuth equivalent `/oauth2/userinfo`).

```ts title="auth.ts"
import { betterAuth } from "better-auth";

betterAuth({
  disabledPaths: [
    "/token",
  ],
  plugins: [jwt({
    disableSettingJwtHeader: true,
  })]
})
```

### Remote JWKS Url

Disables the `/jwks` endpoint and uses this endpoint in any discovery such as OIDC.

Useful if your JWKS are not managed at `/jwks` or if your jwks are signed with a certificate and placed on your CDN.

NOTE: you **MUST** specify which asymmetric algorithm is used for signing.

```ts title="auth.ts"
jwt({
  jwks: {
    remoteUrl: "https://example.com/.well-known/jwks.json",
    keyPairConfig: {
      alg: 'ES256',
    },
  }
})
```

### Custom JWKS Path

By default, the JWKS endpoint is available at `/jwks`. You can customize this path using the `jwksPath` option.

This is useful when you need to:
- Follow OAuth 2.0/OIDC conventions (e.g., `/.well-known/jwks.json`)
- Match existing API conventions in your application
- Avoid path conflicts with other endpoints

**Server Configuration:**

```ts title="auth.ts"
jwt({
  jwks: {
    jwksPath: "/.well-known/jwks.json"
  }
})
```

**Client Configuration:**

When using a custom `jwksPath` on the server, you **MUST** configure the client with the same path:

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { jwtClient } from "better-auth/client/plugins"

export const authClient = createAuthClient({
  plugins: [
    jwtClient({
      jwks: {
        jwksPath: "/.well-known/jwks.json" // Must match server configuration
      }
    })
  ]
})
```

Then you can use the `jwks()` method as usual:

```ts
const { data, error } = await authClient.jwks()
if (data) {
  // Use data.keys to verify JWT tokens
}
```

<Callout type="warning">
  The `jwksPath` configured on the client **MUST** match the server configuration. If they don't match, the client will not be able to fetch the JWKS.
</Callout>

### Custom Signing

This is an advanced feature. Configuration outside of this plugin **MUST** be provided.

Implementers:
- `remoteUrl` must be defined if using the `sign` function. This shall store all active keys, not just the current one.
- If using localized approach, ensure server uses the latest private key when rotated. Depending on deployment, the server may need to be restarted.
- When using remote approach, verify the payload is unchanged after transit. Use integrity validation like CRC32 or SHA256 checks if available.

#### Localized Signing

```ts title="auth.ts"
jwt({
  jwks: {
    remoteUrl: "https://example.com/.well-known/jwks.json",
    keyPairConfig: {
      alg: 'EdDSA',
    },
  },
  jwt: {
    sign: async (jwtPayload: JWTPayload) => {
      // this is pseudocode
      return await new SignJWT(jwtPayload)
        .setProtectedHeader({
          alg: "EdDSA",
          kid: process.env.currentKid,
          typ: "JWT",
        })
        .sign(process.env.clientPrivateKey);
    },
  },
})
```

#### Remote Signing

Useful if you are using a remote Key Management Service such as [Google KMS](https://cloud.google.com/kms/docs/encrypt-decrypt-rsa#kms-encrypt-asymmetric-nodejs), [Amazon KMS](https://docs.aws.amazon.com/kms/latest/APIReference/API_Sign.html), or [Azure Key Vault](https://learn.microsoft.com/en-us/rest/api/keyvault/keys/sign/sign?view=rest-keyvault-keys-7.4&tabs=HTTP).

```ts title="auth.ts"
jwt({
  jwks: {
    remoteUrl: "https://example.com/.well-known/jwks.json",
    keyPairConfig: {
      alg: 'ES256',
    },
  },
  jwt: {
    sign: async (jwtPayload: JWTPayload) => {
      // this is pseudocode
      const headers = JSON.stringify({ kid: '123', alg: 'ES256', typ: 'JWT' })
      const payload = JSON.stringify(jwtPayload)
      const encodedHeaders = Buffer.from(headers).toString('base64url')
      const encodedPayload = Buffer.from(payload).toString('base64url')
      const hash = createHash('sha256')
      const data = `${encodedHeaders}.${encodedPayload}`
      hash.update(Buffer.from(data))
      const digest = hash.digest()
      const sig = await remoteSign(digest)
      // integrityCheck(sig)
      const jwt = `${data}.${sig}`
      // verifyJwt(jwt)
      return jwt
    },
  },
})
```


## Schema

The JWT plugin adds the following tables to the database:

### JWKS

Table Name: `jwks`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each web key",
      isPrimaryKey: true
    },
    { 
      name: "publicKey", 
      type: "string", 
      description: "The public part of the web key" 
    },
    { 
      name: "privateKey", 
      type: "string", 
      description: "The private part of the web key" 
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the web key was created" 
    },
    { 
      name: "expiresAt", 
      type: "Date", 
      description: "Timestamp of when the web key expires",
      isOptional: true
    },
  ]}
  />

<Callout>
  You can customize the table name and fields for the `jwks` table. See the [Database concept documentation](/docs/concepts/database#custom-table-names) for more information on how to customize plugin schema.
</Callout>

## Options

### Algorithm of the Key Pair

The algorithm used for the generation of the key pair. The default is **EdDSA** with the **Ed25519** curve. Below are the available options:

```ts title="auth.ts"
jwt({
  jwks: {
    keyPairConfig: {
      alg: "EdDSA",
      crv: "Ed25519"
    }
  }
})
```

#### EdDSA
- **Default Curve**: `Ed25519`
- **Optional Property**: `crv`
  - Available options: `Ed25519`, `Ed448`
  - Default: `Ed25519`

#### ES256
- No additional properties

#### RSA256
- **Optional Property**: `modulusLength`
  - Expects a number
  - Default: `2048`

#### PS256
- **Optional Property**: `modulusLength`
  - Expects a number
  - Default: `2048`

#### ECDH-ES
- **Optional Property**: `crv`
  - Available options: `P-256`, `P-384`, `P-521`
  - Default: `P-256`

#### ES512
- No additional properties


### Disable private key encryption

By default, the private key is encrypted using AES256 GCM. You can disable this by setting the `disablePrivateKeyEncryption` option to `true`.

For security reasons, it's recommended to keep the private key encrypted.

```ts title="auth.ts"
jwt({
  jwks: {
    disablePrivateKeyEncryption: true
  }
})
```

### Key Rotation

You can enable key rotation by setting the `rotationInterval` option. This will automatically rotate the key pair at the specified interval.

The default value is `undefined` (disabled).

```ts title="auth.ts"
jwt({
  jwks: {
    rotationInterval: 60 * 60 * 24 * 30, // 30 days
    gracePeriod: 60 * 60 * 24 * 30 // 30 days
  }
})
```

- `rotationInterval`: The interval in seconds to rotate the key pair.
- `gracePeriod`: The period in seconds to keep the old key pair valid after rotation. This is useful to allow clients to verify tokens signed by the old key pair. The default value is 30 days.

### Modify JWT payload

By default the entire user object is added to the JWT payload. You can modify the payload by providing a function to the `definePayload` option.

```ts title="auth.ts"
jwt({
  jwt: {
    definePayload: ({user}) => {
      return {
        id: user.id,
        email: user.email,
        role: user.role
      }
    }
  }
})
```

### Modify Issuer, Audience, Subject or Expiration time
If none is given, the `BASE_URL` is used as the issuer and the audience is set to the `BASE_URL`. The expiration time is set to 15 minutes.

```ts title="auth.ts"
jwt({
  jwt: {
    issuer: "https://example.com",
    audience: "https://example.com",
    expirationTime: "1h",
    getSubject: (session) => {
      // by default the subject is the user id
      return session.user.email
    }
  }
})
```

### Custom Adapter

By default, the JWT plugin stores and retrieves JWKS from your database. You can provide a custom adapter to override this behavior, allowing you to store JWKS in alternative locations such as Redis, external services, or in-memory storage.

```ts title="auth.ts"
jwt({
  adapter: {
    getJwks: async (ctx) => {
      // Custom implementation to get all JWKS
      // This overrides the default database query
      return await yourCustomStorage.getAllKeys()
    },
    createJwk: async (ctx, webKey) => {
      // Custom implementation to create a new key
      // This overrides the default database insert
      return await yourCustomStorage.createKey(webKey)
    }
  }
})
```
---
title: Organization
description: The organization plugin allows you to manage your organization's members and teams.
---

Organizations simplifies user access and permissions management. Assign roles and permissions to streamline project management, team coordination, and partnerships.

## Installation

<Steps>
<Step>
### Add the plugin to your **auth** config
```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { organization } from "better-auth/plugins" // [!code highlight]

export const auth = betterAuth({
    plugins: [
        organization() // [!code highlight]
    ]
})
```
</Step>

<Step>
    ### Migrate the database

    Run the migration or generate the schema to add the necessary fields and tables to the database.

    <Tabs items={["migrate", "generate"]}>
        <Tab value="migrate">
        ```package-install
        npx auth migrate
        ```
        </Tab>
        <Tab value="generate">
        ```package-install
        npx auth generate
        ```
        </Tab>
    </Tabs>
    See the [Schema](#schema) section to add the fields manually.

</Step>

<Step>
    ### Add the client plugin

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { organizationClient } from "better-auth/client/plugins" // [!code highlight]

    export const authClient = createAuthClient({
        plugins: [
            organizationClient() // [!code highlight]
        ]
    })
    ```

</Step>
</Steps>

## Usage

Once you've installed the plugin, you can start using the organization plugin to manage your organization's members and teams. The client plugin will provide you with methods under the `organization` namespace, and the server `api` will provide you with the necessary endpoints to manage your organization and give you an easier way to call the functions on your own backend.

## Organization

### Create an organization

<APIMethod path="/organization/create" method="POST" requireSession>

```ts
const metadata = { someKey: "someValue" };

type createOrganization = {
  /**
  * The organization name.
  */
  name: string = "My Organization"
  /**
  * The organization slug.
  */
  slug: string = "my-org"
  /**
  * The organization logo.
  */
  logo?: string = "https://example.com/logo.png"
  /**
  * The metadata of the organization.
  */
  metadata?: Record<string, any>
  /**
  * The user ID of the organization creator.
  * @serverOnly - This is ignored if session headers are provided.
  */
  userId?: string = "some_user_id"
  /**
  * Whether to keep the current active organization active after creating a new one.
  */
  keepCurrentActiveOrganization?: boolean = false
}
```

</APIMethod>

<Callout type="warn">
**Mutually Exclusive Parameters**

The `userId` and session headers cannot be used together:
- **With session headers:** The organization is created for the authenticated session user. The `userId` field is **silently ignored**.
- **Without session headers (Server-side only):** The organization is created for the user specified by `userId`.

**For Admins:** To create an organization on behalf of another user, you must make the API call server-side **without** passing session headers.
</Callout>

#### Restrict who can create an organization

By default, any user can create an organization. To restrict this, set the `allowUserToCreateOrganization` option to a function that returns a boolean, or directly to `true` or `false`.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

const auth = betterAuth({
  //...
  plugins: [
    organization({
      allowUserToCreateOrganization: async (user) => { // [!code highlight]
        const subscription = await getSubscription(user.id); // [!code highlight]
        return subscription.plan === "pro"; // [!code highlight]
      }, // [!code highlight]
    }),
  ],
});
```

#### Check if organization slug is taken

To check if an organization slug is taken or not you can use the `checkSlug` function provided by the client. The function takes an object with the following properties:

<APIMethod path="/organization/check-slug" method="POST">
```ts
type checkOrganizationSlug = {
    /**
     * The organization slug to check.  
     */
    slug: string = "my-org"
}
```
</APIMethod>

### Organization Hooks

You can customize organization operations using hooks that run before and after various organization-related activities. Better Auth provides two ways to configure hooks:

1. **Legacy organizationCreation hooks** (deprecated, use `organizationHooks` instead)
2. **Modern organizationHooks** (recommended) - provides comprehensive control over all organization-related activities

#### Organization Creation and Management Hooks

Control organization lifecycle operations:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    organization({
      organizationHooks: {
        // Organization creation hooks
        beforeCreateOrganization: async ({ organization, user }) => {
          // Run custom logic before organization is created
          // Optionally modify the organization data
          return {
            data: {
              ...organization,
              metadata: {
                customField: "value",
              },
            },
          };
        },

        afterCreateOrganization: async ({ organization, member, user }) => {
          // Run custom logic after organization is created
          // e.g., create default resources, send notifications
          await setupDefaultResources(organization.id);
        },

        // Organization update hooks
        beforeUpdateOrganization: async ({ organization, user, member }) => {
          // Validate updates, apply business rules
          return {
            data: {
              ...organization,
              name: organization.name?.toLowerCase(),
            },
          };
        },

        afterUpdateOrganization: async ({ organization, user, member }) => {
          // Sync changes to external systems
          await syncOrganizationToExternalSystems(organization);
        },
      },
    }),
  ],
});
```

<Callout type="info">
  The legacy `organizationCreation` hooks are still supported but deprecated.
  Use `organizationHooks.beforeCreateOrganization` and
  `organizationHooks.afterCreateOrganization` instead for new projects.
</Callout>

#### Member Hooks

Control member operations within organizations:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    organization({
      organizationHooks: {
        // Before a member is added to an organization
        beforeAddMember: async ({ member, user, organization }) => {
          // Custom validation or modification
          console.log(`Adding ${user.email} to ${organization.name}`);

          // Optionally modify member data
          return {
            data: {
              ...member,
              role: "custom-role", // Override the role
            },
          };
        },

        // After a member is added
        afterAddMember: async ({ member, user, organization }) => {
          // Send welcome email, create default resources, etc.
          await sendWelcomeEmail(user.email, organization.name);
        },

        // Before a member is removed
        beforeRemoveMember: async ({ member, user, organization }) => {
          // Cleanup user's resources, send notification, etc.
          await cleanupUserResources(user.id, organization.id);
        },

        // After a member is removed
        afterRemoveMember: async ({ member, user, organization }) => {
          await logMemberRemoval(user.id, organization.id);
        },

        // Before updating a member's role
        beforeUpdateMemberRole: async ({
          member,
          newRole,
          user,
          organization,
        }) => {
          // Validate role change permissions
          if (newRole === "owner" && !hasOwnerUpgradePermission(user)) {
            throw new Error("Cannot upgrade to owner role");
          }

          // Optionally modify the role
          return {
            data: {
              role: newRole,
            },
          };
        },

        // After updating a member's role
        afterUpdateMemberRole: async ({
          member,
          previousRole,
          user,
          organization,
        }) => {
          await logRoleChange(user.id, previousRole, member.role);
        },
      },
    }),
  ],
});
```

#### Invitation Hooks

Control invitation lifecycle:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    organization({
      organizationHooks: {
        // Before creating an invitation
        beforeCreateInvitation: async ({
          invitation,
          inviter,
          organization,
        }) => {
          // Custom validation or expiration logic
          const customExpiration = new Date(
            Date.now() + 1000 * 60 * 60 * 24 * 7
          ); // 7 days

          return {
            data: {
              ...invitation,
              expiresAt: customExpiration,
            },
          };
        },

        // After creating an invitation
        afterCreateInvitation: async ({
          invitation,
          inviter,
          organization,
        }) => {
          // Send custom invitation email, track metrics, etc.
          await sendCustomInvitationEmail(invitation, organization);
        },

        // Before accepting an invitation
        beforeAcceptInvitation: async ({ invitation, user, organization }) => {
          // Additional validation before acceptance
          await validateUserEligibility(user, organization);
        },

        // After accepting an invitation
        afterAcceptInvitation: async ({
          invitation,
          member,
          user,
          organization,
        }) => {
          // Setup user account, assign default resources
          await setupNewMemberResources(user, organization);
        },

        // Before/after rejecting invitations
        beforeRejectInvitation: async ({ invitation, user, organization }) => {
          // Log rejection reason, send notification to inviter
        },

        afterRejectInvitation: async ({ invitation, user, organization }) => {
          await notifyInviterOfRejection(invitation.inviterId, user.email);
        },

        // Before/after cancelling invitations
        beforeCancelInvitation: async ({
          invitation,
          cancelledBy,
          organization,
        }) => {
          // Verify cancellation permissions
        },

        afterCancelInvitation: async ({
          invitation,
          cancelledBy,
          organization,
        }) => {
          await logInvitationCancellation(invitation.id, cancelledBy.id);
        },
      },
    }),
  ],
});
```

#### Team Hooks

Control team operations (when teams are enabled):

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    organization({
      teams: { enabled: true },
      organizationHooks: {
        // Before creating a team
        beforeCreateTeam: async ({ team, user, organization }) => {
          // Validate team name, apply naming conventions
          return {
            data: {
              ...team,
              name: team.name.toLowerCase().replace(/\s+/g, "-"),
            },
          };
        },

        // After creating a team
        afterCreateTeam: async ({ team, user, organization }) => {
          // Create default team resources, channels, etc.
          await createDefaultTeamResources(team.id);
        },

        // Before updating a team
        beforeUpdateTeam: async ({ team, updates, user, organization }) => {
          // Validate updates, apply business rules
          return {
            data: {
              ...updates,
              name: updates.name?.toLowerCase(),
            },
          };
        },

        // After updating a team
        afterUpdateTeam: async ({ team, user, organization }) => {
          await syncTeamChangesToExternalSystems(team);
        },

        // Before deleting a team
        beforeDeleteTeam: async ({ team, user, organization }) => {
          // Backup team data, notify members
          await backupTeamData(team.id);
        },

        // After deleting a team
        afterDeleteTeam: async ({ team, user, organization }) => {
          await cleanupTeamResources(team.id);
        },

        // Team member operations
        beforeAddTeamMember: async ({
          teamMember,
          team,
          user,
          organization,
        }) => {
          // Validate team membership limits, permissions
          const memberCount = await getTeamMemberCount(team.id);
          if (memberCount >= 10) {
            throw new Error("Team is full");
          }
        },

        afterAddTeamMember: async ({
          teamMember,
          team,
          user,
          organization,
        }) => {
          await grantTeamAccess(user.id, team.id);
        },

        beforeRemoveTeamMember: async ({
          teamMember,
          team,
          user,
          organization,
        }) => {
          // Backup user's team-specific data
          await backupTeamMemberData(user.id, team.id);
        },

        afterRemoveTeamMember: async ({
          teamMember,
          team,
          user,
          organization,
        }) => {
          await revokeTeamAccess(user.id, team.id);
        },
      },
    }),
  ],
});
```

#### Hook Error Handling

All hooks support error handling. Throwing an error in a `before` hook will prevent the operation from proceeding:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";
import { APIError } from "better-auth/api";

export const auth = betterAuth({
  plugins: [
    organization({
      organizationHooks: {
        beforeAddMember: async ({ member, user, organization }) => {
          // Check if user has pending violations
          const violations = await checkUserViolations(user.id);
          if (violations.length > 0) {
            throw new APIError("BAD_REQUEST", {
              message:
                "User has pending violations and cannot join organizations",
            });
          }
        },

        beforeCreateTeam: async ({ team, user, organization }) => {
          // Validate team name uniqueness
          const existingTeam = await findTeamByName(team.name, organization.id);
          if (existingTeam) {
            throw new APIError("BAD_REQUEST", {
              message: "Team name already exists in this organization",
            });
          }
        },
      },
    }),
  ],
});
```

### List User's Organizations

To list the organizations that a user is a member of, you can use `useListOrganizations` hook. It implements a reactive way to get the organizations that the user is a member of.

<Tabs items={["React", "Vue", "Svelte"]} default="React">
<Tab value="React">
```tsx title="client.tsx"
import { authClient } from "@/lib/auth-client"

function App(){
const { data: organizations } = authClient.useListOrganizations()
return (
  <div>
    {organizations.map((org) => (
      <p>{org.name}</p>
    ))}
  </div>)
}
```
</Tab>

<Tab value="Svelte">
```svelte title="page.svelte"
<script lang="ts">
  import { authClient } from "$lib/auth-client";
  const organizations = authClient.useListOrganizations();
</script>

<h1>Organizations</h1>

{#if $organizations.isPending}

  <p>Loading...</p>
{:else if !$organizations.data?.length}
  <p>No organizations found.</p>
{:else}
  <ul>
    {#each $organizations.data as organization}
      <li>{organization.name}</li>
    {/each}
  </ul>
{/if}
```

</Tab>

<Tab value="Vue">
```vue title="organization.vue"
<script lang="ts">;
export default {
    setup() {
        const organizations = authClient.useListOrganizations()
        return { organizations };
    }
};
</script>

<template>
    <div>
        <h1>Organizations</h1>
        <div v-if="organizations.isPending">Loading...</div>
        <div v-else-if="organizations.data === null">No organizations found.</div>
        <ul v-else>
            <li v-for="organization in organizations.data" :key="organization.id">
                {{ organization.name }}
            </li>
        </ul>
    </div>
</template>
```
</Tab>
</Tabs>

Or alternatively, you can call `organization.list` if you don't want to use a hook.

<APIMethod path="/organization/list" method="GET" requireSession>
  ```ts
  type listOrganizations = {
  }
  ```
</APIMethod>


### Active Organization

Active organization is the workspace the user is currently working on. By default when the user is signed in the active organization is set to `null`. You can set the active organization to the user session.

<Callout type="info">
  It's not always you want to persist the active organization in the session.
  You can manage the active organization in the client side only. For example,
  multiple tabs can have different active organizations.
</Callout>

#### Set Active Organization

You can set the active organization by calling the `organization.setActive` function. It'll set the active organization for the user session.

<Callout>
  In some applications, you may want the ability to unset an active
  organization. In this case, you can call this endpoint with `organizationId`
  set to `null`.
</Callout>

<APIMethod path="/organization/set-active" method="POST" requireSession>
```ts
type setActiveOrganization = {
    /**
     * The organization ID to set as active. It can be null to unset the active organization.  
     */
    organizationId?: string | null = "org-id"
    /**
     * The organization slug to set as active. It can be null to unset the active organization if organizationId is not provided.  
     */
    organizationSlug?: string = "org-slug"
}
```
</APIMethod>

To automatically set an active organization when a session is created, you can use [database hooks](/docs/concepts/database#database-hooks). You'll need to implement logic to determine which organization to set as the initial active organization.

```ts title="auth.ts"
export const auth = betterAuth({
  import { betterAuth } from "better-auth";

  databaseHooks: {
    session: {
      create: {
        before: async (session) => {
          // Implement your custom logic to set initial active organization
          const organization = await getInitialOrganization(session.userId);
          return {
            data: {
              ...session,
              activeOrganizationId: organization?.id,
            },
          };
        },
      },
    },
  },
});
```

#### Use Active Organization

To retrieve the active organization for the user, you can call the `useActiveOrganization` hook. It returns the active organization for the user. Whenever the active organization changes, the hook will re-evaluate and return the new active organization.

<Tabs items={['React', 'Vue', 'Svelte']}>
    <Tab value="React">
    ```tsx title="client.tsx"
    import { authClient } from "@/lib/auth-client"

    function App(){
        const { data: activeOrganization } = authClient.useActiveOrganization()
        return (
            <div>
                {activeOrganization ? <p>{activeOrganization.name}</p> : null}
            </div>
        )
    }
    ```
    </Tab>
    <Tab value="Svelte">
    ```tsx title="client.tsx"
    <script lang="ts">
    import { authClient } from "$lib/auth-client";
    const activeOrganization = authClient.useActiveOrganization();
    </script>

    <h2>Active Organization</h2>

    {#if $activeOrganization.isPending}
    <p>Loading...</p>
    {:else if $activeOrganization.data === null}
    <p>No active organization found.</p>
    {:else}
    <p>{$activeOrganization.data.name}</p>
    {/if}
    ```
    </Tab>
    <Tab value="Vue">
    ```vue title="organization.vue"
    <script lang="ts">;
    export default {
        setup() {
            const activeOrganization = authClient.useActiveOrganization();
            return { activeOrganization };
        }
    };
    </script>

    <template>
        <div>
            <h2>Active organization</h2>
            <div v-if="activeOrganization.isPending">Loading...</div>
            <div v-else-if="activeOrganization.data === null">No active organization.</div>
            <div v-else>
                {{ activeOrganization.data.name }}
            </div>
        </div>
    </template>
    ```
    </Tab>

</Tabs>

### Get Full Organization

To get the full details of an organization, you can use the `getFullOrganization` function.
By default, if you don't pass any properties, it will use the active organization.

<APIMethod
  path="/organization/get-full-organization"
  method="GET"
  requireSession
>
```ts
type getFullOrganization = {
    /**
     * The organization ID to get. By default, it will use the active organization.  
     */
    organizationId?: string = "org-id"
    /**
     * The organization slug to get.  
     */
    organizationSlug?: string = "org-slug"
    /**
     * The limit of members to get. By default, it uses the membershipLimit option which defaults to 100.
     */
    membersLimit?: number = 100
}
```
</APIMethod>


### Update Organization

To update organization info, you can use `organization.update`

<APIMethod
  path="/organization/update"
  method="POST"
  requireSession
>
```ts
type updateOrganization = {
    /**
     * A partial list of data to update the organization. 
     */
    data: {
        /**
         * The name of the organization. 
         */
        name?: string = "updated-name"
        /**
         * The slug of the organization. 
         */
        slug?: string = "updated-slug"
        /**
         * The logo of the organization. 
         */
        logo?: string = "new-logo.url"
        /**
         * The metadata of the organization. 
         */
        metadata?: Record<string, any> | null = { customerId: "test" }
    }
    /**
     * The organization ID. to update.
     */
    organizationId?: string = "org-id"
}
```
</APIMethod>

### Delete Organization

To remove user owned organization, you can use `organization.delete`

<APIMethod
  path="/organization/delete"
  method="POST"
  requireSession
>
```ts
type deleteOrganization = {
    /*
    * The organization ID to delete.
    */
    organizationId: string = "org-id"
}
```
</APIMethod>

If the user has the necessary permissions (by default: role is owner) in the specified organization, all members, invitations and organization information will be removed.

You can configure how organization deletion is handled through `organizationDeletion` option:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

const auth = betterAuth({
  plugins: [
    organization({
      disableOrganizationDeletion: true, //to disable it altogether
      organizationHooks: {
        beforeDeleteOrganization: async (data, request) => {
          // a callback to run before deleting org
        },
        afterDeleteOrganization: async (data, request) => {
          // a callback to run after deleting org
        },
      },
    }),
  ],
});
```

## Invitations

To add a member to an organization, we first need to send an invitation to the user. The user will receive an email/sms with the invitation link. Once the user accepts the invitation, they will be added to the organization.

### Setup Invitation Email

For member invitation to work we first need to provide `sendInvitationEmail` to the `better-auth` instance. This function is responsible for sending the invitation email to the user.

You'll need to construct and send the invitation link to the user. The link should include the invitation ID, which will be used with the acceptInvitation function when the user clicks on it.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";
import { sendOrganizationInvitation } from "./email";

export const auth = betterAuth({
  plugins: [
    organization({
      async sendInvitationEmail(data) {
        const inviteLink = `https://example.com/accept-invitation/${data.id}`;
        sendOrganizationInvitation({
          email: data.email,
          invitedByUsername: data.inviter.user.name,
          invitedByEmail: data.inviter.user.email,
          teamName: data.organization.name,
          inviteLink,
        });
      },
    }),
  ],
});
```

### Send Invitation

To invite users to an organization, you can use the `invite` function provided by the client. The `invite` function takes an object with the following properties:

<APIMethod path="/organization/invite-member" method="POST" requireSession>
```ts
type createInvitation = {
    /**
     * The email address of the user to invite.  
     */
    email: string = "example@gmail.com"
    /**
     * The role(s) to assign to the user. It can be `admin`, `member`, `owner`
     */
    role: string | string[] = "member"
    /**
     * The organization ID to invite the user to. Defaults to the active organization.  
     */
    organizationId?: string = "org-id"
    /**
     * Resend the invitation email, if the user is already invited.  
     */
    resend?: boolean = true
    /**
     * The team ID to invite the user to.  
     */
    teamId?: string = "team-id"
}
```
</APIMethod>

<Callout>
  - If the user is already a member of the organization, the invitation will be
  canceled. - If the user is already invited to the organization, unless
  `resend` is set to `true`, the invitation will not be sent again. - If
  `cancelPendingInvitationsOnReInvite` is set to `true`, the invitation will be
  canceled if the user is already invited to the organization and a new
  invitation is sent.
</Callout>

### Accept Invitation

When a user receives an invitation email, they can click on the invitation link to accept the invitation. The invitation link should include the invitation ID, which will be used to accept the invitation.

Make sure to call the `acceptInvitation` function after the user is logged in.

<APIMethod path="/organization/accept-invitation" method="POST" requireSession>
```ts
type acceptInvitation = {
    /**
     * The ID of the invitation to accept.  
     */
    invitationId: string = "invitation-id"
}
```
</APIMethod>

#### Email Verification Requirement

If the `requireEmailVerificationOnInvitation` option is enabled in your organization configuration, users must verify their email address before they can accept invitations. This adds an extra security layer to ensure that only verified users can join your organization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    organization({
      requireEmailVerificationOnInvitation: true, // [!code highlight]
      async sendInvitationEmail(data) {
        // ... your email sending logic
      },
    }),
  ],
});
```

### Cancel Invitation

If a user has sent out an invitation, you can use this method to cancel it.

If you're looking for how a user can reject an invitation, you can find that [here](#reject-invitation).

<APIMethod path="/organization/cancel-invitation" method="POST" noResult requireSession>
```ts
type cancelInvitation = {
    /**
     * The ID of the invitation to cancel.  
     */
    invitationId: string = "invitation-id"
}
```
</APIMethod>

### Reject Invitation

If this user has received an invitation, but wants to decline it, this method will allow you to do so by rejecting it.

<APIMethod path="/organization/reject-invitation" method="POST" noResult requireSession>
```ts
type rejectInvitation = {
    /**
     * The ID of the invitation to reject.  
     */
    invitationId: string = "invitation-id"
}
```
</APIMethod>

<Callout type="info">
  Like accepting invitations, rejecting invitations also requires email
  verification when the `requireEmailVerificationOnInvitation` option is
  enabled. Users with unverified emails will receive an error when attempting to
  reject invitations.
</Callout>

### Get Invitation

To get an invitation you can use the `organization.getInvitation` function provided by the client. You need to provide the invitation id as a query parameter.

<APIMethod
  path="/organization/get-invitation"
  method="GET"
  requireSession
>
```ts
type getInvitation = {
    /**
     * The ID of the invitation to get.  
     */
    id: string = "invitation-id"
}
```
</APIMethod>

### List Invitations

To list all invitations for a given organization you can use the `listInvitations` function provided by the client.

<APIMethod path="/organization/list-invitations" method="GET" requireSession>
```ts
type listInvitations = {
    /**
     * An optional ID of the organization to list invitations for. If not provided, will default to the user's active organization. 
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

### List user invitations

To list all invitations for a given user you can use the `listUserInvitations` function provided by the client.

```ts
import { authClient } from "@/lib/auth-client"

const invitations = await authClient.organization.listUserInvitations();
```

On the server, you can pass the user ID as a query parameter.

```ts title="list-user-invitations.ts"
const invitations = await auth.api.listUserInvitations({
  query: {
    email: "user@example.com",
  },
});
```

<Callout type="warn">
  The `email` query parameter is only available on the server to query for
  invitations for a specific user.
</Callout>

## Members

### List Members

To list all members of an organization you can use the `listMembers` function.

<APIMethod path="/organization/list-members" method="GET" requireSession>

```ts
type listMembers = {
    /**
     * An optional organization ID to list members for. If not provided, will default to the user's active organization.
     */
    organizationId?: string = "organization-id"
    /**
     * The limit of members to return.
     */
    limit?: number = 100
    /**
     * The offset to start from.
     */
    offset?: number = 0
    /**
     * The field to sort by.
     */
    sortBy?: string = "createdAt"
    /**
     * The direction to sort by.
     */
    sortDirection?: "asc" | "desc" = "desc"
    /**
     * The field to filter by.
     */
    filterField?: string = "createdAt"
    /**
     * The operator to filter by.
     */
    filterOperator?: "eq" | "ne" | "lt" | "lte" | "gt" | "gte" | "in" | "not_in" | "contains" | "starts_with" | "ends_with" = "eq"
    /**
     * The value to filter by.
     */
    filterValue?: string | number | boolean | string[] | number[] = "value"
}
```
</APIMethod>

### Remove Member

To remove you can use `organization.removeMember`

<APIMethod path="/organization/remove-member" method="POST" requireSession>
```ts
type removeMember = {
    /**
     * The ID or email of the member to remove. 
     */
    memberIdOrEmail: string = "user@example.com"
    /**
     * The ID of the organization to remove the member from. If not provided, the active organization will be used. 
     */
    organizationId?: string = "org-id"
}
```
</APIMethod>

### Update Member Role

To update the role of a member in an organization, you can use the `organization.updateMemberRole`. If the user has the permission to update the role of the member, the role will be updated.

<APIMethod path="/organization/update-member-role" method="POST" noResult requireSession>
```ts
type updateMemberRole = {
    /**
     * The new role to be applied. This can be a string or array of strings representing the roles. 
     */
    role: string | string[] = ["admin", "sale"]
    /**
     * The member id to apply the role update to. 
     */
    memberId: string = "member-id"
    /**
     * An optional organization ID which the member is a part of to apply the role update. If not provided, you must provide session headers to get the active organization. 
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

### Get Active Member

To get the current member of the active organization you can use the `organization.getActiveMember` function. This function will return the user's member details in their active organization.

<APIMethod
  path="/organization/get-active-member"
  method="GET"
  requireSession
  resultVariable="member"
>
  ```ts 
  type getActiveMember = {
  }
  ```
</APIMethod>

### Get Active Member Role
To get the current role member of the active organization you can use the `organization.getActiveMemberRole` function. This function will return the user's member role in their active organization.

<APIMethod
  path="/organization/get-active-member-role"
  method="GET"
  requireSession
  resultVariable="{ role }"
>
  ```ts
  type getActiveMemberRole = {
  }
  ```
</APIMethod>

### Add Member

If you want to add a member directly to an organization without sending an invitation, you can use the `addMember` function which can only be invoked on the server.

<APIMethod
  path="/organization/add-member"
  method="POST"
  isServerOnly
>
```ts
type addMember = {
    /**
     * The user ID which represents the user to be added as a member. If `null` is provided, then it's expected to provide session headers. 
     */
    userId?: string | null = "user-id"
    /**
     * The role(s) to assign to the new member. 
     */
    role: string | string[] = ["admin", "sale"]
    /**
     * An optional organization ID to pass. If not provided, will default to the user's active organization. 
     */
    organizationId?: string = "org-id"
    /**
     * An optional team ID to add the member to. 
     */
    teamId?: string = "team-id"
}
```
</APIMethod>

### Leave Organization

To leave organization you can use `organization.leave` function. This function will remove the current user from the organization.

<APIMethod
  path="/organization/leave"
  method="POST"
  requireSession
  noResult
>
```ts
type leaveOrganization = {
    /**
     * The organization ID for the member to leave. 
     */
    organizationId: string = "organization-id"
}
```
</APIMethod>

## Access Control

The organization plugin provides a very flexible access control system. You can control the access of the user based on the role they have in the organization. You can define your own set of permissions based on the role of the user.

### Roles

By default, there are three roles in the organization:

`owner`: The user who created the organization by default. The owner has full control over the organization and can perform any action.

`admin`: Users with the admin role have full control over the organization except for deleting the organization or changing the owner.

`member`: Users with the member role have limited control over the organization. They can only read organization data and have no permissions to create, update, or delete resources.

<Callout>
  A user can have multiple roles. Multiple roles are stored as string separated
  by comma (",").
</Callout>

### Permissions

By default, there are three resources, and these have two to three actions.

**organization**:

    `update` `delete`

**member**:

    `create` `update` `delete`

**invitation**:

    `create` `cancel`

The owner has full control over all the resources and actions. The admin has full control over all the resources except for deleting the organization or changing the owner. The member has no control over any of those actions other than reading the data.

### Custom Permissions

The plugin provides an easy way to define your own set of permissions for each role.

<Steps>
    <Step>
    #### Create Access Control

    You first need to create access controller by calling `createAccessControl` function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value.
    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    /**
     * make sure to use `as const` so typescript can infer the type correctly
     */
    const statement = { // [!code highlight]
        project: ["create", "share", "update", "delete"], // [!code highlight]
    } as const; // [!code highlight]

    const ac = createAccessControl(statement); // [!code highlight]
    ```
    
    <Callout type="warning">
      To keep bundle sizes small, make sure to import from `better-auth/plugins/access` instead of `better-auth/plugins`.
    </Callout>
    </Step>

    <Step>
    #### Create Roles

    Once you have created the access controller you can create roles with the permissions you have defined.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    const statement = {
        project: ["create", "share", "update", "delete"],
    } as const;

    const ac = createAccessControl(statement);

    const member = ac.newRole({ // [!code highlight]
        project: ["create"], // [!code highlight]
    }); // [!code highlight]

    const admin = ac.newRole({ // [!code highlight]
        project: ["create", "update"], // [!code highlight]
    }); // [!code highlight]

    const owner = ac.newRole({ // [!code highlight]
        project: ["create", "update", "delete"], // [!code highlight]
    }); // [!code highlight]

    const myCustomRole = ac.newRole({ // [!code highlight]
        project: ["create", "update", "delete"], // [!code highlight]
        organization: ["update"], // [!code highlight]
    }); // [!code highlight]
    ```

      When you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import `defaultStatements` and merge it with your new statement, plus merge the roles' permissions set with the default roles.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";
    import { defaultStatements, adminAc } from 'better-auth/plugins/organization/access'

    const statement = {
        ...defaultStatements, // [!code highlight]
        project: ["create", "share", "update", "delete"],
    } as const;

    const ac = createAccessControl(statement);

    const admin = ac.newRole({
        project: ["create", "update"],
        ...adminAc.statements, // [!code highlight]
    });
    ```

    </Step>

    <Step>
        #### Pass Roles to the Plugin

        Once you have created the roles you can pass them to the organization plugin both on the client and the server.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { organization } from "better-auth/plugins"
        import { ac, owner, admin, member } from "@/auth/permissions"

        export const auth = betterAuth({
            plugins: [
                organization({
                    ac,
                    roles: {
                        owner,
                        admin,
                        member,
                        myCustomRole
                    }
                }),
            ],
        });
        ```

        You also need to pass the access controller and the roles to the client plugin.

        ```ts title="auth-client"
        import { createAuthClient } from "better-auth/client"
        import { organizationClient } from "better-auth/client/plugins"
        import { ac, owner, admin, member, myCustomRole } from "@/auth/permissions"

        export const authClient = createAuthClient({
            plugins: [
                organizationClient({
                    ac,
                    roles: {
                        owner,
                        admin,
                        member,
                        myCustomRole
                    }
                })
          ]
        })
        ```
    </Step>

</Steps>

### Access Control Usage

**Has Permission**:

You can use the `hasPermission` action provided by the `api` to check the permission of the user.

```ts title="has-permission.ts"
import { auth } from "@/lib/auth"

await auth.api.hasPermission({
  headers: await headers(),
  body: {
    permissions: {
      project: ["create"], // This must match the structure in your access control
    },
  },
});

// You can also check multiple resource permissions at the same time
await auth.api.hasPermission({
  headers: await headers(),
  body: {
    permissions: {
      project: ["create"], // This must match the structure in your access control
      sale: ["create"],
    },
  },
});
```

If you want to check the permission of the user on the client from the server you can use the `hasPermission` function provided by the client.

```ts title="auth-client.ts"
const canCreateProject = await authClient.organization.hasPermission({
  permissions: {
    project: ["create"],
  },
});

// You can also check multiple resource permissions at the same time
const canCreateProjectAndCreateSale =
  await authClient.organization.hasPermission({
    permissions: {
      project: ["create"],
      sale: ["create"],
    },
  });
```

**Check Role Permission**:

Once you have defined the roles and permissions to avoid checking the permission from the server you can use the `checkRolePermission` function provided by the client.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

const canCreateProject = authClient.organization.checkRolePermission({
  permissions: {
    organization: ["delete"],
  },
  role: "admin",
});

// You can also check multiple resource permissions at the same time
const canCreateProjectAndCreateSale =
  authClient.organization.checkRolePermission({
    permissions: {
      organization: ["delete"],
      member: ["delete"],
    },
    role: "admin",
  });
```

<Callout type="warn">
  This will not include any dynamic roles as everything is ran synchronously on the client side.
  Please use the [hasPermission](#access-control-usage) APIs to include checks for any dynamic roles & permissions.
</Callout>

---

## Dynamic Access Control 

Dynamic access control allows you to create roles at runtime for organizations. This is achieved by storing the
created roles and permissions associated with an organization in a database table.

### Enabling Dynamic Access Control

To enable dynamic access control, pass the `dynamicAccessControl` configuration option with `enabled` set to `true` to both server and client plugins.

Ensure you have pre-defined an `ac` instance on the server auth plugin.
This is important as this is how we can infer the permissions that are available for use.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";
import { ac } from "@/auth/permissions";

export const auth = betterAuth({
    plugins: [
        organization({ // [!code highlight]
            ac, // Must be defined in order for dynamic access control to work // [!code highlight]
            dynamicAccessControl: { // [!code highlight]
              enabled: true, // [!code highlight]
            }, // [!code highlight]
        }) // [!code highlight]
    ]
})
```

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { organizationClient } from "better-auth/client/plugins";

export const authClient = createAuthClient({
    plugins: [
        organizationClient({ // [!code highlight]
            dynamicAccessControl: { // [!code highlight]
              enabled: true, // [!code highlight]
            }, // [!code highlight]
        }) // [!code highlight]
    ]
})
```

<Callout>
  This will require you to run migrations to add the new `organizationRole` table to the database.
</Callout>


<Callout type="warn">
  The `authClient.organization.checkRolePermission` function will not include any dynamic roles as everything is ran synchronously on the client side.
  Please use the [hasPermission](#access-control-usage) APIs to include checks for any dynamic roles.
</Callout>

### Creating a role

To create a new role for an organization at runtime, you can use the `createRole` function.

Only users with roles which contain the `ac` resource with the `create` permission can create a new role.
By default, only the `admin` and `owner` roles have this permission. You also cannot add permissions that your
current role in that organization can't already access.

<APIMethod
  path="/organization/create-role"
  method="POST"
  requireSession
  noResult
>
```ts
// To use custom resources or permissions,
// make sure they are defined in the `ac` instance of your organization config.
const permission = {
  project: ["create", "update", "delete"]
}

type createOrgRole = {
    /**
     * A unique name of the role to create.
     */
    role: string = "my-unique-role"
    /**
     * The permissions to assign to the role.
     */
    permission?: Record<string, string[]> = permission,
    /**
     * The organization ID which the role will be created in. Defaults to the active organization.
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

Now you can freely call [`updateMemberRole`](#update-member-role) to update the role of a member with your newly created role!

### Deleting a role

To delete a role, you can use the `deleteRole` function, then provide either a `roleName` or `roleId` parameter along
with the `organizationId` parameter.

<APIMethod
  path="/organization/delete-role"
  method="POST"
  requireSession
  noResult
>
```ts
type deleteOrgRole = {
    /**
     * The name of the role to delete. Alternatively, you can pass a `roleId` parameter instead.
     */
    roleName?: string = "my-role"
    /**
     * The id of the role to delete. Alternatively, you can pass a `roleName` parameter instead.
     */
    roleId?: string = "role-id"
    /**
     * The organization ID which the role will be deleted in. Defaults to the active organization.
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

### Listing roles

To list roles, you can use the `listOrgRoles` function.
This requires the `ac` resource with the `read` permission for the member to be able to list roles.

<APIMethod
  path="/organization/list-roles"
  method="GET"
  requireSession
  resultVariable="roles"
>
```ts
type listOrgRoles = {
    /**
     * The organization ID which the roles are under to list. Defaults to the user's active organization. 
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

### Getting a specific role

To get a specific role, you can use the `getOrgRole` function and pass either a `roleName` or `roleId` parameter.
This requires the `ac` resource with the `read` permission for the member to be able to get a role.


<APIMethod
  path="/organization/get-role"
  method="GET"
  requireSession
  resultVariable="role"
>
```ts
type getOrgRole = {
    /**
     * The name of the role to get. Alternatively, you can pass a `roleId` parameter instead.
     */
    roleName?: string = "my-role"
    /**
     * The id of the role to get. Alternatively, you can pass a `roleName` parameter instead.
     */
    roleId?: string = "role-id"
    /**
     * The organization ID from which the role will be retrieved. Defaults to the active organization.
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

### Updating a role

To update a role, you can use the `updateOrgRole` function and pass either a `roleName` or `roleId` parameter.


<APIMethod
  path="/organization/update-role"
  method="POST"
  requireSession
  resultVariable="updatedRole"
>
```ts
type updateOrgRole = {
    /**
     * The name of the role to update. Alternatively, you can pass a `roleId` parameter instead.
     */
    roleName?: string = "my-role"
    /**
     * The id of the role to update. Alternatively, you can pass a `roleName` parameter instead.
     */
    roleId?: string = "role-id"
    /**
     * The organization ID which the role will be updated in. Defaults to the active organization.
     */
    organizationId?: string = "organization-id"
    /**
     * The data which will be updated
    */
    data: {
      /**
       * Optionally update the permissions of the role.
       */
      permission?: Record<string, string[]> = { project: ["create", "update", "delete"] }
      /**
       * Optionally update the name of the role.
       */
      roleName?: string = "my-new-role"
    }
}
```
</APIMethod>


### Configuration Options

Below is a list of options that can be passed to the `dynamicAccessControl` object.

#### `enabled`

This option is used to enable or disable dynamic access control. By default, it is disabled.

```ts
organization({
  dynamicAccessControl: {
    enabled: true // [!code highlight]
  }
})
```

#### `maximumRolesPerOrganization`

This option is used to limit the number of roles that can be created for an organization.

By default, the maximum number of roles that can be created for an organization is infinite.

```ts
organization({
  dynamicAccessControl: {
    maximumRolesPerOrganization: 10 // [!code highlight]
  }
})
```

You can also pass a function that returns a number.

```ts
organization({
  dynamicAccessControl: {
    maximumRolesPerOrganization: async (organizationId) => { // [!code highlight]
      const organization = await getOrganization(organizationId); // [!code highlight]
      return organization.plan === "pro" ? 100 : 10; // [!code highlight]
    } // [!code highlight]
  }
})
```

### Additional Fields

To add additional fields to the `organizationRole` table, you can pass the `additionalFields` configuration option to the `organization` plugin.

```ts
organization({
  schema: {
    organizationRole: {
      additionalFields: {
        // Role colors!
        color: {
          type: "string",
          defaultValue: "#ffffff",
        },
        //... other fields
      },
    },
  },
})
```

Then, if you don't already use `inferOrgAdditionalFields` to infer the additional fields, you can use it to infer the additional fields.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { organizationClient, inferOrgAdditionalFields } from "better-auth/client/plugins"
import type { auth } from "@/lib/auth" // import the auth object type only

export const authClient = createAuthClient({
    plugins: [
        organizationClient({
            schema: inferOrgAdditionalFields<typeof auth>()
        })
    ]
})
```
Otherwise, you can pass the schema values directly, the same way you do on the org plugin in the server.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { organizationClient } from "better-auth/client/plugins"

export const authClient = createAuthClient({
    plugins: [
        organizationClient({
            schema: {
                organizationRole: {
                    additionalFields: {
                        color: {
                            type: "string",
                            defaultValue: "#ffffff",
                        }
                    }
                }
            }
        })
    ]
})
```


---

## Teams

Teams allow you to group members within an organization. The teams feature provides additional organization structure and can be used to manage permissions at a more granular level.

### Enabling Teams

To enable teams, pass the `teams` configuration option to both server and client plugins:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    organization({
      teams: {
        enabled: true,
        maximumTeams: 10, // Optional: limit teams per organization
        allowRemovingAllTeams: false, // Optional: prevent removing the last team
      },
    }),
  ],
});
```

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { organizationClient } from "better-auth/client/plugins";

export const authClient = createAuthClient({
  plugins: [
    organizationClient({
      teams: {
        enabled: true,
      },
    }),
  ],
});
```

### Managing Teams

#### Create Team

Create a new team within an organization:

<APIMethod path="/organization/create-team" method="POST">
```ts
type createTeam = {
    /**
     * The name of the team. 
     */
    name: string = "my-team"
    /**
     * The organization ID which the team will be created in. Defaults to the active organization. 
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

#### List Teams

Get all teams in an organization:

<APIMethod
  path="/organization/list-teams"
  method="GET"
  requireSession
>
```ts
type listOrganizationTeams = {
    /**
    * The organization ID which the teams are under to list. Defaults to the user's active organization. 
    */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

#### Update Team

Update a team's details:

<APIMethod
  path="/organization/update-team"
  method="POST"
  requireSession
>
```ts
type updateTeam = {
    /**
     * The ID of the team to be updated. 
     */
    teamId: string = "team-id"
    /**
     * A partial object containing options for you to update.
     */
    data: {
        /**
         * The name of the team to be updated.
         */
        name?: string = "My new team name"
        /**
         * The organization ID which the team falls under.
         */
        organizationId?: string = "My new organization ID for this team"
        /**
         * The timestamp of when the team was created.
         */
        createdAt?: Date = new Date()
        /**
         * The timestamp of when the team was last updated.
         */
        updatedAt?: Date = new Date()
    }
}
```
</APIMethod>

#### Remove Team

Delete a team from an organization:

<APIMethod path="/organization/remove-team" method="POST">
```ts
type removeTeam = {
    /**
     * The team ID of the team to remove. 
     */
    teamId: string = "team-id"
    /**
     * The organization ID which the team falls under. If not provided, it will default to the user's active organization. 
     */
    organizationId?: string = "organization-id"
}
```
</APIMethod>

#### Set Active Team

Sets the given team as the current active team. If `teamId` is `null` the current active team is unset.

<APIMethod path="/organization/set-active-team" method="POST" requireSession>
```ts
type setActiveTeam = {
    /**
     * The team ID of the team to set as the current active team.
     */
    teamId?: string = "team-id"
}
```
</APIMethod>

#### List User Teams

List all teams that the current user is a part of.

<APIMethod path="/organization/list-user-teams" method="GET" requireSession>
  ```ts 
  type listUserTeams = {
  }
  ```
</APIMethod>

#### List Team Members

List the members of the given team.

<APIMethod path="/organization/list-team-members" method="POST" forceAsQuery requireSession>
```ts
type listTeamMembers = {
    /**
     * The team whose members we should return. If this is not provided the members of the current active team get returned.
     */
    teamId?: string = "team-id"
}
```
</APIMethod>

#### Add Team Member

Add a member to a team.

<APIMethod path="/organization/add-team-member" method="POST" requireSession>
```ts
type addTeamMember = {
    /**
     * The team the user should be a member of.
     */
    teamId: string = "team-id"
    /**
     * The user ID which represents the user to be added as a member.
     */
    userId: string = "user-id"
}
```
</APIMethod>

#### Remove Team Member

Remove a member from a team.

<APIMethod path="/organization/remove-team-member" method="POST" requireSession>
```ts
type removeTeamMember = {
    /**
     * The team the user should be removed from.
     */
    teamId: string = "team-id"
    /**
     * The user which should be removed from the team.
     */
    userId: string = "user-id"
}
```
</APIMethod>

### Team Permissions

Teams follow the organization's permission system. To manage teams, users need the following permissions:

- `team:create` - Create new teams
- `team:update` - Update team details
- `team:delete` - Remove teams

By default:

- Organization owners and admins can manage teams
- Regular members cannot create, update, or delete teams

### Team Configuration Options

The teams feature supports several configuration options:

- `maximumTeams`: Limit the number of teams per organization

  ```ts
  teams: {
    enabled: true,
    maximumTeams: 10 // Fixed number
    // OR
    maximumTeams: async ({ organizationId, session }, ctx) => {
      // Dynamic limit based on organization plan
      const plan = await getPlan(organizationId)
      return plan === 'pro' ? 20 : 5
    },
    maximumMembersPerTeam: 10 // Fixed number
    // OR
    maximumMembersPerTeam: async ({ teamId, session, organizationId }, ctx) => {
      // Dynamic limit based on team plan
      const plan = await getPlan(organizationId, teamId)
      return plan === 'pro' ? 50 : 10
    },
  }
  ```

- `allowRemovingAllTeams`: Control whether the last team can be removed
  ```ts
  teams: {
    enabled: true,
    allowRemovingAllTeams: false // Prevent removing the last team
  }
  ```

### Team Members

When inviting members to an organization, you can specify a team:

```ts
await authClient.organization.inviteMember({
  email: "user@example.com",
  role: "member",
  teamId: "team-id",
});
```

The invited member will be added to the specified team upon accepting the invitation.

### Database Schema

When teams are enabled, new `team` and `teamMember` tables are added to the database.

Table Name: `team`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each team",
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "The name of the team",
    },
    {
      name: "organizationId",
      type: "string",
      description: "The ID of the organization",
      isForeignKey: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the team was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      isOptional: true,
      description: "Timestamp of when the team was created",
    },
  ]}
/>

Table Name: `teamMember`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each team member",
      isPrimaryKey: true,
    },
    {
      name: "teamId",
      type: "string",
      description: "Unique identifier for each team",
      isForeignKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the team member was created",
    },
  ]}
/>

## Schema

The organization plugin adds the following tables to the database:

### Organization

Table Name: `organization`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each organization",
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "The name of the organization",
    },
    {
      name: "slug",
      type: "string",
      description: "The slug of the organization",
    },
    {
      name: "logo",
      type: "string",
      description: "The logo of the organization",
      isOptional: true,
    },
    {
      name: "metadata",
      type: "string",
      description: "Additional metadata for the organization",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the organization was created",
    },
  ]}
/>

### Member

Table Name: `member`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each member",
      isPrimaryKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "organizationId",
      type: "string",
      description: "The ID of the organization",
      isForeignKey: true,
    },
    {
      name: "role",
      type: "string",
      description: "The role of the user in the organization",
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the member was added to the organization",
    },
  ]}
/>

### Invitation

Table Name: `invitation`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each invitation",
      isPrimaryKey: true,
    },
    {
      name: "email",
      type: "string",
      description: "The email address of the user",
    },
    {
      name: "inviterId",
      type: "string",
      description: "The ID of the inviter",
      isForeignKey: true,
    },
    {
      name: "organizationId",
      type: "string",
      description: "The ID of the organization",
      isForeignKey: true,
    },
    {
      name: "role",
      type: "string",
      description: "The role of the user in the organization",
    },
    {
      name: "status",
      type: "string",
      description: "The status of the invitation",
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the invitation was created"
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "Timestamp of when the invitation expires",
    },
  ]}
/>

If teams are enabled, you need to add the following fields to the invitation table:

<DatabaseTable
  fields={[
    {
      name: "teamId",
      type: "string",
      description: "The ID of the team",
      isOptional: true,
    },
  ]}
/>

### Session

Table Name: `session`

You need to add two more fields to the session table to store the active organization ID and the active team ID.

<DatabaseTable
  fields={[
    {
      name: "activeOrganizationId",
      type: "string",
      description: "The ID of the active organization",
      isOptional: true,
    },
    {
      name: "activeTeamId",
      type: "string",
      description: "The ID of the active team",
      isOptional: true,
    },
  ]}
/>

### Organization Role (optional)

Table Name: `organizationRole`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each organization role",
    },
    {
      name: "organizationId",
      type: "string",
      description: "The ID of the organization",
      isForeignKey: true,
    },
    {
      name: "role",
      type: "string",
      description: "The name of the role",
    },
    {
      name: "permission",
      type: "string",
      description: "The permission of the role",
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the organization role was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the organization role was updated",
    },
  ]}
/>

### Teams (optional)

Table Name: `team`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each team",
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "The name of the team",
    },
    {
      name: "organizationId",
      type: "string",
      description: "The ID of the organization",
      isForeignKey: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the team was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      isOptional: true,
      description: "Timestamp of when the team was created",
    },
  ]}
/>

Table Name: `teamMember`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each team member",
      isPrimaryKey: true,
    },
    {
      name: "teamId",
      type: "string",
      description: "Unique identifier for each team",
      isForeignKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the team member was created",
    },
  ]}
/>

Table Name: `invitation`

<DatabaseTable
  fields={[
    {
      name: "teamId",
      type: "string",
      description: "The ID of the team",
      isOptional: true,
    },
  ]}
/>

### Customizing the Schema

To change the schema table name or fields, you can pass `schema` option to the organization plugin.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

const auth = betterAuth({
  plugins: [
    organization({
      schema: {
        organization: {
          modelName: "organizations", //map the organization table to organizations
          fields: {
            name: "title", //map the name field to title
          },
          additionalFields: {
            // Add a new field to the organization table
            myCustomField: {
              type: "string",
              input: true,
              required: false,
            },
          },
        },
      },
    }),
  ],
});
```

#### Additional Fields

Starting with [Better Auth v1.3](https://github.com/better-auth/better-auth/releases/tag/v1.3.0), you can easily add custom fields to the `organization`, `invitation`, `member`, and `team` tables.

When you add extra fields to a model, the relevant API endpoints will automatically accept and return these new properties. For instance, if you add a custom field to the `organization` table, the `createOrganization` endpoint will include this field in its request and response payloads as needed.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";

const auth = betterAuth({
  plugins: [
    organization({
      schema: {
        organization: {
          additionalFields: {
            myCustomField: {
              // [!code highlight]
              type: "string", // [!code highlight]
              input: true, // [!code highlight]
              required: false, // [!code highlight]
            }, // [!code highlight]
          },
        },
      },
    }),
  ],
});
```

For inferring the additional fields, you can use the `inferOrgAdditionalFields` function. This function will infer the additional fields from the auth object type.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import {
  inferOrgAdditionalFields,
  organizationClient,
} from "better-auth/client/plugins";
import type { auth } from "@/lib/auth" // import the auth object type only

const client = createAuthClient({
  plugins: [
    organizationClient({
      schema: inferOrgAdditionalFields<typeof auth>(),
    }),
  ],
});
```

if you can't import the auth object type, you can use the `inferOrgAdditionalFields` function without the generic. This function will infer the additional fields from the schema object.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import {
  inferOrgAdditionalFields,
  organizationClient,
} from "better-auth/client/plugins";

const client = createAuthClient({
  plugins: [
    organizationClient({
      schema: inferOrgAdditionalFields({
        organization: {
          // [!code highlight]
          additionalFields: {
            newField: {
              // [!code highlight]
              type: "string", // [!code highlight]
            }, // [!code highlight]
          },
        },
      }),
    }),
  ],
});
```
#### Example usage
```ts
await client.organization.create({
  name: "Test",
  slug: "test",
  newField: "123", //this should be allowed
  //@ts-expect-error - this field is not available
  unavailableField: "123", //this should be not allowed
});
```

## Options

**allowUserToCreateOrganization**: `boolean` | `((user: User) => Promise<boolean> | boolean)` - A function that determines whether a user can create an organization. By default, it's `true`. You can set it to `false` to restrict users from creating organizations.

**organizationLimit**: `number` | `((user: User) => Promise<boolean> | boolean)` - The maximum number of organizations allowed for a user. By default, it's `unlimited`. You can set it to any number you want, or a function that returns a boolean. **If you provide a function, it should return `true` if the user has reached their organization limit (blocking further creation), or `false` if they have not reached their limit (allowing further creation).**

**creatorRole**: `admin | owner` - The role of the user who creates the organization. By default, it's `owner`. You can set it to `admin`.

**membershipLimit**: `number` | `((user: User, organization: Organization) => Promise<number> | number)` - The maximum number of members allowed in an organization. By default, it's `100`. You can set it to any number you want or a function that returns the limit number.

**sendInvitationEmail**: `async (data) => Promise<void>` - A function that sends an invitation email to the user.

**invitationExpiresIn** : `number` - How long the invitation link is valid for in seconds. By default, it's 48 hours (2 days).

**cancelPendingInvitationsOnReInvite**: `boolean` - Whether to cancel pending invitations if the user is already invited to the organization. By default, it's `false`.

**invitationLimit**: `number` | `((user: User) => Promise<boolean> | boolean)` - The maximum number of invitations allowed for a user. By default, it's `100`. You can set it to any number you want or a function that returns a boolean.

**requireEmailVerificationOnInvitation**: `boolean` - Whether to require email verification before accepting or rejecting invitations. By default, it's `false`. When enabled, users must have verified their email address before they can accept or reject organization invitations.
---
title: OAuth Proxy
description: OAuth Proxy plugin for Better Auth
---

A proxy plugin, that allows you to proxy OAuth requests. Useful for development and preview deployments where the redirect URL can't be known in advance to add to the OAuth provider. 

## Installation

<Steps>
  <Step>
    ### Add the plugin to your **auth** config
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { oAuthProxy } from "better-auth/plugins" // [!code highlight]

    export const auth = betterAuth({
    plugins: [
    oAuthProxy({ // [!code highlight]
    productionURL: "https://my-main-app.com", // Optional - if the URL isn't inferred correctly // [!code highlight]
    currentURL: "http://localhost:3000", // Optional - if the URL isn't inferred correctly // [!code highlight]
  }), // [!code highlight]
    ]
  })
    ```
  </Step>
  <Step>
    ### Add redirect URL to your OAuth provider

    For the proxy server to work properly, you’ll need to pass the redirect URL of your main production app registered with the OAuth provider in your social provider config. This needs to be done for each social provider you want to proxy requests for.

    ```ts
    export const auth = betterAuth({
    plugins: [
    oAuthProxy(),
    ],
    socialProviders: {
    github: {
    clientId: "your-client-id",
    clientSecret: "your-client-secret",
    redirectURI: "https://my-main-app.com/api/auth/callback/github" // [!code highlight]
  }
  }
  })
    ```
  </Step>
</Steps>

## How it works

The plugin allows you to use a single OAuth client (registered with your production URL) across multiple environments like preview deployments or local development.

1. Preview server initiates OAuth, redirecting to the OAuth provider with production's redirect URI
2. OAuth provider callbacks to production server
3. Production server exchanges the code for tokens and fetches user info
4. Production server encrypts the profile data and redirects to preview server (**no database write on production**)
5. Preview server decrypts the profile, creates user/session in its own database, and sets the session cookie

```ts
import { authClient } from "@/lib/auth-client"

await authClient.signIn.social({
    provider: "github",
    callbackURL: "/dashboard"
})
```

The encrypted profile data is passed via URL query parameters and can only be decrypted by servers sharing the same secret. This also allows preview deployments to use separate databases from production if needed.

<Callout type="info">
This plugin is intended for development and preview environments. If `baseURL` and `productionURL` are the same, the plugin will not proxy the request.
</Callout>

## Options

**productionURL**: If this value matches the `baseURL` in your auth config, requests will not be proxied. Defaults to the `BETTER_AUTH_URL` environment variable.

**currentURL**: The application's current URL is automatically determined by the plugin. It first checks for the request URL if invoked by a client, then it checks the base URL from popular hosting providers, and finally falls back to the `baseURL` in your auth config. If the URL isn't inferred correctly, you can specify it manually here.

**maxAge**: Maximum age in seconds for encrypted profile payloads. Payloads older than this will be rejected to prevent replay attacks. Keep this value short (e.g., 30-60 seconds) to minimize the window for potential replay attacks while still allowing normal OAuth flows. Defaults to `60` seconds.
---
title: Multi Session
description: Learn how to use multi-session plugin in Better Auth.
---

The multi-session plugin allows users to maintain multiple active sessions across different accounts in the same browser. This plugin is useful for applications that require users to switch between multiple accounts without logging out.

## Installation

<Steps>
<Step>
### Add the plugin to your **auth** config
```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { multiSession } from "better-auth/plugins"  // [!code highlight]

export const auth = betterAuth({
    plugins: [
        multiSession(), // [!code highlight]
    ]
})
```
</Step>
<Step>
        ### Add the client Plugin

        Add the client plugin and Specify where the user should be redirected if they need to verify 2nd factor

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { multiSessionClient } from "better-auth/client/plugins"  // [!code highlight]

        export const authClient = createAuthClient({
            plugins: [
                multiSessionClient()  // [!code highlight]
            ]
        })
        ```
        </Step>
</Steps>    


## Usage

Whenever a user logs in, the plugin will add additional cookie to the browser. This cookie will be used to maintain multiple sessions across different accounts. 


### List all device sessions

To list all active sessions for the current user, you can call the `listDeviceSessions` method.

<APIMethod
  path="/multi-session/list-device-sessions"
  method="GET"
  requireSession
>
```ts
type listDeviceSessions = {
}
```
</APIMethod>

### Set active session

To set the active session, you can call the `setActive` method.

<APIMethod
  path="/multi-session/set-active"
  method="POST"
  requireSession
>
```ts
type setActiveSession = {
    /**
     * The session token to set as active. 
     */
    sessionToken: string = "some-session-token"
}
```
</APIMethod>

### Revoke a session

To revoke a session, you can call the `revoke` method.

<APIMethod
  path="/multi-session/revoke"
  method="POST"
  requireSession
>
```ts
type revokeDeviceSession = {
    /**
     * The session token to revoke. 
     */
    sessionToken: string = "some-session-token"
}
```
</APIMethod>

### Signout and Revoke all sessions

When a user logs out, the plugin will revoke all active sessions for the user. You can do this by calling the existing `signOut` method, which handles revoking all sessions automatically.

### Max Sessions

You can specify the maximum number of sessions a user can have by passing the `maximumSessions` option to the plugin. By default, the plugin allows 5 sessions per device.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { multiSession } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        multiSession({
            maximumSessions: 3
        })
    ]
})
```
---
title: Last Login Method
description: Track and display the last authentication method used by users
---

The last login method plugin tracks the most recent authentication method used by users (email, OAuth providers, etc.). This enables you to display helpful indicators on login pages, such as "Last signed in with Google" or prioritize certain login methods based on user preferences.

## Installation

<Steps>
    <Step>
        ### Add the plugin to your auth config

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { lastLoginMethod } from "better-auth/plugins" // [!code highlight]

        export const auth = betterAuth({
            // ... other config options
            plugins: [
                lastLoginMethod() // [!code highlight]
            ]
        })
        ```
    </Step>
    <Step>
        ### Add the client plugin to your auth client

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { lastLoginMethodClient } from "better-auth/client/plugins" // [!code highlight]

        export const authClient = createAuthClient({
            plugins: [
                lastLoginMethodClient() // [!code highlight]
            ]
        })
        ```
    </Step>
</Steps>

## Usage

Once installed, the plugin automatically tracks the last authentication method used by users. You can then retrieve and display this information in your application.

### Getting the Last Used Method

The client plugin provides several methods to work with the last login method:

```ts title="app.tsx"
import { authClient } from "@/lib/auth-client"

// Get the last used login method
const lastMethod = authClient.getLastUsedLoginMethod()
console.log(lastMethod) // "google", "email", "github", etc.

// Check if a specific method was last used
const wasGoogle = authClient.isLastUsedLoginMethod("google")

// Clear the stored method
authClient.clearLastUsedLoginMethod()
```

### UI Integration Example

Here's how to use the plugin to enhance your login page:

```tsx title="sign-in.tsx"
import { authClient } from "@/lib/auth-client"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"

export function SignInPage() {
    const lastMethod = authClient.getLastUsedLoginMethod()
    
    return (
        <div className="space-y-4">
            <h1>Sign In</h1>
            
            {/* Email sign in */}
            <div className="relative">
                <Button 
                    onClick={() => authClient.signIn.email({...})}
                    variant={lastMethod === "email" ? "default" : "outline"}
                    className="w-full"
                >
                    Sign in with Email
                    {lastMethod === "email" && (
                        <Badge className="ml-2">Last used</Badge>
                    )}
                </Button>
            </div>
            
            {/* OAuth providers */}
            <div className="relative">
                <Button 
                    onClick={() => authClient.signIn.social({ provider: "google" })}
                    variant={lastMethod === "google" ? "default" : "outline"}
                    className="w-full"
                >
                    Continue with Google
                    {lastMethod === "google" && (
                        <Badge className="ml-2">Last used</Badge>
                    )}
                </Button>
            </div>
            
            <div className="relative">
                <Button 
                    onClick={() => authClient.signIn.social({ provider: "github" })}
                    variant={lastMethod === "github" ? "default" : "outline"}
                    className="w-full"
                >
                    Continue with GitHub
                    {lastMethod === "github" && (
                        <Badge className="ml-2">Last used</Badge>
                    )}
                </Button>
            </div>
        </div>
    )
}
```

## Database Persistence

By default, the last login method is stored only in cookies. For more persistent tracking and analytics, you can enable database storage.

<Steps>
    <Step>
        ### Enable database storage

        Set `storeInDatabase` to `true` in your plugin configuration:

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { lastLoginMethod } from "better-auth/plugins"

        export const auth = betterAuth({
            plugins: [
                lastLoginMethod({
                    storeInDatabase: true // [!code highlight]
                })
            ]
        })
        ```
    </Step>
    <Step>
        ### Run database migration

        The plugin will automatically add a `lastLoginMethod` field to your user table. Run the migration to apply the changes:

   <Tabs items={["migrate", "generate"]}>
      <Tab value="migrate">
      ```package-install
      npx auth@latest migrate
      ```
      </Tab>
      <Tab value="generate">
      ```package-install
      npx auth@latest generate
      ```
      </Tab>
    </Tabs>
    </Step>
    <Step>
        ### Access database field

        When database storage is enabled, the `lastLoginMethod` field becomes available in user objects:

        ```ts title="user-profile.tsx"
        import { auth } from "@/lib/auth"

        // Server-side access
        const session = await auth.api.getSession({ headers })
        console.log(session?.user.lastLoginMethod) // "google", "email", etc.

        // Client-side access via session
        const { data: session } = authClient.useSession()
        console.log(session?.user.lastLoginMethod)
        ```
    </Step>
</Steps>

### Database Schema

When `storeInDatabase` is enabled, the plugin adds the following field to the `user` table:

Table: `user`

<DatabaseTable
    fields={[
        { name: "lastLoginMethod", type: "string", description: "The last authentication method used by the user", isOptional: true },
    ]}
/>

### Custom Schema Configuration

You can customize the database field name:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { lastLoginMethod } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        lastLoginMethod({
            storeInDatabase: true,
            schema: {
                user: {
                    lastLoginMethod: "last_auth_method" // Custom field name
                }
            }
        })
    ]
})
```

## Configuration Options

The last login method plugin accepts the following options:

### Server Options

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { lastLoginMethod } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        lastLoginMethod({
            // Cookie configuration
            cookieName: "better-auth.last_used_login_method", // Default: "better-auth.last_used_login_method"
            maxAge: 60 * 60 * 24 * 30, // Default: 30 days in seconds
            
            // Database persistence
            storeInDatabase: false, // Default: false
            
            // Custom method resolution
            customResolveMethod: (ctx) => {
                // Custom logic to determine the login method
                if (ctx.path === "/oauth/callback/custom-provider") {
                    return "custom-provider"
                }
                // Return null to use default resolution
                return null
            },
            
            // Schema customization (when storeInDatabase is true)
            schema: {
                user: {
                    lastLoginMethod: "custom_field_name"
                }
            }
        })
    ]
})
```

**cookieName**: `string`
- The name of the cookie used to store the last login method
- Default: `"better-auth.last_used_login_method"`
- **Note**: This cookie is `httpOnly: false` to allow client-side JavaScript access for UI features

**maxAge**: `number`  
- Cookie expiration time in seconds
- Default: `2592000` (30 days)

**storeInDatabase**: `boolean`
- Whether to store the last login method in the database
- Default: `false`
- When enabled, adds a `lastLoginMethod` field to the user table

**customResolveMethod**: `(ctx: GenericEndpointContext) => string | null`
- Custom function to determine the login method from the request context
- Return `null` to use the default resolution logic
- Useful for custom OAuth providers or authentication flows

**schema**: `object`
- Customize database field names when `storeInDatabase` is enabled
- Allows mapping the `lastLoginMethod` field to a custom column name

### Client Options

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { lastLoginMethodClient } from "better-auth/client/plugins"

export const authClient = createAuthClient({
    plugins: [
        lastLoginMethodClient({
            cookieName: "better-auth.last_used_login_method" // Default: "better-auth.last_used_login_method"
        })
    ]
})
```

**cookieName**: `string`
- The name of the cookie to read the last login method from
- Must match the server-side `cookieName` configuration
- Default: `"better-auth.last_used_login_method"`

### Default Method Resolution

By default, the plugin tracks these authentication methods:

- **Email authentication**: `"email"`
- **OAuth providers**: Provider ID (e.g., `"google"`, `"github"`, `"discord"`)
- **OAuth2 callbacks**: Provider ID from URL path
- **Sign up methods**: Tracked the same as sign in methods

The plugin automatically detects the method from these endpoints:
- `/callback/:id` - OAuth callback with provider ID
- `/oauth2/callback/:id` - OAuth2 callback with provider ID  
- `/sign-in/email` - Email sign in
- `/sign-up/email` - Email sign up

## Cross-Domain Support

The plugin automatically inherits cookie settings from Better Auth's centralized cookie system. This solves the problem where the last login method wouldn't persist across:

- **Cross-subdomain setups**: `auth.example.com` → `app.example.com`
- **Cross-origin setups**: `api.company.com` → `app.different.com`

When you enable `crossSubDomainCookies` or `crossOriginCookies` in your Better Auth config, the plugin will automatically use the same domain, secure, and sameSite settings as your session cookies, ensuring consistent behavior across your application.

## Advanced Examples

### Custom Provider Tracking

If you have custom OAuth providers or authentication methods, you can use the `customResolveMethod` option:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { lastLoginMethod } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        lastLoginMethod({
            customResolveMethod: (ctx) => {
                // Track custom SAML provider
                if (ctx.path === "/saml/callback") {
                    return "saml"
                }
                
                // Track magic link authentication
                if (ctx.path === "/magic-link/verify") {
                    return "magic-link"
                }
                
                // Track phone authentication
                if (ctx.path === "/sign-in/phone") {
                    return "phone"
                }
                
                // Return null to use default logic
                return null
            }
        })
    ]
})
```

### Usage with Expo

When using Better Auth with Expo, make sure to import the client plugin from `@better-auth/expo/plugins` rather than from `better-auth/plugins/client`. This ensures the last login method is stored correctly using the configured storage.

```ts
import { createAuthClient } from "better-auth/react"
import { expoClient } from "@better-auth/expo"
import { lastLoginMethodClient } from "@better-auth/expo/plugins" // [!code highlight]
import * as SecureStore from "expo-secure-store"

export const authClient = createAuthClient({
  plugins: [
    expoClient({
      scheme: "myapp",
      storagePrefix: "myapp",
      storage: SecureStore,
    }),
    lastLoginMethodClient({
      storagePrefix: "myapp",
      storage: SecureStorage,
    })
  ]
})
```

<Callout type="info">
    In Expo only apps, where browser support isn’t needed, you can omit the server plugin and rely solely on the client plugin.
</Callout>
---
title: Stripe
description: Stripe plugin for Better Auth to manage subscriptions and payments.
---

The Stripe plugin integrates Stripe's payment and subscription functionality with Better Auth. Since payment and authentication are often tightly coupled, this plugin simplifies the integration of Stripe into your application, handling customer creation, subscription management, and webhook processing.

## Features

- Create Stripe Customers automatically when users sign up
- Manage subscription plans and pricing
- Process subscription lifecycle events (creation, updates, cancellations)
- Handle Stripe webhooks securely with signature verification
- Expose subscription data to your application
- Support for trial periods and subscription upgrades
- **Automatic trial abuse prevention** - Users can only get one trial per account across all plans
- Flexible reference system to associate subscriptions with users or organizations
- Team subscription support with seats management

## Installation

<Steps>
    <Step>
        ### Install the plugin

        First, install the plugin:

        ```package-install
        @better-auth/stripe
        ```
        <Callout>
        If you're using a separate client and server setup, make sure to install the plugin in both parts of your project.
        </Callout>
    </Step>
    <Step>
        ### Install the Stripe SDK

        Next, install the Stripe SDK on your server:

        ```package-install
        stripe@^20.0.0
        ```
    </Step>
    <Step>
        ### Add the plugin to your auth config

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { stripe } from "@better-auth/stripe"
        import Stripe from "stripe"

        const stripeClient = new Stripe(process.env.STRIPE_SECRET_KEY!, {
            apiVersion: "2025-11-17.clover", // Latest API version as of Stripe SDK v20.0.0
        })

        export const auth = betterAuth({
            // ... your existing config
            plugins: [
                stripe({
                    stripeClient,
                    stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET!,
                    createCustomerOnSignUp: true,
                })
            ]
        })
        ```

        <Callout type="info">
        **Upgrading from Stripe v18?** Version 19 uses async webhook signature verification (`constructEventAsync`) which is handled internally by the plugin. No code changes required on your end!
        </Callout>
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { stripeClient } from "@better-auth/stripe/client"

        export const authClient = createAuthClient({
            // ... your existing config
            plugins: [
                stripeClient({
                    subscription: true //if you want to enable subscription management
                })
            ]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the tables manually.
    </Step>
    <Step>
        ### Set up Stripe webhooks

        Create a webhook endpoint in your Stripe dashboard pointing to:

        ```
        https://your-domain.com/api/auth/stripe/webhook
        ```
        `/api/auth` is the default path for the auth server.
        
        Make sure to select at least these events:
        - `checkout.session.completed`
        - `customer.subscription.created`
        - `customer.subscription.updated`
        - `customer.subscription.deleted`

        Save the webhook signing secret provided by Stripe and add it to your environment variables as `STRIPE_WEBHOOK_SECRET`.
    </Step>
</Steps>

## Usage

### Customer Management

You can use this plugin solely for customer management without enabling subscriptions. This is useful if you just want to link Stripe customers to your users.

When you set `createCustomerOnSignUp: true`, a Stripe customer is automatically created on signup and linked to the user in your database.
You can customize the customer creation process:

```ts title="auth.ts"
stripe({
    // ... other options
    createCustomerOnSignUp: true,
    onCustomerCreate: async ({ stripeCustomer, user }, ctx) => {
        // Do something with the newly created customer
        console.log(`Customer ${stripeCustomer.id} created for user ${user.id}`);
    },
    getCustomerCreateParams: async (user, ctx) => {
        // Customize the Stripe customer creation parameters
        return {
            metadata: {
                referralSource: user.metadata?.referralSource
            }
        };
    }
})
```

### Subscription Management

#### Defining Plans

You can define your subscription plans either statically or dynamically:

```ts title="auth.ts"
// Static plans
subscription: {
    enabled: true,
    plans: [
        {
            name: "basic", // the name of the plan, it'll be automatically lower cased when stored in the database
            priceId: "price_1234567890", // the price ID from stripe
            annualDiscountPriceId: "price_1234567890", // (optional) the price ID for annual billing with a discount
            limits: {
                projects: 5,
                storage: 10
            }
        },
        {
            name: "pro",
            priceId: "price_0987654321",
            limits: {
                projects: 20,
                storage: 50
            },
            freeTrial: {
                days: 14,
            }
        }
    ]
}

// Dynamic plans (fetched from database or API)
subscription: {
    enabled: true,
    plans: async () => {
        const plans = await db.query("SELECT * FROM plans");
        return plans.map(plan => ({
            name: plan.name,
            priceId: plan.stripe_price_id,
            limits: JSON.parse(plan.limits)
        }));
    }
}
```

see [plan configuration](#plan-configuration) for more.

#### Creating a Subscription

To create a subscription, use the `subscription.upgrade` method:

<APIMethod
  path="/subscription/upgrade"
  method="POST"
  requireSession
>
```ts
type upgradeSubscription = {
    /**
     * The name of the plan to upgrade to.
     */
    plan: string = "pro"
    /**
     * Whether to upgrade to an annual plan.
     */
    annual?: boolean = true
    /**
     * Reference id of the subscription. Defaults based on customerType.
     */
    referenceId?: string = "123"
    /**
     * The id of the subscription to upgrade.
     */
    subscriptionId?: string = "sub_123"
    /**
     * Additional metadata to store with the subscription.
     */
    metadata?: Record<string, any>
    /**
     * The type of customer for billing. (Default: "user")
     */
    customerType?: "user" | "organization"
    /**
     * Number of seats to upgrade to (if applicable).
     */
    seats?: number = 1
    /**
     * The IETF language tag of the locale Checkout is displayed in.
     * If not provided or set to `auto`, the browser's locale is used.
     */
    locale?: string
    /**
     * The URL to which Stripe should send customers when payment or setup is complete.
     */
    successUrl: string
    /**
     * If set, checkout shows a back button and customers will be directed here if they cancel payment.
     */
    cancelUrl: string
    /**
     * The URL to return to from the Billing Portal (used when upgrading existing subscriptions)
     */
    returnUrl?: string
    /**
     * Disable redirect after successful subscription.
     */
    disableRedirect: boolean = false
    /**
     * Schedule the plan change at the end of the current billing period
     * instead of applying it immediately.
     */
    scheduleAtPeriodEnd?: boolean = false
}
```
</APIMethod>

**Simple Example:**

```ts title="client.ts"
await authClient.subscription.upgrade({
    plan: "pro",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
    annual: true, // Optional: upgrade to an annual plan
    referenceId: "org_123", // Optional: defaults based on customerType
    seats: 5, // Optional: for team plans
    locale: "en" // Optional: display checkout in English
});
```

This will create a Checkout Session and redirect the user to the Stripe Checkout page.

<Callout type="info">
The plugin only supports one active or trialing subscription per reference ID (user or organization) at a time. Multiple concurrent subscriptions for the same reference ID are not supported.

If the user already has an active subscription, you **must** provide the `subscriptionId` parameter when upgrading. Otherwise, a new subscription may be created alongside the existing one, resulting in duplicate billing.
</Callout>

> **Important:** The `successUrl` parameter will be internally modified to handle race conditions between checkout completion and webhook processing. The plugin creates an intermediate redirect that ensures subscription status is properly updated before redirecting to your success page.

```ts
const { error } = await authClient.subscription.upgrade({
    plan: "pro",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
});
if(error) {
    alert(error.message);
}
```

#### Switching Plans

To switch a subscription to a different plan, use the `subscription.upgrade` method:
```ts title="client.ts"
await authClient.subscription.upgrade({
    plan: "pro",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
    subscriptionId: "sub_123", // the Stripe subscription ID of the user's current plan
});
```
This ensures that the user only pays for the new plan, and not both.

#### Scheduling Plan Changes at Period End

By default, plan changes take effect immediately with prorated billing. You may want to defer the change to the end of the current billing period so the user can continue using their current plan until it expires:

```ts title="client.ts"
await authClient.subscription.upgrade({
    plan: "pro",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
    returnUrl: "/billing",
    scheduleAtPeriodEnd: true, // [!code highlight] Default: false
});
```

This uses the [Stripe Subscription Schedules API](https://docs.stripe.com/billing/subscriptions/subscription-schedules) to create a two-phase schedule: the current plan continues until the billing period ends, then the new plan starts automatically with no proration.

<Callout type="info">
When `scheduleAtPeriodEnd` is `true`:
- The subscription plan is **not changed** until the billing period ends — only `stripeScheduleId` is stored so clients can detect the pending change
- No redirect to Stripe Checkout or Billing Portal occurs, the change is applied server-side
- At the end of the billing period, Stripe fires a `customer.subscription.updated` webhook which updates the subscription record automatically
- If a new upgrade or schedule is requested before the period ends, the existing pending schedule is released first
</Callout>

#### Listing Active Subscriptions

To get the user's active subscriptions:

<APIMethod
  path="/subscription/list"
  method="GET"
  requireSession
  resultVariable="subscriptions"
>
```ts
type listActiveSubscriptions = {
    /**
     * Reference id of the subscription to list.
     */
    referenceId?: string = '123'
    /**
     * The type of customer for billing. (Default: "user")
     */
    customerType?: "user" | "organization"
}

// get the active subscription
const activeSubscription = subscriptions.find(
    sub => sub.status === "active" || sub.status === "trialing"
);

// Check subscription limits
const projectLimit = subscriptions?.limits?.projects || 0;
```
</APIMethod>

Make sure to provide `authorizeReference` in your plugin config to authorize the reference ID

```ts title="auth.ts"
stripe({
    // ... other options
    subscription: {
        // ... other subscription options
        authorizeReference: async ({ user, session, referenceId, action }) => {
            if(action === "list-subscription") {
                const org = await db.member.findFirst({
                    where: {
                        organizationId: referenceId,
                        userId: user.id
                    }   
                });
                return org?.role === "owner"
            }
            // Check if the user has permission to list subscriptions for this reference
            return true;
        }
    }
})
```
#### Canceling a Subscription

To cancel a subscription:

<APIMethod
  path="/subscription/cancel"
  method="POST"
  requireSession
>
```ts
type cancelSubscription = {
    /**
     * Reference id of the subscription to cancel. Defaults based on customerType.
     */
    referenceId?: string = 'org_123'
    /**
     * The type of customer for billing. (Default: "user")
     */
    customerType?: "user" | "organization"
    /**
     * The id of the subscription to cancel.
     */
    subscriptionId?: string = 'sub_123'
    /**
     * URL to take customers to when they click on the billing portal's link to return to your website.
     */
    returnUrl: string = '/account'
}
```
</APIMethod>

This will redirect the user to the Stripe Billing Portal where they can cancel their subscription.

<Callout type="info">
**Understanding Cancellation States**

Stripe supports different types of cancellation, and the plugin tracks all of them:

| Field               | Description                                                                                                                      |
|---------------------|----------------------------------------------------------------------------------------------------------------------------------|
| `cancelAtPeriodEnd` | Whether this subscription will (if status=active) or did (if status=canceled) cancel at the end of the current billing period.   |
| `cancelAt`          | If the subscription is scheduled to be canceled, this is the time at which the cancellation will take effect.                    |
| `canceledAt`        | If the subscription has been canceled, this is the time when it was canceled.                                                    |
| `endedAt`           | If the subscription has ended, the date the subscription ended.                                                                  |
| `status`            | Changes to "canceled" only after the subscription has actually ended.                                                            |
</Callout>

#### Restoring a Subscription

> <small className='font-normal'>**Note:** This only works for subscriptions that are still active but have a pending cancellation or a scheduled plan change. It cannot restore subscriptions that have already ended (`status: "canceled"` with `endedAt` set).</small>

If a user changes their mind after canceling a subscription or scheduling a plan change, you can restore the subscription:


<APIMethod
  path="/subscription/restore"
  method="POST"
  requireSession
>
```ts
type restoreSubscription = {
    /**
     * Reference id of the subscription to restore. Defaults based on customerType.
     */
    referenceId?: string = '123'
    /**
     * The type of customer for billing. (Default: "user")
     */
    customerType?: "user" | "organization"
    /**
     * The id of the subscription to restore.
     */
    subscriptionId?: string = 'sub_123'
}
```
</APIMethod>

<Callout type="info">
This endpoint handles two cases:

- **Pending cancellation**: Sets `cancelAtPeriodEnd` to `false` and clears `cancelAt` / `canceledAt`, so the subscription continues to renew.
- **Pending plan change** (via `scheduleAtPeriodEnd`): Releases the Stripe subscription schedule and clears `stripeScheduleId`, so the current plan remains unchanged.
</Callout>


#### Creating Billing Portal Sessions

To create a [Stripe billing portal session](https://docs.stripe.com/api/customer_portal/sessions/create) where customers can manage their subscriptions, update payment methods, and view billing history:

<APIMethod
  path="/subscription/billing-portal"
  method="POST"
  requireSession
>
```ts
type createBillingPortal = {
    /**
    * The IETF language tag of the locale Customer Portal is displayed in.
    * If not provided or set to `auto`, the browser's locale is used.
    */
    locale?: string
    /**
     * Reference id of the subscription.
     */
    referenceId?: string = "123"
    /**
     * The type of customer for billing. (Default: "user")
     */
    customerType?: "user" | "organization"
    /**
     * Return URL to redirect back after exiting the billing portal.
     */
    returnUrl?: string
    /**
     * Disable the automatic redirect to the billing page.
     * @default false
     */
    disableRedirect?: boolean = false
}
```
</APIMethod>
<Callout type="info" >
For supported locales, see the [IETF language tag documentation](https://docs.stripe.com/js/appendix/supported_locales).
</Callout>
        
This endpoint creates a Stripe billing portal session and returns a URL in the response as `data.url`. You can redirect users to this URL to allow them to manage their subscription, payment methods, and billing history.

### Reference System

By default, subscriptions are associated with the user ID. However, you can use a custom reference ID to associate subscriptions with other entities, such as organizations:

```ts title="client.ts"
// Create a subscription for an organization
await authClient.subscription.upgrade({
    plan: "pro",
    referenceId: "org_123456",
    successUrl: "/dashboard",
    cancelUrl: "/pricing",
    seats: 5 // Number of seats for team plans
});

// List subscriptions for an organization
const { data: subscriptions } = await authClient.subscription.list({
    query: {
        referenceId: "org_123456"
    }
});
```

#### Team Subscriptions with Seats

For team or organization plans, you can specify the number of seats:

```ts
await authClient.subscription.upgrade({
    plan: "team",
    referenceId: "org_123456",
    seats: 10, // 10 team members
    successUrl: "/org/billing/success",
    cancelUrl: "/org/billing"
});
```

The `seats` parameter is passed to Stripe as the quantity for the subscription item. You can use this value in your application logic to limit the number of members in a team or organization.

To authorize reference IDs, implement the `authorizeReference` function:

```ts title="auth.ts"
subscription: {
    // ... other options
    authorizeReference: async ({ user, session, referenceId, action }) => {
        // Check if the user has permission to manage subscriptions for this reference
        if (action === "upgrade-subscription" || action === "cancel-subscription" || action === "restore-subscription") {
            const org = await db.member.findFirst({
                where: {
                    organizationId: referenceId,
                    userId: user.id
                }   
            });
            return org?.role === "owner"
        }
        return true;
    }
}
```

### Webhook Handling

The plugin automatically handles common webhook events:

- `checkout.session.completed`: Updates subscription status after checkout
- `customer.subscription.created`: Creates a subscription when created outside the checkout flow
- `customer.subscription.updated`: Updates subscription details when changed
- `customer.subscription.deleted`: Marks subscription as canceled

You can also handle custom events:

```ts title="auth.ts"
stripe({
    // ... other options
    onEvent: async (event) => {
        // Handle any Stripe event
        switch (event.type) {
            case "invoice.paid":
                // Handle paid invoice
                break;
            case "payment_intent.succeeded":
                // Handle successful payment
                break;
        }
    }
})
```

### Subscription Lifecycle Hooks

You can hook into various subscription lifecycle events:

```ts title="auth.ts"
subscription: {
    // ... other options
    onSubscriptionComplete: async ({ event, subscription, stripeSubscription, plan }) => {
        // Called when a subscription is successfully created via checkout
        await sendWelcomeEmail(subscription.referenceId, plan.name);
    },
    onSubscriptionCreated: async ({ event, subscription, stripeSubscription, plan }) => {
        // Called when a subscription is created outside the checkout flow (e.g. Stripe dashboard)
        await sendSubscriptionCreatedEmail(subscription.referenceId, plan.name);
    },
    onSubscriptionUpdate: async ({ event, subscription }) => {
        // Called when a subscription is updated
        console.log(`Subscription ${subscription.id} updated`);
    },
    onSubscriptionCancel: async ({ event, subscription, stripeSubscription, cancellationDetails }) => {
        // Called when a subscription is canceled
        await sendCancellationEmail(subscription.referenceId);
    },
    onSubscriptionDeleted: async ({ event, subscription, stripeSubscription }) => {
        // Called when a subscription is deleted
        console.log(`Subscription ${subscription.id} deleted`);
    }
}
```

### Trial Periods

You can configure trial periods for your plans:

```ts title="auth.ts"
{
    name: "pro",
    priceId: "price_0987654321",
    freeTrial: {
        days: 14,
        onTrialStart: async (subscription) => {
            // Called when a trial starts
            await sendTrialStartEmail(subscription.referenceId);
        },
        onTrialEnd: async ({ subscription }, ctx) => {
            // Called when a trial ends
            await sendTrialEndEmail(subscription.referenceId);
        },
        onTrialExpired: async (subscription, ctx) => {
            // Called when a trial expires without conversion
            await sendTrialExpiredEmail(subscription.referenceId);
        }
    }
}
```

## Schema

The Stripe plugin adds the following tables to your database:


### User

Table Name: `user`

<DatabaseTable
  fields={[
    { 
      name: "stripeCustomerId", 
      type: "string", 
      description: "The Stripe customer ID",
      isOptional: true
    },
  ]}
/>

### Organization

Table Name: `organization` <small className='text-xs'>(only when `organization.enabled` is `true`)</small>

<DatabaseTable
  fields={[
    {
      name: "stripeCustomerId",
      type: "string",
      description: "The Stripe customer ID for the organization",
      isOptional: true
    },
  ]}
/>

### Subscription

Table Name: `subscription`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Unique identifier for each subscription",
      isPrimaryKey: true
    },
    { 
      name: "plan", 
      type: "string", 
      description: "The name of the subscription plan" 
    },
    { 
      name: "referenceId", 
      type: "string", 
      description: "The ID this subscription is associated with (user ID by default). This should NOT be a unique field in your database, as it must allow users to resubscribe after a cancellation.",
      isUnique: false
    },
    { 
      name: "stripeCustomerId", 
      type: "string", 
      description: "The Stripe customer ID",
      isOptional: true
    },
    { 
      name: "stripeSubscriptionId", 
      type: "string", 
      description: "The Stripe subscription ID",
      isOptional: true
    },
    { 
      name: "status", 
      type: "string", 
      description: "The status of the subscription (active, canceled, etc.)",
      defaultValue: "incomplete"
    },
    { 
      name: "periodStart", 
      type: "Date", 
      description: "Start date of the current billing period",
      isOptional: true
    },
    { 
      name: "periodEnd", 
      type: "Date", 
      description: "End date of the current billing period",
      isOptional: true
    },
    { 
      name: "cancelAtPeriodEnd", 
      type: "boolean", 
      description: "Whether the subscription will be canceled at the end of the period",
      defaultValue: false,
      isOptional: true
    },
    { 
      name: "cancelAt", 
      type: "Date", 
      description: "If the subscription is scheduled to be canceled, this is the time at which the cancellation will take effect",
      isOptional: true
    },
    { 
      name: "canceledAt", 
      type: "Date", 
      description: "If the subscription has been canceled, this is the time when the cancellation was requested. Note: If the subscription was canceled with cancelAtPeriodEnd, this reflects the cancellation request time, not when the subscription actually ends",
      isOptional: true
    },
    { 
      name: "endedAt", 
      type: "Date", 
      description: "If the subscription has ended, this is the date the subscription ended",
      isOptional: true
    },
    { 
      name: "seats", 
      type: "number", 
      description: "Number of seats for team plans",
      isOptional: true
    },
    { 
      name: "trialStart", 
      type: "Date", 
      description: "Start date of the trial period",
      isOptional: true
    },
    {
      name: "trialEnd",
      type: "Date",
      description: "End date of the trial period",
      isOptional: true
    },
    {
      name: "billingInterval",
      type: "string",
      description: "The billing interval of the subscription (e.g. 'month', 'year')",
      isOptional: true
    },
    {
      name: "stripeScheduleId",
      type: "string",
      description: "Stripe Subscription Schedule ID, present when a scheduled plan change is pending",
      isOptional: true
    }
  ]}
/>

### Customizing the Schema

To change the schema table names or fields, you can pass a `schema` option to the Stripe plugin:

```ts title="auth.ts"
stripe({
    // ... other options
    schema: {
        subscription: {
            modelName: "stripeSubscriptions", // map the subscription table to stripeSubscriptions
            fields: {
                plan: "planName" // map the plan field to planName
            }
        }
    }
})
```

## Options

| Option                    | Type       | Description                                                                                   |
| ------------------------- | ---------- | --------------------------------------------------------------------------------------------- |
| `stripeClient`            | `Stripe`   | The Stripe client instance. **Required.**                                                     |
| `stripeWebhookSecret`     | `string`   | The webhook signing secret from Stripe. **Required.**                                         |
| `createCustomerOnSignUp`  | `boolean`  | Whether to automatically create a Stripe customer when a user signs up. Default: `false`.     |
| `onCustomerCreate`        | `function` | Callback called after a customer is created. Receives `{ stripeCustomer, user }` and context. |
| `getCustomerCreateParams` | `function` | Customize Stripe customer creation parameters. Receives `user` and context.                   |
| `onEvent`                 | `function` | Callback called for any Stripe webhook event. Receives `Stripe.Event`.                        |
| `subscription`            | `object`   | Subscription configuration. See [below](#subscription-options).                               |
| `organization`            | `object`   | Enable Organization Customer support. See [below](#organization-options).                     |
| `schema`                  | `object`   | Customize the database schema for the Stripe plugin.                                          |

### Subscription Options

| Option                     | Type                         | Description                                                                                                            |
| -------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| `enabled`                  | `boolean`                    | Whether to enable subscription functionality. **Required.**                                                            |
| `plans`                    | `StripePlan[]` or `function` | An array of subscription plans or an async function that returns plans. **Required** if enabled.                       |
| `requireEmailVerification` | `boolean`                    | Whether to require email verification before allowing subscription upgrades. Default: `false`.                         |
| `authorizeReference`       | `function`                   | Authorize reference IDs. Receives `{ user, session, referenceId, action }` and context.                                |
| `getCheckoutSessionParams` | `function`                   | Customize Stripe Checkout session parameters. Receives `{ user, session, plan, subscription }`, request, and context.  |
| `onSubscriptionComplete`   | `function`                   | Called when a subscription is created via checkout. Receives `{ event, stripeSubscription, subscription, plan }` and context. |
| `onSubscriptionCreated`    | `function`                   | Called when a subscription is created outside checkout. Receives `{ event, stripeSubscription, subscription, plan }`.  |
| `onSubscriptionUpdate`     | `function`                   | Called when a subscription is updated. Receives `{ event, subscription }`.                                             |
| `onSubscriptionCancel`     | `function`                   | Called when a subscription is canceled. Receives `{ event, subscription, stripeSubscription, cancellationDetails }`.   |
| `onSubscriptionDeleted`    | `function`                   | Called when a subscription is deleted. Receives `{ event, stripeSubscription, subscription }`.                         |

#### Plan Configuration

| Option                    | Type       | Description                                                  |
| ------------------------- | ---------- | ------------------------------------------------------------ |
| `name`                    | `string`   | The name of the plan. **Required.**                          |
| `priceId`                 | `string`   | The Stripe price ID. **Required** unless using `lookupKey`.  |
| `lookupKey`               | `string`   | The Stripe price lookup key. Alternative to `priceId`.       |
| `annualDiscountPriceId`   | `string`   | A price ID for annual billing.                               |
| `annualDiscountLookupKey` | `string`   | The Stripe price lookup key for annual billing.              |
| `limits`                  | `object`   | Limits for plan (e.g. `{ projects: 10, storage: 5 }`).       |
| `group`                   | `string`   | A group name for categorizing plans.                         |
| `seatPriceId`             | `string`   | Per-seat billing price ID. Requires the `organization` plugin. |
| `lineItems`               | `LineItem[]` | Additional line items to include in the checkout session.   |
| `freeTrial`               | `object`   | Trial configuration. See [below](#free-trial-configuration). |

<Callout type="info">
Stripe does not support [mixed-interval subscriptions](https://docs.stripe.com/billing/subscriptions/mixed-interval) via Checkout Sessions. All line items in a checkout should use the **same billing interval** (e.g. all monthly or all yearly). If intervals differ, the Stripe API will reject the request.
</Callout>

#### Free Trial Configuration

| Option           | Type       | Description                                                                              |
| ---------------- | ---------- | ---------------------------------------------------------------------------------------- |
| `days`           | `number`   | Number of trial days. **Required.**                                                      |
| `onTrialStart`   | `function` | Called when a trial starts. Receives `subscription`.                                     |
| `onTrialEnd`     | `function` | Called when a trial ends. Receives `{ subscription }` and context.                       |
| `onTrialExpired` | `function` | Called when a trial expires without conversion. Receives `subscription` and context.     |

### Organization Options

| Option                    | Type       | Description                                                                                                              |
| ------------------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------ |
| `enabled`                 | `boolean`  | Enable Organization Customer support. **Required.**                                                                      |
| `getCustomerCreateParams` | `function` | Customize Stripe customer creation parameters for organizations. Receives `organization` and context.                   |
| `onCustomerCreate`        | `function` | Called after an organization customer is created. Receives `{ stripeCustomer, organization }` and context.              |

## Advanced Usage

### Using with Organizations

The Stripe plugin integrates with the [organization plugin](/docs/plugins/organization) to enable organizations as Stripe Customers. Instead of individual users, organizations become the billing entity for subscriptions. This is useful for B2B services where billing is tied to the organization rather than individual user.

<Callout type="info">
**When Organization Customer is enabled:**

- A Stripe Customer is automatically created when an organization first subscribes
- Organization name changes are synced to the Stripe Customer
- Organizations with active subscriptions cannot be deleted
</Callout>

#### Enabling Organization Customer

To enable Organization Customer, set `organization.enabled` to `true` and ensure the organization plugin is installed:

```ts title="auth.ts"
plugins: [
    organization(),
    stripe({
        // ... other options
        subscription: {
            enabled: true,
            plans: [...],
        },
        organization: { // [!code highlight]
            enabled: true // [!code highlight]
        } // [!code highlight]
    })
]
```

#### Creating Organization Subscriptions

Even with Organization Customer enabled, user subscriptions remain available and are the default. To use the organization as the billing entity, pass `customerType: "organization"`:

```ts title="client.ts"
await authClient.subscription.upgrade({
    plan: "team",
    referenceId: activeOrg.id,
    customerType: "organization", // [!code highlight]
    seats: 10,
    successUrl: "/org/billing/success",
    cancelUrl: "/org/billing"
});
```

#### Authorization

Make sure to implement the `authorizeReference` function to verify that the user has permission to manage subscriptions for the organization:

```ts title="auth.ts"
subscription: {
    // ... other subscription options
    authorizeReference: async ({ user, referenceId, action }) => {
        const member = await db.members.findFirst({
            where: {
                userId: user.id,
                organizationId: referenceId
            }
        });

        return member?.role === "owner" || member?.role === "admin";
    }
}
```

#### Organization Billing Email

Unlike users, organization billing email is not automatically synced because organization itself doesn't have a unique email. Organizations often use a dedicated billing email separate from user accounts.
To change the billing email after checkout, update it through the Stripe Dashboard or implement custom logic using `stripeClient`:

```ts
await stripeClient.customers.update(organization.stripeCustomerId, {
    email: "billing@company.com"
});
```

### Custom Checkout Session Parameters

You can customize the Stripe Checkout session with additional parameters:

```ts title="auth.ts"
getCheckoutSessionParams: async ({ user, session, plan, subscription }, ctx) => {
    return {
        params: {
            allow_promotion_codes: true,
            tax_id_collection: {
                enabled: true
            },
            billing_address_collection: "required",
            custom_text: {
                submit: {
                    message: "We'll start your subscription right away"
                }
            },
            metadata: {
                planType: "business",
                referralCode: user.metadata?.referralCode
            }
        },
        options: {
            idempotencyKey: `sub_${user.id}_${plan.name}_${Date.now()}`
        }
    };
}
```

### Tax Collection

To collect tax IDs from the customer, set `tax_id_collection` to true:

```ts title="auth.ts"
subscription: {
    // ... other options
    getCheckoutSessionParams: async ({ user, session, plan, subscription }, ctx) => {
        return {
            params: {
                tax_id_collection: {
                    enabled: true
                }
            }
        };
    }
}
```

### Automatic Tax Calculation

To enable automatic tax calculation using the customer's location, set `automatic_tax` to true. Enabling this parameter causes Checkout to collect any billing address information necessary for tax calculation. You need to have tax registration setup and configured in the Stripe dashboard first for this to work.

```ts title="auth.ts"
subscription: {
    // ... other options
    getCheckoutSessionParams: async ({ user, session, plan, subscription }, ctx) => {
        return {
            params: {
                automatic_tax: {
                    enabled: true
                }
            }
        };
    }
}
```

### Trial Period Management

The Stripe plugin automatically prevents users from getting multiple free trials. Once a user has used a trial period (regardless of which plan), they will not be eligible for additional trials on any plan.

**How it works:**
- The system tracks trial usage across all plans for each user
- When a user subscribes to a plan with a trial, the system checks their subscription history
- If the user has ever had a trial (indicated by `trialStart`/`trialEnd` fields or `trialing` status), no new trial will be offered
- This prevents abuse where users cancel subscriptions and resubscribe to get multiple free trials

**Example scenario:**
1. User subscribes to "Starter" plan with 7-day trial
2. User cancels the subscription after the trial
3. User tries to subscribe to "Premium" plan - no trial will be offered
4. User will be charged immediately for the Premium plan

This behavior is automatic and requires no additional configuration. The trial eligibility is determined at the time of subscription creation and cannot be overridden through configuration.

## Troubleshooting

### Webhook Issues

If webhooks aren't being processed correctly:

1. Check that your webhook URL is correctly configured in the Stripe dashboard
2. Verify that the webhook signing secret is correct
3. Ensure you've selected all the necessary events in the Stripe dashboard
4. Check your server logs for any errors during webhook processing

### Subscription Status Issues

If subscription statuses aren't updating correctly:

1. Make sure the webhook events are being received and processed
2. Check that the `stripeCustomerId` and `stripeSubscriptionId` fields are correctly populated
3. Verify that the reference IDs match between your application and Stripe

### Testing Webhooks Locally

For local development, you can use the Stripe CLI to forward webhooks to your local environment:

```bash
stripe listen --forward-to localhost:3000/api/auth/stripe/webhook
```

This will provide you with a webhook signing secret that you can use in your local environment.
---
title: Admin
description: Admin plugin for Better Auth
---

The Admin plugin provides a set of administrative functions for user management in your application. It allows administrators to perform various operations such as creating users, managing user roles, banning/unbanning users, impersonating users, and more.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To use the Admin plugin, add it to your auth config.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { admin } from "better-auth/plugins" // [!code highlight]

    export const auth = betterAuth({
        // ... other config options
        plugins: [
            admin() // [!code highlight]
        ]
    })
    ```

  </Step>

    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

  <Step>
    ### Add the client plugin

    Next, include the admin client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { adminClient } from "better-auth/client/plugins"  // [!code highlight]

    export const authClient = createAuthClient({
        plugins: [
            adminClient()  // [!code highlight]
        ]
    })
    ```

  </Step>
</Steps>

## Usage

Before performing any admin operations, the user must be authenticated with an admin account. An admin is any user assigned the `admin` role or any user whose ID is included in the `adminUserIds` option.

### Create User

Allows an admin to create a new user.

<APIMethod
  path="/admin/create-user"
  method="POST"
  resultVariable="newUser"
>
```ts
type createUser = {
    /**
     * The email of the user. 
     */
    email: string = "user@example.com"
    /**
     * The password of the user. 
     */
    password: string = "some-secure-password"
    /**
     * The name of the user. 
     */
    name: string = "James Smith"
    /**
     * A string or array of strings representing the roles to apply to the new user. 
     */
    role?: string | string[] = "user"
    /**
     * Extra fields for the user. Including custom additional fields. 
     */
    data?: Record<string, any> = { customField: "customValue" }
}
```
</APIMethod>

### List Users

Allows an admin to list all users in the database.

<APIMethod
  path="/admin/list-users"
  method="GET"
  requireSession
  note={"All properties are optional to configure. By default, 100 rows are returned, you can configure this by the `limit` property."}
  resultVariable={"users"}
>
```ts
type listUsers = {
  /**
   * The value to search for. 
   */
  searchValue?: string = "some name"
  /**
   * The field to search in, defaults to email. Can be `email` or `name`. 
   */
  searchField?: "email" | "name" = "name"
  /**
   * The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. 
   */
  searchOperator?: "contains" | "starts_with" | "ends_with" = "contains"
  /**
   * The number of users to return. Defaults to 100.
   */
  limit?: string | number = 100
  /**
   * The offset to start from. 
   */
  offset?: string | number = 100
  /**
   * The field to sort by. 
   */
  sortBy?: string = "name"
  /**
   * The direction to sort by. 
   */
  sortDirection?: "asc" | "desc" = "desc"
  /**
   * The field to filter by. 
   */
  filterField?: string = "email"
  /**
   * The value to filter by. 
   */
  filterValue?: string | number | boolean | string[] | number[] = "hello@example.com"
  /**
   * The operator to use for the filter.
   */
  filterOperator?: "eq" | "ne" | "lt" | "lte" | "gt" | "gte" | "in" | "not_in" | "contains" | "starts_with" | "ends_with" = "eq"
}
```
</APIMethod>


#### Query Filtering

The `listUsers` function supports various filter operators including `eq`, `contains`, `starts_with`, and `ends_with`.

#### Pagination

The `listUsers` function supports pagination by returning metadata alongside the user list. The response includes the following fields:

```ts
{
  users: User[],   // Array of returned users
  total: number,   // Total number of users after filters and search queries
  limit: number | undefined,   // The limit provided in the query
  offset: number | undefined   // The offset provided in the query
}
```

##### How to Implement Pagination

To paginate results, use the `total`, `limit`, and `offset` values to calculate:

- **Total pages:** `Math.ceil(total / limit)`
- **Current page:** `(offset / limit) + 1`
- **Next page offset:** `Math.min(offset + limit, (total - 1))` – The value to use as `offset` for the next page, ensuring it does not exceed the total number of pages.
- **Previous page offset:** `Math.max(0, offset - limit)` – The value to use as `offset` for the previous page (ensuring it doesn’t go below zero).

##### Example Usage

Fetching the second page with 10 users per page:

```ts
import { authClient } from "@/lib/auth-client";

const pageSize = 10;
const currentPage = 2;

const users = await authClient.admin.listUsers({
    query: {
        limit: pageSize,
        offset: (currentPage - 1) * pageSize
    }
});

const totalUsers = users.total;
const totalPages = Math.ceil(totalUsers / pageSize)
```

### Get User

Fetches a user's information using an id.

<APIMethod
  path="/admin/get-user"
  method="GET"
  requireSession
>
```ts
type getUser = {
  /**
  * The id of the user you want to fetch.
  */
  id: string = "user-id"
}
```
</APIMethod>

#### Returns
On success, `data` contains the user object. On failure, `error` is populated by `code`, `message`, `status`, and `statusText`.
```ts
type GetUserResponse = {
  data: User | null;
  error: null | {
    message: string;
    status: number; //HTTP status code
    statusText: string;
    code: string;
}
```

### Set User Role

Changes the role of a user.

<APIMethod
  path="/admin/set-role"
  method="POST"
  requireSession
>
```ts
type setRole = {
    /**
     * The user id which you want to set the role for.
     */
    userId?: string = "user-id"
    /**
     * The role to set, this can be a string or an array of strings. 
     */
    role: string | string[] = "admin"
}
```
</APIMethod>

### Set User Password

Changes the password of a user.

<APIMethod
  path="/admin/set-user-password"
  method="POST"
  requireSession
>
```ts
type setUserPassword = {
    /**
     * The new password. 
     */
    newPassword: string = 'new-password'
    /**
     * The user id which you want to set the password for.
     */
    userId: string = 'user-id'
}
```
</APIMethod>

### Update user

Update a user's details.

<APIMethod
  path="/admin/update-user"
  method="POST"
  requireSession
>
```ts
type adminUpdateUser = {
    /**
     * The user id which you want to update.
     */
    userId: string = "user-id"
    /**
     * The data to update.
     */
    data: Record<string, any> = { name: "John Doe" }
}
```
</APIMethod>

### Ban User

Bans a user, preventing them from signing in and revokes all of their existing sessions.


<APIMethod
  path="/admin/ban-user"
  method="POST"
  requireSession
  noResult
>
```ts
type banUser = {
    /**
     * The user id which you want to ban.
     */
    userId: string = "user-id"
    /**
     * The reason for the ban. 
     */
    banReason?: string = "Spamming"
    /**
     * The number of seconds until the ban expires. If not provided, the ban will never expire. 
     */
    banExpiresIn?: number = 60 * 60 * 24 * 7
}
```
</APIMethod>

### Unban User

Removes the ban from a user, allowing them to sign in again.

<APIMethod
  path="/admin/unban-user"
  method="POST"
  requireSession
  noResult
>
```ts
type unbanUser = {
    /**
     * The user id which you want to unban.
     */
    userId: string = "user-id"
}
```
</APIMethod>

### List User Sessions

Lists all sessions for a user.

<APIMethod
  path="/admin/list-user-sessions"
  method="POST"
  requireSession
>
```ts
type listUserSessions = {
    /**
     * The user id. 
     */
    userId: string = "user-id"
}
```
</APIMethod>

### Revoke User Session

Revokes a specific session for a user.


<APIMethod
  path="/admin/revoke-user-session"
  method="POST"
  requireSession
>
```ts
type revokeUserSession = {
    /**
     * The session token which you want to revoke. 
     */
    sessionToken: string = "session_token_here"
}
```
</APIMethod>

### Revoke All Sessions for a User

Revokes all sessions for a user.

<APIMethod
  path="/admin/revoke-user-sessions"
  method="POST"
  requireSession
>
```ts
type revokeUserSessions = {
    /**
     * The user id which you want to revoke all sessions for. 
     */
    userId: string = "user-id"
}
```
</APIMethod>

### Impersonate User

This feature allows an admin to create a session that mimics the specified user. The session will remain active until either the browser session ends or it reaches 1 hour. You can change this duration by setting the `impersonationSessionDuration` option.

<APIMethod
  path="/admin/impersonate-user"
  method="POST"
  requireSession
>
```ts
type impersonateUser = {
    /**
     * The user id which you want to impersonate. 
     */
    userId: string = "user-id"
}
```
</APIMethod>

### Stop Impersonating User

To stop impersonating a user and continue with the admin account, you can use `stopImpersonating`

<APIMethod path="/admin/stop-impersonating" method="POST" noResult requireSession>
```ts
type stopImpersonating = {
}
```
</APIMethod>

### Remove User

Hard deletes a user from the database.

<APIMethod
  path="/admin/remove-user"
  method="POST"
  requireSession
  resultVariable="deletedUser"
>
```ts
type removeUser = {
    /**
     * The user id which you want to remove. 
     */
    userId: string = "user-id"
}
```
</APIMethod>

## Access Control

The admin plugin offers a highly flexible access control system, allowing you to manage user permissions based on their role. You can define custom permission sets to fit your needs.

### Roles

By default, there are two roles:

`admin`: Users with the admin role have full control over other users.

`user`: Users with the user role have no control over other users.

<Callout>
  A user can have multiple roles. Multiple roles are stored as string separated by comma (",").
</Callout>

### Permissions

By default, there are two resources with up to six permissions.

**user**:
  `create` `list` `set-role` `ban` `impersonate` `delete` `set-password`

**session**:
  `list` `revoke` `delete`

Users with the admin role have full control over all the resources and actions. Users with the user role have no control over any of those actions.

### Custom Permissions

The plugin provides an easy way to define your own set of permissions for each role.

<Steps>
    <Step>
    #### Create Access Control

    You first need to create an access controller by calling the `createAccessControl` function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value.
    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    /**
     * make sure to use `as const` so typescript can infer the type correctly
     */
    const statement = { // [!code highlight]
        project: ["create", "share", "update", "delete"], // [!code highlight]
    } as const; // [!code highlight]

    const ac = createAccessControl(statement); // [!code highlight]
    ```
    
    <Callout type="warning">
      To keep bundle sizes small, make sure to import from `better-auth/plugins/access` instead of `better-auth/plugins`.
    </Callout>
    </Step>

    <Step>
    #### Create Roles

    Once you have created the access controller you can create roles with the permissions you have defined.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";

    export const statement = {
        project: ["create", "share", "update", "delete"], // <-- Permissions available for created roles
    } as const;

    export const ac = createAccessControl(statement);

    export const user = ac.newRole({ // [!code highlight]
        project: ["create"], // [!code highlight]
    }); // [!code highlight]

   export const admin = ac.newRole({ // [!code highlight]
        project: ["create", "update"], // [!code highlight]
    }); // [!code highlight]

    export const myCustomRole = ac.newRole({ // [!code highlight]
        project: ["create", "update", "delete"], // [!code highlight]
        user: ["ban"], // [!code highlight]
    }); // [!code highlight]
    ```

      When you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import `defaultStatements` and merge it with your new statement, plus merge the roles' permissions set with the default roles.

    ```ts title="permissions.ts"
    import { createAccessControl } from "better-auth/plugins/access";
    import { defaultStatements, adminAc } from "better-auth/plugins/admin/access";

    const statement = {
        ...defaultStatements, // [!code highlight]
        project: ["create", "share", "update", "delete"],
    } as const;

    const ac = createAccessControl(statement);

    const admin = ac.newRole({
        project: ["create", "update"],
        ...adminAc.statements, // [!code highlight]
    });
    ```

    </Step>

    <Step>
        #### Pass Roles to the Plugin

        Once you have created the roles you can pass them to the admin plugin both on the client and the server.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { admin as adminPlugin } from "better-auth/plugins"
        import { ac, admin, user } from "@/auth/permissions"

        export const auth = betterAuth({
            plugins: [
                adminPlugin({
                    ac,
                    roles: {
                        admin,
                        user,
                        myCustomRole
                    }
                }),
            ],
        });
        ```

        You also need to pass the access controller and the roles to the client plugin.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { adminClient } from "better-auth/client/plugins"
        import { ac, admin, user, myCustomRole } from "@/auth/permissions"

        export const client = createAuthClient({
            plugins: [
                adminClient({
                    ac,
                    roles: {
                        admin,
                        user,
                        myCustomRole
                    }
                })
            ]
        })
        ```
    </Step>

</Steps>

### Access Control Usage

**Has Permission**:

To check a user's permissions, you can use the `hasPermission` function provided by the client.


<APIMethod path="/admin/has-permission" method="POST">
```ts
type userHasPermission = {
    /**
     * The user id which you want to check the permissions for. 
     */
    userId?: string = "user-id"
    /**
     * Check role permissions.
     * @serverOnly
     */
    role?: string = "admin"
    /**
     * Optionally check if a single permission is granted. Must use this, or permissions. 
     */
    permission?: Record<string, string[]> = { "project": ["create", "update"] } /* Must use this, or permissions */,
    /**
     * Optionally check if multiple permissions are granted. Must use this, or permission. 
     */
    permissions?: Record<string, string[]>
}
```
</APIMethod>

Example usage:

```ts
import { authClient } from "@/lib/auth-client";

const canCreateProject = await authClient.admin.hasPermission({
  permissions: {
    project: ["create"],
  },
});

// You can also check multiple resource permissions at the same time
const canCreateProjectAndCreateSale = await authClient.admin.hasPermission({
  permissions: {
    project: ["create"],
    sale: ["create"]
  },
});
```

If you want to check a user's permissions server-side, you can use the `userHasPermission` action provided by the `api` to check the user's permissions.



```ts title="permission.ts"
import { auth } from "@/lib/auth"

await auth.api.userHasPermission({
  body: {
    userId: 'id', //the user id
    permissions: {
      project: ["create"], // This must match the structure in your access control
    },
  },
});

// You can also just pass the role directly
await auth.api.userHasPermission({
  body: {
   role: "admin",
    permissions: {
      project: ["create"], // This must match the structure in your access control
    },
  },
});

// You can also check multiple resource permissions at the same time
await auth.api.userHasPermission({
  body: {
   role: "admin",
    permissions: {
      project: ["create"], // This must match the structure in your access control
      sale: ["create"]
    },
  },
});
```


**Check Role Permission**:

Use the `checkRolePermission` function on the client side to verify whether a given **role** has a specific **permission**. This is helpful after defining roles and their permissions, as it allows you to perform permission checks without needing to contact the server.

Note that this function does **not** check the permissions of the currently logged-in user directly. Instead, it checks what permissions are assigned to a specified role. The function is synchronous, so you don't need to use `await` when calling it.

```ts
import { authClient } from "@/lib/auth-client";

const canCreateProject = authClient.admin.checkRolePermission({
  permissions: {
    user: ["delete"],
  },
  role: "admin",
});

// You can also check multiple resource permissions at the same time
const canDeleteUserAndRevokeSession = authClient.admin.checkRolePermission({
  permissions: {
    user: ["delete"],
    session: ["revoke"]
  },
  role: "admin",
});
```

## Schema

This plugin adds the following fields to the `user` table:

<DatabaseTable
  fields={[
    {
      name: "role",
      type: "string",
      description:
        "The user's role. Defaults to `user`. Admins will have the `admin` role.",
      isOptional: true,
    },
    {
      name: "banned",
      type: "boolean",
      description: "Indicates whether the user is banned.",
      isOptional: true,
    },
    {
      name: "banReason",
      type: "string",
      description: "The reason for the user's ban.",
      isOptional: true,
    },
    {
      name: "banExpires",
      type: "date",
      description: "The date when the user's ban will expire.",
      isOptional: true,
    },
  ]}
/>

And adds one field in the `session` table:

<DatabaseTable
  fields={[
    {
      name: "impersonatedBy",
      type: "string",
      description: "The ID of the admin that is impersonating this session.",
      isOptional: true,
    },
  ]}
/>

## Options

### Default Role

The default role for a user. Defaults to `user`.

```ts title="auth.ts"
admin({
  defaultRole: "regular",
});
```
### Admin Roles

Specifies which roles are considered admin roles. Defaults to `["admin"]`. Custom roles (for example, `superadmin`) must be defined in custom access control.

```ts title="auth.ts"
admin({
  // Requires custom access control with `superadmin` defined in `roles`
  adminRoles: ["admin", "superadmin"],
});
```

<Callout type="warning">
  **Note:** The `adminRoles` option is **not required** when using custom access control (via `ac` and `roles`). When you define custom roles with specific permissions, those roles will have exactly the permissions you grant them through the access control system.  
  
  
  **Warning:** When **not** using custom access control, only `admin` and `user` exist as valid roles. Any role that isn't in the `adminRoles` list will **not** be able to perform admin operations.

</Callout>

### Admin userIds

You can pass an array of userIds that should be considered as admin. Default to `[]`

```ts title="auth.ts"
admin({
    adminUserIds: ["user_id_1", "user_id_2"]
})
```

If a user is in the `adminUserIds` list, they will be able to perform any admin operation.

### impersonationSessionDuration

The duration of the impersonation session in seconds. Defaults to 1 hour.

```ts title="auth.ts"
admin({
  impersonationSessionDuration: 60 * 60 * 24, // 1 day
});
```

### Default Ban Reason

The default ban reason for a user created by the admin. Defaults to `No reason`.

```ts title="auth.ts"
admin({
  defaultBanReason: "Spamming",
});
```

### Default Ban Expires In

The default ban expires in for a user created by the admin in seconds. Defaults to `undefined` (meaning the ban never expires).

```ts title="auth.ts"
admin({
  defaultBanExpiresIn: 60 * 60 * 24, // 1 day
});
```

### bannedUserMessage

The message to show when a banned user tries to sign in. Defaults to "You have been banned from this application. Please contact support if you believe this is an error."

```ts title="auth.ts"
admin({
  bannedUserMessage: "Custom banned user message",
});
```

### allowImpersonatingAdmins

Whether to allow impersonating other admin users. Defaults to `false`.

```ts title="auth.ts"
admin({
  allowImpersonatingAdmins: true,
});
```
---
title: Dub
description: Better Auth Plugin for Lead Tracking using Dub links and OAuth Linking
---

[Dub](https://dub.co/) is an open source modern link management platform for entrepreneurs, creators, and growth teams.

This plugins allows you to track leads when a user signs up using a Dub link. It also adds OAuth linking support to allow you to build integrations extending Dub's linking management infrastructure.

## Installation

<Steps>
    <Step>
        ### Install the plugin
        First, install the plugin:

        ```package-install
        @dub/better-auth
        ```
    </Step>
    <Step>
        ### Install the Dub SDK

        Next, install the Dub SDK on your server:

        ```package-install
        dub
        ```
    </Step>
    <Step>
        ### Configure the plugin

        Add the plugin to your auth config:

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { dubAnalytics } from "@dub/better-auth"
        import { dub } from "dub"

        export const auth = betterAuth({
            plugins: [
                dubAnalytics({
                    dubClient: new Dub()
                })
            ]
        })
        ```
    </Step>

</Steps>

## Usage

### Lead Tracking

By default, the plugin will track sign up events as leads. You can disable this by setting `disableLeadTracking` to `true`.

```ts
import { dubAnalytics } from "@dub/better-auth";
import { betterAuth } from "better-auth";
import { Dub } from "dub";

const dub = new Dub();

const betterAuth = betterAuth({
  plugins: [
    dubAnalytics({
      dubClient: dub,
      disableLeadTracking: true, // Disable lead tracking
    }),
  ],
});
```

### OAuth Linking

The plugin supports OAuth for account linking.

First, you need to setup OAuth app in Dub. Dub supports OAuth 2.0 authentication, which is recommended if you build integrations extending Dub’s functionality [Learn more about OAuth](https://dub.co/docs/integrations/quickstart#integrating-via-oauth-2-0-recommended).

Once you get the client ID and client secret, you can configure the plugin.

```ts
dubAnalytics({
  dubClient: dub,
  oauth: {
    clientId: "your-client-id",
    clientSecret: "your-client-secret",
  },
});
```

And in the client, you need to use the `dubAnalyticsClient` plugin.

```ts
import { createAuthClient } from "better-auth/client";
import { dubAnalyticsClient } from "@dub/better-auth/client";

const authClient = createAuthClient({
  plugins: [dubAnalyticsClient()],
});
```

To link account with Dub, you need to use the `dub.link`.

<APIMethod path="/dub/link" method="POST" requireSession>
```ts
type dubLink = {
  /**
   * URL to redirect to after linking
   * @clientOnly
  */
  callbackURL: string = "/dashboard"
}
```
</APIMethod>

## Options

You can pass the following options to the plugin:

### `dubClient`

The Dub client instance.

### `disableLeadTracking`

Disable lead tracking for sign up events.

### `leadEventName`

Event name for sign up leads.

### `customLeadTrack`

Custom lead track function.

### `oauth`

Dub OAuth configuration.

### `oauth.clientId`

Client ID for Dub OAuth.

### `oauth.clientSecret`

Client secret for Dub OAuth.

### `oauth.pkce`

Enable PKCE for Dub OAuth.
---
title: Autumn Billing
description: Better Auth Plugin for Autumn Billing
---

import { HomeIcon } from "lucide-react";
import { Accordion, Accordions } from "fumadocs-ui/components/accordion";

[Autumn](https://useautumn.com) is open source infrastructure to run SaaS pricing plans. It sits between your app and Stripe, and acts as the database for your customers' subscription status, usage metering and feature permissions.

<Callout>
  This plugin is maintained by the Autumn team. For bugs, issues or feature requests,
  please visit the [Autumn GitHub repo](https://github.com/useautumn/autumn).
</Callout>

<Card href="https://discord.gg/STqxY92zuS" title="Get help on Autumn's Discord">
  We're online to help you with any questions you have.
</Card>

## Features

- One function for all checkout, subscription and payment flows
- No webhooks required: query Autumn for the data you need
- Manages your application's free and paid plans
- Usage tracking for usage billing and periodic limits
- Custom plans and pricing changes through Autumn's dashboard


<Steps>
  <Step>
    ### Setup Autumn Account
    First, create your pricing plans in Autumn's [dashboard](https://app.useautumn.com), where you define what each plan and product gets access to and how it should be billed. In this example, we're handling the free and pro plans for an AI chatbot, which comes with a number of `messages` per month.
  </Step>
  <Step>
    ### Install Autumn SDK

    ```package-install
    autumn-js
    ```
    <Callout>
      If you're using a separate client and server setup, make sure to install the plugin in both parts of your project.
    </Callout>
  </Step>

  <Step>
    ### Add `AUTUMN_SECRET_KEY` to your environment variables

    You can find it in Autumn's dashboard under "[Developer](https://app.useautumn.com/sandbox/onboarding)".

    ```bash title=".env"
    AUTUMN_SECRET_KEY=am_sk_xxxxxxxxxx
    ```
  </Step>

  <Step>
    ### Add the Autumn plugin to your `auth` config

    <Tabs items={["User", "Organization", "User & Organization", "Custom"]}>
    <Tab value="User">

    ```ts title="auth.ts"
    import { autumn } from "autumn-js/better-auth";

    export const auth = betterAuth({
      // ...
      plugins: [autumn()],
    });
    ```

    </Tab>
    <Tab value="Organization">

    ```ts title="auth.ts"
    import { autumn } from "autumn-js/better-auth";
    import { organization } from "better-auth/plugins";

    export const auth = betterAuth({
      // ...
      plugins: [organization(), autumn({ customerScope: "organization" })],
    });
    ```

    </Tab>
    <Tab value="User & Organization">

    ```ts title="auth.ts"
    import { autumn } from "autumn-js/better-auth";
    import { organization } from "better-auth/plugins";

    export const auth = betterAuth({
      // ...
      plugins: [
        organization(),
        autumn({ customerScope: "user_and_organization" })
      ],
    });
    ```

    </Tab>
    <Tab value="Custom">

    ```ts title="auth.ts"
    import { autumn } from "autumn-js/better-auth";
    import { organization } from "better-auth/plugins";

    export const auth = betterAuth({
      // ...
      plugins: [
        organization(),
        autumn({
          identify: async ({ session, organization }) => {
            return {
              customerId: "your_customer_id",
              customerData: {
                name: "Customer Name",
                email: "customer@gmail.com",
              },
            };
          },
        }),
      ],
    });
    ```

    </Tab>
    </Tabs>

  <Callout>
    Autumn will auto-create your customers when they sign up, and assign them any
    default plans you created (eg your Free plan). You can choose who becomes a customer: individual users, organizations, both, or something custom like workspaces.
  </Callout>
  </Step>

  <Step>
      ### Add `<AutumnProvider />`

      Client side, wrap your application with the AutumnProvider component, and pass in the `baseUrl` that you define within better-auth's `authClient`.

      ```tsx title="app/layout.tsx"
      import { AutumnProvider } from "autumn-js/react";

      export default function RootLayout({
        children,
      }: {
        children: React.ReactNode;
      }) {
        return (
          <html>
            <body>
              {/* or meta.env.BETTER_AUTH_URL for vite */}
              <AutumnProvider betterAuthUrl={process.env.NEXT_PUBLIC_BETTER_AUTH_URL}>
                {children}
              </AutumnProvider>
            </body>
          </html>
        );
      }
      ```
  </Step>  
</Steps>

## Usage

### Handle payments

Call `attach` to redirect the customer to a Stripe checkout page when they want to purchase the Pro plan.

If their payment method is already on file, `AttachDialog` will open instead to let the customer confirm their new subscription or purchase, and handle the payment.

<Callout type="warn">
  {" "}
  Make sure you've pasted in your [Stripe test secret
  key](https://dashboard.stripe.com/test/apikeys) in the [Autumn
  dashboard](https://app.useautumn.com/integrations/stripe).
</Callout>

```tsx
import { useCustomer, AttachDialog } from "autumn-js/react";

export default function PurchaseButton() {
  const { attach } = useCustomer();

  return (
    <button
      onClick={async () => {
        await attach({
          productId: "pro",
          dialog: AttachDialog,
        });
      }}
    >
      Upgrade to Pro
    </button>
  );
}
```

The AttachDialog component can be used directly from the `autumn-js/react`
library (as shown in the example above), or downloaded as a [shadcn/ui component](https://docs.useautumn.com/quickstart/shadcn) to customize.

### Integrate Pricing Logic

Integrate your client and server pricing tiers logic with the following functions:

- `check` to see if the customer is `allowed` to send a message.
- `track` a usage event in Autumn (typically done server-side)
- `customer` to display any relevant billing data in your UI (subscriptions, feature balances)

Server-side, you can access Autumn's functions through the `auth` object.

<Tabs items={["Client", "Server"]}>
<Tab value="Client">

```jsx
import { useCustomer } from "autumn-js/react";

export default function SendChatMessage() {
  const { customer, allowed, refetch } = useCustomer();

  return (
    <>
      <button
        onClick={async () => {
          if (allowed({ featureId: "messages" })) {
            //... send chatbot message server-side, then
            await refetch(); // refetch customer usage data
            alert(
              "Remaining messages: " + customer?.features.messages?.balance
            );
          } else {
            alert("You're out of messages");
          }
        }}
      >
        Send Message
      </button>
    </>
  );
}
```

</Tab>
<Tab value="Server">

```typescript Server
import { auth } from "@/lib/auth";

// check on the backend if the customer can send a message
const { allowed } = await auth.api.check({
  headers: await headers(), // pass the request headers
  body: {
    featureId: "messages",
  },
});

// server-side function to send the message

// then track the usage
await auth.api.track({
  headers: await headers(),
  body: {
    featureId: "messages",
    value: 2,
  },
});
```

</Tab>
</Tabs>

### Additional Functions

#### openBillingPortal()

Opens a billing portal where the customer can update their payment method or cancel their plan.

```tsx
import { useCustomer } from "autumn-js/react";

export default function BillingSettings() {
  const { openBillingPortal } = useCustomer();

  return (
    <button
      onClick={async () => {
        await openBillingPortal({
          returnUrl: "/settings/billing",
        });
      }}
    >
      Manage Billing
    </button>
  );
}
```

#### cancel()

Cancel a product or subscription.

```tsx
import { useCustomer } from "autumn-js/react";

export default function CancelSubscription() {
  const { cancel } = useCustomer();

  return (
    <button
      onClick={async () => {
        await cancel({ productId: "pro" });
      }}
    >
      Cancel Subscription
    </button>
  );
}
```

#### Get invoice history

Pass in an `expand` param into `useCustomer` to get additional information. You can expand `invoices`, `trials_used`, `payment_method`, or `rewards`.

```tsx
import { useCustomer } from "autumn-js/react";

export default function CustomerProfile() {
  const { customer } = useCustomer({ expand: ["invoices"] });

  return (
    <div>
      <h2>Customer Profile</h2>
      <p>Name: {customer?.name}</p>
      <p>Email: {customer?.email}</p>
      <p>Balance: {customer?.features.chat_messages?.balance}</p>
    </div>
  );
}
```
---
title: Polar
description: Better Auth Plugin for Payment and Checkouts using Polar
---

[Polar](https://polar.sh) is a developer first payment infrastructure. Out of the box it provides a lot of developer first integrations for payments, checkouts and more. This plugin helps you integrate Polar with Better Auth to make your auth + payments flow seamless.

<Callout>
  This plugin is maintained by Polar team. For bugs, issues or feature requests,
  please visit the [Polar GitHub
  repo](https://github.com/polarsource/polar-adapters).
</Callout>

## Features

- Checkout Integration
- Customer Portal
- Automatic Customer creation on signup
- Event Ingestion & Customer Meters for flexible Usage Based Billing
- Handle Polar Webhooks securely with signature verification
- Reference System to associate purchases with organizations

## Installation

```bash
pnpm add better-auth @polar-sh/better-auth @polar-sh/sdk
```

## Preparation

Go to your Polar Organization Settings, and create an Organization Access Token. Add it to your environment.

```bash
# .env
POLAR_ACCESS_TOKEN=...
```

### Configuring BetterAuth Server

The Polar plugin comes with a handful additional plugins which adds functionality to your stack.

- Checkout - Enables a seamless checkout integration
- Portal - Makes it possible for your customers to manage their orders, subscriptions & granted benefits
- Usage - Simple extension for listing customer meters & ingesting events for Usage Based Billing
- Webhooks - Listen for relevant Polar webhooks

```typescript
import { betterAuth } from "better-auth";
import { polar, checkout, portal, usage, webhooks } from "@polar-sh/better-auth";
import { Polar } from "@polar-sh/sdk";

const polarClient = new Polar({
    accessToken: process.env.POLAR_ACCESS_TOKEN,
    // Use 'sandbox' if you're using the Polar Sandbox environment
    // Remember that access tokens, products, etc. are completely separated between environments.
    // Access tokens obtained in Production are for instance not usable in the Sandbox environment.
    server: 'sandbox'
});

const auth = betterAuth({
    // ... Better Auth config
    plugins: [
        polar({
            client: polarClient,
            createCustomerOnSignUp: true,
            use: [
                checkout({
                    products: [
                        {
                            productId: "123-456-789", // ID of Product from Polar Dashboard
                            slug: "pro" // Custom slug for easy reference in Checkout URL, e.g. /checkout/pro
                        }
                    ],
                    successUrl: "/success?checkout_id={CHECKOUT_ID}",
                    authenticatedUsersOnly: true
                }),
                portal(),
                usage(),
                webhooks({
                    secret: process.env.POLAR_WEBHOOK_SECRET,
                    onCustomerStateChanged: (payload) => // Triggered when anything regarding a customer changes
                    onOrderPaid: (payload) => // Triggered when an order was paid (purchase, subscription renewal, etc.)
                    ...  // Over 25 granular webhook handlers
                    onPayload: (payload) => // Catch-all for all events
                })
            ],
        })
    ]
});
```

### Configuring BetterAuth Client

You will be using the BetterAuth Client to interact with the Polar functionalities.

```typescript
import { createAuthClient } from "better-auth/react";
import { polarClient } from "@polar-sh/better-auth/client";

// This is all that is needed
// All Polar plugins, etc. should be attached to the server-side BetterAuth config
export const authClient = createAuthClient({
  plugins: [polarClient()],
});
```

## Configuration Options

```typescript
import { betterAuth } from "better-auth";
import {
  polar,
  checkout,
  portal,
  usage,
  webhooks,
} from "@polar-sh/better-auth";
import { Polar } from "@polar-sh/sdk";

const polarClient = new Polar({
  accessToken: process.env.POLAR_ACCESS_TOKEN,
  // Use 'sandbox' if you're using the Polar Sandbox environment
  // Remember that access tokens, products, etc. are completely separated between environments.
  // Access tokens obtained in Production are for instance not usable in the Sandbox environment.
  server: "sandbox",
});

const auth = betterAuth({
  // ... Better Auth config
  plugins: [
    polar({
      client: polarClient,
      createCustomerOnSignUp: true,
      getCustomerCreateParams: ({ user }, request) => ({
        metadata: {
          myCustomProperty: 123,
        },
      }),
      use: [
        // This is where you add Polar plugins
      ],
    }),
  ],
});
```

### Required Options

- `client`: Polar SDK client instance

### Optional Options

- `createCustomerOnSignUp`: Automatically create a Polar customer when a user signs up
- `getCustomerCreateParams`: Custom function to provide additional customer creation metadata

### Customers

When `createCustomerOnSignUp` is enabled, a new Polar Customer is automatically created when a new User is added in the Better-Auth Database.

All new customers are created with an associated `externalId`, which is the ID of your User in the Database. This allows us to skip any Polar to User mapping in your Database.

## Checkout Plugin

To support checkouts in your app, simply pass the Checkout plugin to the use-property.

```typescript
import { polar, checkout } from "@polar-sh/better-auth";

const auth = betterAuth({
    // ... Better Auth config
    plugins: [
        polar({
            ...
            use: [
                checkout({
                    // Optional field - will make it possible to pass a slug to checkout instead of Product ID
                    products: [ { productId: "123-456-789", slug: "pro" } ],
                    // Relative URL to return to when checkout is successfully completed
                    successUrl: "/success?checkout_id={CHECKOUT_ID}",
                    // Whether you want to allow unauthenticated checkout sessions or not
                    authenticatedUsersOnly: true
                })
            ],
        })
    ]
});
```

When checkouts are enabled, you're able to initialize Checkout Sessions using the checkout-method on the BetterAuth Client. This will redirect the user to the Product Checkout.

```typescript
await authClient.checkout({
  // Any Polar Product ID can be passed here
  products: ["e651f46d-ac20-4f26-b769-ad088b123df2"],
  // Or, if you setup "products" in the Checkout Config, you can pass the slug
  slug: "pro",
});
```

Checkouts will automatically carry the authenticated User as the customer to the checkout. Email-address will be "locked-in".

If `authenticatedUsersOnly` is `false` - then it will be possible to trigger checkout sessions without any associated customer.

### Organization Support

This plugin supports the Organization plugin. If you pass the organization ID to the Checkout referenceId, you will be able to keep track of purchases made from organization members.

```typescript
const organizationId = (await authClient.organization.list())?.data?.[0]?.id,

await authClient.checkout({
    // Any Polar Product ID can be passed here
    products: ["e651f46d-ac20-4f26-b769-ad088b123df2"],
    // Or, if you setup "products" in the Checkout Config, you can pass the slug
    slug: 'pro',
    // Reference ID will be saved as `referenceId` in the metadata of the checkout, order & subscription object
    referenceId: organizationId
});
```

## Portal Plugin

A plugin which enables customer management of their purchases, orders and subscriptions.

```typescript
import { polar, checkout, portal } from "@polar-sh/better-auth";

const auth = betterAuth({
    // ... Better Auth config
    plugins: [
        polar({
            ...
            use: [
                checkout(...),
                portal()
            ],
        })
    ]
});
```

The portal-plugin gives the BetterAuth Client a set of customer management methods, scoped under `authClient.customer`.

### Customer Portal Management

The following method will redirect the user to the Polar Customer Portal, where they can see orders, purchases, subscriptions, benefits, etc.

```typescript
await authClient.customer.portal();
```

### Customer State

The portal plugin also adds a convenient state-method for retrieving the general Customer State.

```typescript
const { data: customerState } = await authClient.customer.state();
```

The customer state object contains:

- All the data about the customer.
- The list of their active subscriptions
  - Note: This does not include subscriptions done by a parent organization. See the subscription list-method below for more information.
- The list of their granted benefits.
- The list of their active meters, with their current balance.

Thus, with that single object, you have all the required information to check if you should provision access to your service or not.

[You can learn more about the Polar Customer State in the Polar Docs](https://docs.polar.sh/integrate/customer-state).

### Benefits, Orders & Subscriptions

The portal plugin adds 3 convenient methods for listing benefits, orders & subscriptions relevant to the authenticated user/customer.

[All of these methods use the Polar CustomerPortal APIs](https://docs.polar.sh/api-reference/customer-portal)

#### Benefits

This method only lists granted benefits for the authenticated user/customer.

```typescript
const { data: benefits } = await authClient.customer.benefits.list({
  query: {
    page: 1,
    limit: 10,
  },
});
```

#### Orders

This method lists orders like purchases and subscription renewals for the authenticated user/customer.

```typescript
const { data: orders } = await authClient.customer.orders.list({
  query: {
    page: 1,
    limit: 10,
    productBillingType: "one_time", // or 'recurring'
  },
});
```

#### Subscriptions

This method lists the subscriptions associated with authenticated user/customer.

```typescript
const { data: subscriptions } = await authClient.customer.subscriptions.list({
  query: {
    page: 1,
    limit: 10,
    active: true,
  },
});
```

**Important** - Organization Support

This will **not** return subscriptions made by a parent organization to the authenticated user.

However, you can pass a `referenceId` to this method. This will return all subscriptions associated with that referenceId instead of subscriptions associated with the user.

So in order to figure out if a user should have access, pass the user's organization ID to see if there is an active subscription for that organization.

```typescript
const organizationId = (await authClient.organization.list())?.data?.[0]?.id,

const { data: subscriptions } = await authClient.customer.orders.list({
    query: {
	    page: 1,
		limit: 10,
		active: true,
        referenceId: organizationId
    },
});

const userShouldHaveAccess = subscriptions.some(
    sub => // Your logic to check subscription product or whatever.
)
```

## Usage Plugin

A simple plugin for Usage Based Billing.

```typescript
import { polar, checkout, portal, usage } from "@polar-sh/better-auth";

const auth = betterAuth({
    // ... Better Auth config
    plugins: [
        polar({
            ...
            use: [
                checkout(...),
                portal(),
                usage()
            ],
        })
    ]
});
```

### Event Ingestion

Polar's Usage Based Billing builds entirely on event ingestion. Ingest events from your application, create Meters to represent that usage, and add metered prices to Products to charge for it.

[Learn more about Usage Based Billing in the Polar Docs.](https://docs.polar.sh/features/usage-based-billing/introduction)

```typescript
const { data: ingested } = await authClient.usage.ingest({
  event: "file-uploads",
  metadata: {
    uploadedFiles: 12,
  },
});
```

The authenticated user is automatically associated with the ingested event.

### Customer Meters

A simple method for listing the authenticated user's Usage Meters, or as we call them, Customer Meters.

Customer Meter's contains all information about their consumption on your defined meters.

- Customer Information
- Meter Information
- Customer Meter Information
  - Consumed Units
  - Credited Units
  - Balance

```typescript
const { data: customerMeters } = await authClient.usage.meters.list({
  query: {
    page: 1,
    limit: 10,
  },
});
```

## Webhooks Plugin

The Webhooks plugin can be used to capture incoming events from your Polar organization.

```typescript
import { polar, webhooks } from "@polar-sh/better-auth";

const auth = betterAuth({
    // ... Better Auth config
    plugins: [
        polar({
            ...
            use: [
                webhooks({
                    secret: process.env.POLAR_WEBHOOK_SECRET,
                    onCustomerStateChanged: (payload) => // Triggered when anything regarding a customer changes
                    onOrderPaid: (payload) => // Triggered when an order was paid (purchase, subscription renewal, etc.)
                    ...  // Over 25 granular webhook handlers
                    onPayload: (payload) => // Catch-all for all events
                })
            ],
        })
    ]
});
```

Configure a Webhook endpoint in your Polar Organization Settings page. Webhook endpoint is configured at /polar/webhooks.

Add the secret to your environment.

```bash
# .env
POLAR_WEBHOOK_SECRET=...
```

The plugin supports handlers for all Polar webhook events:

- `onPayload` - Catch-all handler for any incoming Webhook event
- `onCheckoutCreated` - Triggered when a checkout is created
- `onCheckoutUpdated` - Triggered when a checkout is updated
- `onOrderCreated` - Triggered when an order is created
- `onOrderPaid` - Triggered when an order is paid
- `onOrderRefunded` - Triggered when an order is refunded
- `onRefundCreated` - Triggered when a refund is created
- `onRefundUpdated` - Triggered when a refund is updated
- `onSubscriptionCreated` - Triggered when a subscription is created
- `onSubscriptionUpdated` - Triggered when a subscription is updated
- `onSubscriptionActive` - Triggered when a subscription becomes active
- `onSubscriptionCanceled` - Triggered when a subscription is canceled
- `onSubscriptionRevoked` - Triggered when a subscription is revoked
- `onSubscriptionUncanceled` - Triggered when a subscription cancellation is reversed
- `onProductCreated` - Triggered when a product is created
- `onProductUpdated` - Triggered when a product is updated
- `onOrganizationUpdated` - Triggered when an organization is updated
- `onBenefitCreated` - Triggered when a benefit is created
- `onBenefitUpdated` - Triggered when a benefit is updated
- `onBenefitGrantCreated` - Triggered when a benefit grant is created
- `onBenefitGrantUpdated` - Triggered when a benefit grant is updated
- `onBenefitGrantRevoked` - Triggered when a benefit grant is revoked
- `onCustomerCreated` - Triggered when a customer is created
- `onCustomerUpdated` - Triggered when a customer is updated
- `onCustomerDeleted` - Triggered when a customer is deleted
- `onCustomerStateChanged` - Triggered when a customer is created
---
title: OIDC Provider
description: Open ID Connect plugin for Better Auth that allows you to have your own OIDC provider.
---

<Callout type="warn">
This plugin will soon be deprecated in favor of the [OAuth Provider Plugin](/docs/plugins/oauth-provider).
</Callout>

The **OIDC Provider Plugin** enables you to build and manage your own OpenID Connect (OIDC) provider, granting full control over user authentication without relying on third-party services like Okta or Azure AD. It also allows other services to authenticate users through your OIDC provider.

**Key Features**:

- **Client Registration**: Register clients to authenticate with your OIDC provider.
- **Dynamic Client Registration**: Allow clients to register dynamically.
- **Trusted Clients**: Configure hard-coded trusted clients with optional consent bypass.
- **Authorization Code Flow**: Support the Authorization Code Flow.
- **Public Clients**: Support public clients for SPA, mobile apps, CLI tools, etc.
- **JWKS Endpoint**: Publish a JWKS endpoint to allow clients to verify tokens. (Not fully implemented)
- **Refresh Tokens**: Issue refresh tokens and handle access token renewal using the `refresh_token` grant.
- **OAuth Consent**: Implement OAuth consent screens for user authorization, with an option to bypass consent for trusted applications.
- **UserInfo Endpoint**: Provide a UserInfo endpoint for clients to retrieve user details.

<Callout type="warn">
This plugin is in active development and may not be suitable for production use. Please report any issues or bugs on [GitHub](https://github.com/better-auth/better-auth).
</Callout>

## Installation

<Steps>
    <Step>
        ### Mount the Plugin

        Add the OIDC plugin to your auth config. See [Configuration Section](#configuration) on how to configure the plugin.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { oidcProvider } from "better-auth/plugins"; // [!code highlight]

        const auth = betterAuth({
            plugins: [
            oidcProvider({ // [!code highlight]
                loginPage: "/sign-in", // path to the login page // [!code highlight]
                // ...other options // [!code highlight]
              }) // [!code highlight]
            ]
        })
        ```
    </Step>

    <Step>
        ### Migrate the Database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

    <Step>
        ### Add the Client Plugin

        Add the OIDC client plugin to your auth client config.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client";
        import { oidcClient } from "better-auth/client/plugins" // [!code highlight]
        
        const authClient = createAuthClient({
            plugins: [
            oidcClient({ // [!code highlight]
                // Your OIDC configuration // [!code highlight]
              }) // [!code highlight]
            ]
        })
        ```
    </Step>
</Steps>

## Usage

Once installed, you can utilize the OIDC Provider to manage authentication flows within your application.

### Register a New Client

To register a new OIDC client, use the `oauth2.register` method on the client or `auth.api.registerOAuthApplication` on the server.

<APIMethod 
  path="/oauth2/register" 
  method="POST"
  note="By default, client registration requires authentication. Set `allowDynamicClientRegistration: true` to allow public registration. Make sure to add the `oidcClient()` plugin to your auth client configuration."
>
```ts
type registerOAuthApplication = {
    /**
     * A list of redirect URIs. 
     */
    redirect_uris: string[] = ["https://client.example.com/callback"]
    /**
     * The authentication method for the token endpoint. 
     */
    token_endpoint_auth_method?: "none" | "client_secret_basic" | "client_secret_post" = "client_secret_basic"
    /**
     * The grant types supported by the application. 
     */
    grant_types?: ("authorization_code" | "implicit" | "password" | "client_credentials" | "refresh_token" | "urn:ietf:params:oauth:grant-type:jwt-bearer" | "urn:ietf:params:oauth:grant-type:saml2-bearer")[] = ["authorization_code"]
    /**
     * The response types supported by the application. 
     */
    response_types?: ("code" | "token")[] = ["code"]
    /**
     * The name of the application. 
     */
    client_name?: string = "My App"
    /**
     * The URI of the application. 
     */
    client_uri?: string = "https://client.example.com"
    /**
     * The URI of the application logo. 
     */
    logo_uri?: string = "https://client.example.com/logo.png"
    /**
     * The scopes supported by the application. Separated by spaces. 
     */
    scope?: string = "profile email"
    /**
     * The contact information for the application. 
     */
    contacts?: string[] = ["admin@example.com"]
    /**
     * The URI of the application terms of service. 
     */
    tos_uri?: string = "https://client.example.com/tos"
    /**
     * The URI of the application privacy policy. 
     */
    policy_uri?: string = "https://client.example.com/policy"
    /**
     * The URI of the application JWKS. 
     */
    jwks_uri?: string = "https://client.example.com/jwks"
    /**
     * The JWKS of the application. 
     */
    jwks?: Record<string, any> = {"keys": [{"kty": "RSA", "alg": "RS256", "use": "sig", "n": "...", "e": "..."}]}
    /**
     * The metadata of the application. 
     */
    metadata?: Record<string, any> = {"key": "value"}
    /**
     * The software ID of the application. 
     */
    software_id?: string = "my-software"
    /**
     * The software version of the application. 
     */
    software_version?: string = "1.0.0"
    /**
     * The software statement of the application. 
     */
    software_statement?: string
}
```
</APIMethod>

<Callout>
This endpoint supports [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591) compliant client registration.
</Callout>

Once the application is created, you will receive a `client_id` and `client_secret` that you can display to the user.

### Trusted Clients

For first-party applications and internal services, you can configure trusted clients directly in your OIDC provider configuration. Trusted clients bypass database lookups for better performance and can optionally skip consent screens for improved user experience.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

const auth = betterAuth({
    plugins: [
      oidcProvider({
        loginPage: "/sign-in",
        trustedClients: [
            {
                clientId: "internal-dashboard",
                clientSecret: "secure-secret-here",
                name: "Internal Dashboard",
                type: "web",
                redirectUrls: ["https://dashboard.company.com/auth/callback"],
                disabled: false,
                skipConsent: true, // Skip consent for this trusted client
                metadata: { internal: true }
            },
            {
                clientId: "mobile-app",
                clientSecret: "mobile-secret", 
                name: "Company Mobile App",
                type: "native",
                redirectUrls: ["com.company.app://auth"],
                disabled: false,
                skipConsent: false, // Still require consent if needed
                metadata: {}
            }
        ]
    })]
})
```

### UserInfo Endpoint

The OIDC Provider includes a UserInfo endpoint that allows clients to retrieve information about the authenticated user. This endpoint is available at `/oauth2/userinfo` and requires a valid access token.

<Endpoint path="/oauth2/userinfo" method="GET" />

#### Server-Side Usage

```ts title="server.ts"
import { auth } from "@/lib/auth";

const userInfo = await auth.api.oAuth2userInfo({
  headers: {
    authorization: "Bearer ACCESS_TOKEN"
  }
});
// userInfo contains user details based on the scopes granted
```

#### Client-Side Usage (For Third-Party OAuth Clients)

Third-party OAuth clients can call the UserInfo endpoint using standard HTTP requests:

```ts title="external-client.ts"
const response = await fetch('https://your-domain.com/api/auth/oauth2/userinfo', {
  headers: {
    'Authorization': 'Bearer ACCESS_TOKEN'
  }
});

const userInfo = await response.json();
```

**Returned claims based on scopes:**

- With `openid` scope: Returns the user's ID (`sub` claim)
- With `profile` scope: Returns `name`, `picture`, `given_name`, `family_name`
- With `email` scope: Returns `email` and `email_verified`

#### Custom Claims

The `getAdditionalUserInfoClaim` function receives the user object, requested scopes array, and the client, allowing you to conditionally include claims based on the scopes granted during authorization. These additional claims will be included in both the UserInfo endpoint response and the ID token.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [
        oidcProvider({
            loginPage: "/sign-in",
            getAdditionalUserInfoClaim: async (user, scopes, client) => {
                const claims: Record<string, any> = {};
                
                // Add custom claims based on scopes
                if (scopes.includes("profile")) {
                    claims.department = user.department;
                    claims.job_title = user.jobTitle;
                }
                
                // Add claims based on client metadata
                if (client.metadata?.includeRoles) {
                    claims.roles = user.roles;
                }
                
                return claims;
            }
        })
    ]
});
```

### Consent Screen

When a user is redirected to the OIDC provider for authentication, they may be prompted to authorize the application to access their data. This is known as the consent screen. By default, Better Auth will display a sample consent screen. You can customize the consent screen by providing a `consentPage` option during initialization.

**Note**: Trusted clients with `skipConsent: true` will bypass the consent screen entirely, providing a seamless experience for first-party applications.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [
      oidcProvider({
        consentPage: "/path/to/consent/page"
      })
    ]
})
```

The plugin will redirect the user to the specified path with `consent_code`, `client_id` and `scope` query parameters. You can use this information to display a custom consent screen. Once the user consents, you can call `oauth2.consent` to complete the authorization.

<Endpoint path="/oauth2/consent" method="POST" />

The consent endpoint supports two methods for passing the consent code:

**Method 1: URL Parameter**
```ts title="consent-page.ts"
import { authClient } from "@/lib/auth-client"

// Get the consent code from the URL
const params = new URLSearchParams(window.location.search);

// Submit consent with the code in the request body
const consentCode = params.get('consent_code');
if (!consentCode) {
	throw new Error('Consent code not found in URL parameters');
}

const res = await authClient.oauth2.consent({
	accept: true, // or false to deny
	consent_code: consentCode,
});
```

**Method 2: Cookie-Based**
```ts title="consent-page.ts"
import { authClient } from "@/lib/auth-client"

// The consent code is automatically stored in a signed cookie
// Just submit the consent decision
const res = await authClient.oauth2.consent({
	accept: true, // or false to deny
	// consent_code not needed when using cookie-based flow
});
```

Both methods are fully supported. The URL parameter method works well with mobile apps and third-party contexts, while the cookie-based method provides a simpler implementation for web applications.

### Handling Login

When a user is redirected to the OIDC provider for authentication, if they are not already logged in, they will be redirected to the login page. You can customize the login page by providing a `loginPage` option during initialization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    plugins: [
      oidcProvider({
        loginPage: "/sign-in"
      })
    ]
})
```

You don't need to handle anything from your side; when a new session is created, the plugin will handle continuing the authorization flow.

## Configuration

### OIDC Metadata

Customize the OIDC metadata by providing a configuration object during initialization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [
      oidcProvider({
        metadata: {
            issuer: "https://your-domain.com",
            authorization_endpoint: "/custom/oauth2/authorize",
            token_endpoint: "/custom/oauth2/token",
            // ...other custom metadata
        }
      })
    ]
})
```

### JWKS Endpoint

The OIDC Provider plugin can integrate with the JWT plugin to provide asymmetric key signing for ID tokens verifiable at a JWKS endpoint.

To make your plugin OIDC compliant, you **MUST** disable the `/token` endpoint, the OAuth equivalent is located at `/oauth2/token` instead.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";
import { jwt } from "better-auth/plugins";

export const auth = betterAuth({
    disabledPaths: [
        "/token",
    ],
    plugins: [
        jwt(), // Make sure to add the JWT plugin
        oidcProvider({
            useJWTPlugin: true, // Enable JWT plugin integration
            loginPage: "/sign-in",
            // ... other options
        })
    ]
})
```

<Callout type="info">
When `useJWTPlugin: false` (default), ID tokens are signed with the application secret.
</Callout>

### Dynamic Client Registration

If you want to allow clients to register dynamically, you can enable this feature by setting the `allowDynamicClientRegistration` option to `true`.

```ts title="auth.ts"
const auth = betterAuth({
    plugins: [
      oidcProvider({
        allowDynamicClientRegistration: true,
      })
    ]
})
```

This will allow clients to register using the `/register` endpoint to be publicly available.

## Schema

The OIDC Provider plugin adds the following tables to the database:

### OAuth Application

Table Name: `oauthApplication`

<DatabaseTable
  fields={[
   {
      name: "id",
      type: "string",
      description: "Database ID of the OAuth client",
      isPrimaryKey: true
   },
    { 
      name: "clientId", 
      type: "string", 
      description: "Unique identifier for each OAuth client",
      isPrimaryKey: true
    },
    { 
      name: "clientSecret", 
      type: "string", 
      description: "Secret key for the OAuth client. Optional for public clients using PKCE.",
      isOptional: true
    },
    { 
      name: "name", 
      type: "string", 
      description: "Name of the OAuth client",
      isRequired: true
    },
    { 
      name: "redirectUrls",
      type: "string", 
      description: "Comma-separated list of redirect URLs",
      isRequired: true
    },
    { 
      name: "metadata", 
      type: "string",
      description: "Additional metadata for the OAuth client",
      isOptional: true
    },
    { 
      name: "type", 
      type: "string",
      description: "Type of OAuth client (e.g., web, mobile)",
      isRequired: true
    },
    { 
      name: "disabled", 
      type: "boolean", 
      description: "Indicates if the client is disabled",
      isRequired: true
    },
    { 
      name: "userId", 
      type: "string", 
      description: "ID of the user who owns the client. (optional)",
      isOptional: true,
      references: { model: "user", field: "id" }
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the OAuth client was created" 
    },
   {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was last updated"
   }
  ]}
/>

### OAuth Access Token

Table Name: `oauthAccessToken`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the access token",
      isPrimaryKey: true
   },
    { 
      name: "accessToken", 
      type: "string", 
      description: "Access token issued to the client",
    },
    { 
      name: "refreshToken", 
      type: "string", 
      description: "Refresh token issued to the client",
      isRequired: true
    },
    { 
      name: "accessTokenExpiresAt", 
      type: "Date", 
      description: "Expiration date of the access token",
      isRequired: true
    },
    { 
      name: "refreshTokenExpiresAt", 
      type: "Date", 
      description: "Expiration date of the refresh token",
      isRequired: true
    },
    { 
      name: "clientId", 
      type: "string", 
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthApplication", field: "clientId" }
    },
    { 
      name: "userId", 
      type: "string", 
      description: "ID of the user associated with the token",
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    { 
      name: "scopes", 
      type: "string", 
      description: "Comma-separated list of scopes granted",
      isRequired: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the access token was created" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the access token was last updated"
    }
  ]}
/>

### OAuth Consent

Table Name: `oauthConsent`

<DatabaseTable
  fields={[
    { 
      name: "id", 
      type: "string", 
      description: "Database ID of the consent",
      isPrimaryKey: true
    },
    { 
      name: "userId", 
      type: "string", 
      description: "ID of the user who gave consent",
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    { 
      name: "clientId", 
      type: "string", 
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthApplication", field: "clientId" }
    },
    { 
      name: "scopes", 
      type: "string", 
      description: "Comma-separated list of scopes consented to",
      isRequired: true
    },
    { 
      name: "consentGiven", 
      type: "boolean", 
      description: "Indicates if consent was given",
      isRequired: true
    },
    { 
      name: "createdAt", 
      type: "Date", 
      description: "Timestamp of when the consent was given" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the consent was last updated"
    }
  ]}
/>

## Options

**allowDynamicClientRegistration**: `boolean` - Enable or disable dynamic client registration.

**metadata**: `OIDCMetadata` - Customize the OIDC provider metadata.

**loginPage**: `string` - Path to the custom login page.

**consentPage**: `string` - Path to the custom consent page.

**trustedClients**: `(Client & { skipConsent?: boolean })[]` - Array of trusted clients that are configured directly in the provider options. These clients bypass database lookups and can optionally skip consent screens.

**getAdditionalUserInfoClaim**: `(user: User, scopes: string[], client: Client) => Record<string, any>` - Function to get additional user info claims.

**useJWTPlugin**: `boolean` - When `true`, ID tokens are signed using the JWT plugin's asymmetric keys. When `false` (default), ID tokens are signed with HMAC-SHA256 using the application secret.

**schema**: `AuthPluginSchema` - Customize the OIDC provider schema.
---
title: Have I Been Pwned
description: A plugin to check if a password has been compromised
---

The Have I Been Pwned plugin helps protect user accounts by preventing the use of passwords that have been exposed in known data breaches. It uses the [Have I Been Pwned](https://haveibeenpwned.com/) API to check if a password has been compromised.

## Installation

### Add the plugin to your **auth** config
```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { haveIBeenPwned } from "better-auth/plugins" // [!code highlight]

export const auth = betterAuth({
    plugins: [
        haveIBeenPwned() // [!code highlight]
    ]
})
```

## Usage

When a user attempts to create an account or update their password with a compromised password, they'll receive the following default error:

```json
{
  "code": "PASSWORD_COMPROMISED",
  "message": "Password is compromised"
}
```

## Config

You can customize the error message:

```ts
haveIBeenPwned({
    customPasswordCompromisedMessage: "Please choose a more secure password."
})
```
## Security Notes

- Only the first 5 characters of the password hash are sent to the API
- The full password is never transmitted
- Provides an additional layer of account security
---
title: Captcha
description: Captcha plugin
---

The **Captcha Plugin** integrates bot protection into your Better Auth system by adding captcha verification for key endpoints. This plugin ensures that only human users can perform actions like signing up, signing in, or resetting passwords. The following providers are currently supported:
- [Google reCAPTCHA](https://developers.google.com/recaptcha)
- [Cloudflare Turnstile](https://www.cloudflare.com/application-services/products/turnstile/)
- [hCaptcha](https://www.hcaptcha.com/)
- [CaptchaFox](https://captchafox.com/)

<Callout type="info">
  This plugin works out of the box with <Link href="/docs/authentication/email-password">Email & Password</Link> authentication. To use it with other authentication methods, you will need to configure the <Link href="/docs/plugins/captcha#plugin-options">endpoints</Link> array in the plugin options.
</Callout>

## Installation

<Steps>
  <Step>
    ### Add the plugin to your **auth** config

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { captcha } from "better-auth/plugins"; // [!code highlight]

    export const auth = betterAuth({
        plugins: [
            captcha({ // [!code highlight]
                provider: "cloudflare-turnstile", // or google-recaptcha, hcaptcha, captchafox // [!code highlight]
                secretKey: process.env.TURNSTILE_SECRET_KEY!, // [!code highlight]
            }), // [!code highlight]
        ],
    });
    ```

  </Step>
  <Step>
    ### Add the captcha token to your request headers

    <Callout type="warning">
      The `x-captcha-user-remote-ip` header is no longer required—IP is now auto-detected server-side.
    </Callout>

    Add the captcha token to your request headers for all protected endpoints. This example shows how to include it in a `signIn` request:

    ```ts
    import { authClient } from "@/lib/auth-client"
    
    await authClient.signIn.email({
        email: "user@example.com",
        password: "secure-password",
        fetchOptions: { // [!code highlight]
            headers: { // [!code highlight]
                "x-captcha-response": turnstileToken, // [!code highlight]
            }, // [!code highlight]
        }, // [!code highlight]
    });
    ```

    - To implement Cloudflare Turnstile on the client side, follow the official [Cloudflare Turnstile documentation](https://developers.cloudflare.com/turnstile/) or use a library like [react-turnstile](https://www.npmjs.com/package/@marsidev/react-turnstile).
    - To implement Google reCAPTCHA on the client side, follow the official [Google reCAPTCHA documentation](https://developers.google.com/recaptcha/intro) or use libraries like [react-google-recaptcha](https://www.npmjs.com/package/react-google-recaptcha) (v2) and [react-google-recaptcha-v3](https://www.npmjs.com/package/react-google-recaptcha-v3) (v3).
    - To implement hCaptcha on the client side, follow the official [hCaptcha documentation](https://docs.hcaptcha.com/#add-the-hcaptcha-widget-to-your-webpage) or use libraries like [@hcaptcha/react-hcaptcha](https://www.npmjs.com/package/@hcaptcha/react-hcaptcha)
    - To implement CaptchaFox on the client side, follow the official [CaptchaFox documentation](https://docs.captchafox.com/getting-started) or use libraries like [@captchafox/react](https://www.npmjs.com/package/@captchafox/react)
  </Step>
</Steps>

## How it works

<Steps>
  <Step>
    The plugin acts as a middleware: it intercepts all `POST` requests to configured endpoints (see `endpoints`
    in the [Plugin Options](#plugin-options) section).
  </Step>
  <Step>
    it validates the captcha token on the server, by calling the captcha provider's `/siteverify`.
  </Step>
  <Step>
    - if the token is missing, gets rejected by the captcha provider, or if the `/siteverify` endpoint is
    unavailable, the plugin returns an error and interrupts the request.
    - if the token is accepted by the captcha provider, the middleware returns `undefined`, meaning the request is allowed to proceed.

  </Step>
</Steps>

## Plugin Options

- **`provider` (required)**: your captcha provider.
- **`secretKey` (required)**: your provider's secret key used for the server-side validation.
- `endpoints` (optional): replaces the default array of paths where captcha verification is enforced. If set, only the specified paths will be protected. Default is `["/sign-up/email", "/sign-in/email", "/request-password-reset"]`.
- `minScore` (optional - only *Google ReCAPTCHA v3*): minimum score threshold. Default is `0.5`.
- `siteKey` (optional - only *hCaptcha* and *CaptchaFox*): prevents tokens issued on one sitekey from being redeemed elsewhere.
- `siteVerifyURLOverride` (optional): overrides endpoint URL for the captcha verification request.
---
title: i18n
description: Internationalization plugin for translating error messages
---

The i18n plugin allows you to translate error messages returned by Better Auth based on the user's locale. It supports multiple locale detection strategies including HTTP headers, cookies, session data, and custom callbacks.

Better Auth already provides English error messages by default, so you only need to provide translations for other languages.

## Installation

<Steps>
<Step>
### Install the plugin

```package-install
@better-auth/i18n
```
</Step>
<Step>
### Add the plugin to your **auth** config

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { i18n } from "@better-auth/i18n"

export const auth = betterAuth({
    plugins: [
        i18n({
            translations: {
                fr: {
                    USER_NOT_FOUND: "Utilisateur non trouvé",
                    INVALID_EMAIL_OR_PASSWORD: "Email ou mot de passe invalide",
                    INVALID_PASSWORD: "Mot de passe invalide",
                },
                de: {
                    USER_NOT_FOUND: "Benutzer nicht gefunden",
                    INVALID_EMAIL_OR_PASSWORD: "Ungültige E-Mail oder Passwort",
                    INVALID_PASSWORD: "Ungültiges Passwort",
                },
            },
        }),
    ],
})
```
</Step>
</Steps>

## Usage

The plugin automatically detects the user's locale and translates error messages accordingly. When an error is returned, the response will include both the translated message and the original message.

### Error Response Format

When an error occurs and a translation is available, the response will look like this:

```json
{
    "code": "INVALID_EMAIL_OR_PASSWORD",
    "message": "Email ou mot de passe invalide",
    "originalMessage": "Invalid email or password"
}
```

### Locale Detection

By default, the plugin detects the locale from the `Accept-Language` HTTP header. You can configure multiple detection strategies that are checked in order:

```ts title="auth.ts"
i18n({
    translations: { /* ... */ },
    detection: ["cookie", "header", "session"], // Priority order
})
```

Available detection strategies:

- **`header`** - Uses the `Accept-Language` HTTP header (default)
- **`cookie`** - Reads locale from a cookie
- **`session`** - Reads locale from the authenticated user's stored preference
- **`callback`** - Uses a custom function to determine locale

### Header-Based Detection

The plugin automatically parses the `Accept-Language` header, including quality values:

```http
Accept-Language: fr-CA, fr;q=0.9, en;q=0.8
```

This would first try `fr-CA` (mapped to `fr`), then `fr`, then `en`.

### Cookie-Based Detection

To use cookie-based detection, add `"cookie"` to the detection strategies and optionally configure the cookie name:

```ts title="auth.ts"
i18n({
    translations: { /* ... */ },
    detection: ["cookie", "header"],
    localeCookie: "lang", // Default is "locale"
})
```

### Session-Based Detection

If you store the user's locale preference in their profile, you can detect it from the session:

```ts title="auth.ts"
export const auth = betterAuth({
    user: {
        additionalFields: {
            locale: { type: "string", required: false },
        },
    },
    plugins: [
        i18n({
            translations: { /* ... */ },
            detection: ["session", "header"],
            userLocaleField: "locale", // Default is "locale"
        }),
    ],
})
```

### Custom Detection Callback

For advanced use cases, you can provide a custom locale detection function:

```ts title="auth.ts"
i18n({
    translations: { /* ... */ },
    detection: ["callback", "header"],
    getLocale: (ctx) => {
        // Custom logic: use query param, custom header, etc.
        if (!ctx.request) return null;
        const url = new URL(ctx.request.url);
        return url.searchParams.get("lang");
    },
})
```

The callback receives the full endpoint context. It should return the locale code or `null`.

## Error Codes

The plugin translates error messages based on error codes. You can find all available error codes in the [Error Codes Reference](/docs/reference/errors).

Common error codes include:

| Code | Default Message |
|------|-----------------|
| `USER_NOT_FOUND` | User not found |
| `INVALID_EMAIL_OR_PASSWORD` | Invalid email or password |
| `INVALID_PASSWORD` | Invalid password |
| `CREDENTIAL_ACCOUNT_NOT_FOUND` | Credential account not found |
| `EMAIL_NOT_VERIFIED` | Email not verified |
| `SESSION_EXPIRED` | Session expired |

## Options

### `translations`

**Type:** `Record<string, Record<string, string>>`

**Required:** Yes

A dictionary of translations keyed by locale code. Each locale contains a mapping of error codes to translated messages. Since Better Auth already provides English messages, you typically only need to provide translations for other languages.

```ts
translations: {
    fr: { USER_NOT_FOUND: "Utilisateur non trouvé" },
    de: { USER_NOT_FOUND: "Benutzer nicht gefunden" },
}
```

### `defaultLocale`

**Type:** `string`

**Default:** `"en" when possible, otherwise the first locale in the translations dictionary`

The fallback locale to use when no locale can be detected or the detected locale is not in the translations.

### `detection`

**Type:** `Array<"header" | "cookie" | "session" | "callback">`

**Default:** `["header"]`

An array of detection strategies to use, in priority order. The first strategy that returns a valid locale will be used.

### `localeCookie`

**Type:** `string`

**Default:** `"locale"`

The name of the cookie to read when using the `"cookie"` detection strategy.

### `userLocaleField`

**Type:** `string`

**Default:** `"locale"`

The field name on the user object that stores their locale preference when using the `"session"` detection strategy.

### `getLocale`

**Type:** `(ctx: GenericEndpointContext) => string | null | Promise<string | null>`

A custom function to detect the locale when using the `"callback"` detection strategy. Receives the full endpoint context. Returns the locale code or `null`.

<Callout type="info">
`ctx.request` could be undefined for non-HTTP calls.
</Callout>

## Fallback Behavior

- If a translation is not found for a specific error code in the detected locale, the built-in English message is kept.
- If the detected locale is not in the translations dictionary, the built-in English message is used.
- If no locale can be detected from any strategy, the built-in English message is used.
- Non-error responses are never modified by this plugin.
---
title: Magic link
description: Magic link plugin
---

Magic link or email link is a way to authenticate users without a password. When a user enters their email, a link is sent to their email. When the user clicks on the link, they are authenticated.

## Installation

<Steps>
    <Step>
    ### Add the server Plugin

    Add the magic link plugin to your server:

    ```ts title="server.ts"
    import { betterAuth } from "better-auth";
    import { magicLink } from "better-auth/plugins";  // [!code highlight]

    export const auth = betterAuth({
        plugins: [
            magicLink({ // [!code highlight]
                sendMagicLink: async ({ email, token, url }, ctx) => { // [!code highlight]
                    // send email to user // [!code highlight]
                } // [!code highlight]
            }) // [!code highlight]
        ]
    })
    ```
    </Step>

    <Step>
    ### Add the client Plugin

    Add the magic link plugin to your client:

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client";
    import { magicLinkClient } from "better-auth/client/plugins"; // [!code highlight]
    
    export const authClient = createAuthClient({
        plugins: [
            magicLinkClient() // [!code highlight]
        ]
    });
    ```
    </Step>

</Steps>

## Usage

### Sign In with Magic Link

To sign in with a magic link, you need to call `signIn.magicLink` with the user's email address. The `sendMagicLink` function is called to send the magic link to the user's email.


<APIMethod
  path="/sign-in/magic-link"
  method="POST"
  requireSession
>
  
```ts
type signInMagicLink = {
    /**
     * Email address to send the magic link. 
     */
    email: string = "user@email.com"
    /**
     * User display name. Only used if the user is registering for the first time. 
     */
    name?: string = "my-name"
    /**
     * URL to redirect after magic link verification. 
     */
    callbackURL?: string = "/dashboard"
    /**
     * URL to redirect after new user signup
     */
    newUserCallbackURL?: string = "/welcome"
    /**
     * URL to redirect if an error happen on verification
     * If only callbackURL is provided but without an `errorCallbackURL` then they will be 
     * redirected to the callbackURL with an `error` query parameter.
     */
    errorCallbackURL?: string = "/error"
}
```
</APIMethod>

<Callout>
If the user has not signed up, unless `disableSignUp` is set to `true`, the user will be signed up automatically.
</Callout>

### Verify Magic Link

When you send the URL generated by the `sendMagicLink` function to a user, clicking the link will authenticate them and redirect them to the `callbackURL` specified in the `signIn.magicLink` function. If an error occurs, the user will be redirected to the `callbackURL` with an error query parameter.

<Callout type="warn">
  If no `callbackURL` is provided, the user will be redirected to the root URL.
</Callout>

If you want to handle the verification manually, (e.g, if you send the user a different URL), you can use the `verify` function.


<APIMethod
  path="/magic-link/verify"
  method="GET"
  requireSession
>
```ts
type magicLinkVerify = {
    /**
     * Verification token. 
     */
    token: string = "123456"
    /**
     * URL to redirect after magic link verification, if not provided will return the session. 
     */
    callbackURL?: string = "/dashboard"
}
```
</APIMethod>

## Configuration Options

**sendMagicLink**: The `sendMagicLink` function is called when a user requests a magic link. It takes an object with the following properties:

- `email`: The email address of the user.
- `url`: The URL to be sent to the user. This URL contains the token.
- `token`: The token if you want to send the token with custom URL.

and a `ctx` context object as the second parameter.

**expiresIn**: specifies the time in seconds after which the magic link will expire. The default value is `300` seconds (5 minutes).

**allowedAttempts**: Specifies the number of allowed attempts for verifying the magic link. The default value is `1`. When the limit is exceeded, the token is deleted and the user is redirected with `?error=ATTEMPTS_EXCEEDED`. Set to `Infinity` to allow unlimited attempts.

**disableSignUp**: If set to `true`, the user will not be able to sign up using the magic link. The default value is `false`.

**generateToken**: The `generateToken` function is called to generate a token which is used to uniquely identify the user. The default value is a random string. There is one parameter:

- `email`: The email address of the user.

<Callout type="warn">
  When using `generateToken`, ensure that the returned string is hard to guess
  because it is used to verify who someone actually is in a confidential way. By
  default, we return a long and cryptographically secure string.
</Callout>

**storeToken**: The `storeToken` function is called to store the magic link token in the database. The default value is `"plain"`.

The `storeToken` function can be one of the following:

- `"plain"`: The token is stored in plain text.
- `"hashed"`: The token is hashed using the default hasher.
- `{ type: "custom-hasher", hash: (token: string) => Promise<string> }`: The token is hashed using a custom hasher.
---
title: Community Plugins
description: A list of recommended community plugins.
---

import { CommunityPluginsTable } from "@/components/community-plugins-table";

This page showcases a list of recommended community made plugins. We encourage you to create custom plugins and maybe get added to the list!

## Create Your Own Plugin

To create your own custom plugin, get started by reading our [plugins documentation](/docs/concepts/plugins). And if you want to share your plugin with the community, please open a pull request to add it to this list.

## Browse Community Plugins

<CommunityPluginsTable />
---
title: Anonymous  
description: Anonymous plugin for Better Auth.
---

The Anonymous plugin allows users to have an authenticated experience without requiring them to provide an email address, password, OAuth provider, or any other Personally Identifiable Information (PII). Users can later link an authentication method to their account when ready.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To enable anonymous authentication, add the anonymous plugin to your authentication configuration.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { anonymous } from "better-auth/plugins" // [!code highlight]
    
    export const auth = betterAuth({
        // ... other config options
        plugins: [
            anonymous() // [!code highlight]
        ]
    })
    ```
  </Step>

    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>

  <Step>
    ### Add the client plugin

    Next, include the anonymous client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { anonymousClient } from "better-auth/client/plugins" // [!code highlight]
    
    export const authClient = createAuthClient({
        plugins: [
            anonymousClient() // [!code highlight]
        ]
    })
    ```
  </Step>
</Steps>

## Usage

### Sign In

To sign in a user anonymously, use the `signIn.anonymous()` method.

```ts
import { authClient } from "@/lib/auth-client";

const user = await authClient.signIn.anonymous()
```

### Link Account

If a user is already signed in anonymously and tries to `signIn` or `signUp` with another method,
their anonymous activities can be linked to the new account.

To do that you first need to provide `onLinkAccount` callback to the plugin.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { anonymous } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        anonymous({
            onLinkAccount: async ({ anonymousUser, newUser }) => {
               // perform actions like moving the cart items from anonymous user to the new user
            }
        })
    ]
```

Then when you call `signIn` or `signUp` with another method, the `onLinkAccount` callback will be called. And the `anonymousUser` will be deleted by default.

```ts
import { authClient } from "@/lib/auth-client";

const user = await authClient.signIn.email({
    email,
})
```

### Delete Anonymous User

To delete an anonymous user, you can call the `/delete-anonymous-user` endpoint.

<APIMethod
  path="/delete-anonymous-user"
  method="POST"
  noResult
>
```ts
type deleteAnonymousUser = {
}
```
</APIMethod>

<Callout type="info">
**Notes:**
- The anonymous user is deleted by default when the account is linked to a new authentication method.
- Setting `disableDeleteAnonymousUser` to `true` will prevent the anonymous user from being able to call the `/delete-anonymous-user` endpoint.
</Callout>

## Options

### `emailDomainName`

The domain name to use when generating an email address for anonymous users. If not provided, the default format `temp@{id}.com` is used.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { anonymous } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        anonymous({
            emailDomainName: "example.com" // [!code highlight] -> temp-{id}@example.com
        })
    ]
})
```

### `generateRandomEmail`

A custom function to generate email addresses for anonymous users. This allows you to define your own email format. The function can be synchronous or asynchronous.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { anonymous } from "better-auth/plugins"

export const auth = betterAuth({
    plugins: [
        anonymous({
            generateRandomEmail: () => { // [!code highlight]
                const id = crypto.randomUUID() // [!code highlight]
                return `guest-${id}@example.com` // [!code highlight]
            } // [!code highlight]
        })
    ]
})
```

<Callout type="info">
**Notes:**
- If `generateRandomEmail` is provided, `emailDomainName` is ignored.
- You are responsible for ensuring the email is unique to avoid conflicts. The returned email must be in a valid format.
</Callout>


### `onLinkAccount`

A callback function that is called when an anonymous user links their account to a new authentication method. The callback receives an object with the `anonymousUser` and the `newUser`.

### `disableDeleteAnonymousUser`

By default, when an anonymous user links their account to a new authentication method,
the anonymous user record is automatically deleted.
If you set this option to `true`, this automatic deletion will be disabled,
and the `/delete-anonymous-user` endpoint will no longer be accessible to anonymous users.

### `generateName`

A callback function that is called to generate a name for the anonymous user. Useful if you want to have random names for anonymous users, or if `name` is unique in your database.

## Schema

The anonymous plugin requires an additional field in the user table:

<DatabaseTable
    fields={[
        { name: "isAnonymous", type: "boolean", description: "Indicates whether the user is anonymous.", isOptional: true },
    ]}
/>
---
title: One Tap
description: One Tap plugin for Better Auth
---

The One Tap plugin allows users to log in with a single tap using Google's One Tap API. The plugin
provides a simple way to integrate One Tap into your application, handling the client-side and server-side logic for you.

## Installation
<Steps>
    <Step>
### Add the Server Plugin
Add the One Tap plugin to your auth configuration:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oneTap } from "better-auth/plugins"; // [!code highlight]

export const auth = betterAuth({
    plugins: [
        oneTap(), // Add the One Tap server plugin  // [!code highlight]
    ]
});
```
    </Step>
    
    <Step>
### Add the Client Plugin
Add the client plugin and specify where the user should be redirected after sign-in or if additional verification (like 2FA) is needed.


```ts
import { createAuthClient } from "better-auth/client";
import { oneTapClient } from "better-auth/client/plugins"; // [!code highlight]

export const authClient = createAuthClient({
  plugins: [
    oneTapClient({
      clientId: "YOUR_CLIENT_ID",
      // Optional client configuration:
      autoSelect: false,
      cancelOnTapOutside: true,
      context: "signin",
      additionalOptions: {
        // Any extra options for the Google initialize method
      },
      // Configure prompt behavior and exponential backoff:
      promptOptions: {
        baseDelay: 1000,   // Base delay in ms (default: 1000)
        maxAttempts: 5     // Maximum number of attempts before triggering onPromptNotification (default: 5)
      }
    })
  ]
});
```
    </Step>
</Steps>

### Usage

#### Prompt Mode (Default)

To display the One Tap popup, simply call the oneTap method on your auth client:

```ts
import { authClient } from "@/lib/auth-client";

await authClient.oneTap(); // [!code highlight]
```

#### Button Mode

To render a "Sign In with Google" button instead of showing the automatic prompt, use the `button` option:

<Tabs items={["Vanilla JS", "React Ref"]}>
  <Tab value="Vanilla JS">
    ```tsx
    // In your component
    <div id="google-signin-button"></div>

    // Call oneTap with button configuration
    await authClient.oneTap({
      button: {
        container: "#google-signin-button", // CSS selector or HTMLElement
        config: {
          theme: "outline",
          size: "large",
          type: "standard",
          text: "signin_with"
        }
      }
    });
    ```
  </Tab>
  <Tab value="React Ref">
    ```tsx
    import { useEffect, useRef } from "react";

    function SignInButton() {
      const buttonRef = useRef<HTMLDivElement>(null);

      useEffect(() => {
        if (buttonRef.current) {
          authClient.oneTap({
            button: {
              container: buttonRef.current,
              config: {
                theme: "filled_blue",
                size: "large"
              }
            }
          });
        }
      }, []);

      return <div ref={buttonRef}></div>;
    }
    ```
  </Tab>
</Tabs>

### Customizing Redirect Behavior

By default, after a successful login the plugin will hard redirect the user to `/`. You can customize this behavior as follows:

#### Avoiding a Hard Redirect

Pass fetchOptions with an onSuccess callback to handle the login response without a page reload:

```ts
import { authClient } from "@/lib/auth-client";

await authClient.oneTap({
  fetchOptions: {
    onSuccess: () => {
      // For example, use a router to navigate without a full reload:
      router.push("/dashboard");
    }
  }
});
```

#### Specifying a Custom Callback URL

To perform a hard redirect to a different page after login, use the callbackURL option:

```ts
import { authClient } from "@/lib/auth-client";

await authClient.oneTap({
  callbackURL: "/dashboard"
});
```

#### Handling Prompt Dismissals with Exponential Backoff

If the user dismisses or skips the prompt, the plugin will retry showing the One Tap prompt using exponential backoff based on your configured promptOptions.

If the maximum number of attempts is reached without a successful sign-in, you can use the onPromptNotification callback to be notified—allowing you to render an alternative UI (e.g., a traditional Google Sign-In button) so users can restart the process manually:

```ts
import { authClient } from "@/lib/auth-client";

await authClient.oneTap({
  onPromptNotification: (notification) => {
    console.warn("Prompt was dismissed or skipped. Consider displaying an alternative sign-in option.", notification);
    // Render your alternative UI here
  }
});
```

### Client Options

- `clientId`: The client ID for your Google One Tap API.
- `autoSelect`: Automatically select the account if the user is already signed in. Default is false.
- `cancelOnTapOutside`: Cancel the One Tap popup when the user taps outside it. Note that this option may not have an effect when FedCM is active, as the browser manages the dismiss behavior. Default is true.
- `uxMode`: The mode to use for the Google One Tap flow. Can be "popup" or "redirect". Default is "popup".
- `context`: The context in which the One Tap API should be used. Can be "signin", "signup", or "use". Default is "signin".
- `additionalOptions`: Extra options to pass to Google's initialize method as per the [Google Identity Services docs](https://developers.google.com/identity/gsi/web/reference/js-reference#google.accounts.id.prompt).
- `promptOptions`: Configuration for the prompt behavior and exponential backoff:
  - `baseDelay`: Base delay in milliseconds for retries. Default is 1000.
  - `maxAttempts`: Maximum number of prompt attempts before invoking the `onPromptNotification` callback. Default is 5.
  - `fedCM`: When enabled, calls [`navigator.credentials.preventSilentAccess()`](https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/preventSilentAccess) on sign-out to clear the browser's FedCM credential state. FedCM itself is managed by the Google Identity Services library and cannot be disabled. Default is true.

### Button Mode Options

When using button mode, pass a `button` object to the `oneTap` action with the following properties:

- `container`: The HTML element or CSS selector where the button should be rendered (required)
- `config`: Button configuration options (optional):
  - `type`: Button type - `"standard"` (default) or `"icon"` (icon-only)
  - `theme`: Button theme - `"outline"` (default), `"filled_blue"`, or `"filled_black"`
  - `size`: Button size - `"large"` (default), `"medium"`, or `"small"`
  - `text`: Button text - `"signin_with"` (default), `"signup_with"`, `"continue_with"`, or `"signin"`
  - `shape`: Button shape - `"rectangular"` (default), `"pill"`, `"circle"`, or `"square"`
  - `logo_alignment`: Google logo alignment - `"left"` (default) or `"center"` (for standard button only)
  - `width`: Minimum button width in pixels (max 400)
  - `locale`: Display button using specified language code (e.g., `"zh_CN"`)

### Server Options

- `disableSignUp`: Disable the sign-up option, allowing only existing users to sign in. Default is false.
- `clientId`: Optionally, pass a client ID here if it is not provided in your social provider configuration.

### Authorized JavaScript origins
Ensure you have configured the Authorized JavaScript origins (e.g., http://localhost:3000, https://example.com) for your Client ID in the Google Cloud Console. This is a required step for the Google One Tap API, and it will not function correctly unless your origins are correctly set.
---
title: Single Sign-On (SSO)
description: Integrate Single Sign-On (SSO) with your application.
---

`OIDC` `OAuth2` `SSO` `SAML`

Single Sign-On (SSO) allows users to authenticate with multiple applications using a single set of credentials. This plugin supports OpenID Connect (OIDC), OAuth2 providers, and SAML 2.0.

## Installation

<Steps>
    <Step>
        ### Install the plugin

        ```package-install
        @better-auth/sso
        ```
    </Step>
    <Step>
        ### Add Plugin to the server

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        import { sso } from "@better-auth/sso"; // [!code highlight]

        const auth = betterAuth({
            plugins: [
                sso() // [!code highlight]
            ]
        })
        ```
    </Step>
    <Step>
        ### Migrate the database

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        See the [Schema](#schema) section to add the fields manually.
    </Step>
    <Step>
        ### Add the client plugin

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        import { ssoClient } from "@better-auth/sso/client" // [!code highlight]

        const authClient = createAuthClient({
            plugins: [
                ssoClient() // [!code highlight]
            ]
        })
        ```
    </Step>
</Steps>

## Usage

### Register an OIDC Provider

To register an OIDC provider, use the `registerSSOProvider` endpoint and provide the necessary configuration details for the provider.

A redirect URL will be automatically generated using the provider ID. For instance, if the provider ID is `hydra`, the redirect URL would be `{baseURL}/api/auth/sso/callback/hydra`. Note that `/api/auth` may vary depending on your base path configuration.

<Callout type="info">
If you need all providers to share a single callback URL (e.g., when migrating from another auth provider), see [Shared Redirect URI](#shared-redirect-uri).
</Callout>

<Callout type="info">
When you register an OIDC provider, Better Auth automatically fetches and validates the IdP's [OIDC discovery document](#oidc-discovery). Most endpoint fields are optional — see [OIDC Discovery](#oidc-discovery) for details on auto-discovered fields and possible registration errors.
</Callout>

#### Example

<Tabs items={["client", "server"]}>
    <Tab value="client">
```ts title="register-oidc-provider.ts"
import { authClient } from "@/lib/auth-client";

// Register with OIDC configuration
await authClient.sso.register({
    providerId: "example-provider",
    issuer: "https://idp.example.com",
    domain: "example.com",
    oidcConfig: {
        clientId: "client-id",
        clientSecret: "client-secret",
        authorizationEndpoint: "https://idp.example.com/authorize",
        tokenEndpoint: "https://idp.example.com/token",
        jwksEndpoint: "https://idp.example.com/jwks",
        discoveryEndpoint: "https://idp.example.com/.well-known/openid-configuration",
        scopes: ["openid", "email", "profile"],
        pkce: true,
        mapping: {
            id: "sub",
            email: "email",
            emailVerified: "email_verified",
            name: "name",
            image: "picture",
            extraFields: {
                department: "department",
                role: "role"
            }
        }
    }
});
```
    </Tab>

    <Tab value="server">
```ts title="register-oidc-provider.ts"
const { headers } = await signInWithTestUser();
await auth.api.registerSSOProvider({
    body: {
        providerId: "example-provider",
        issuer: "https://idp.example.com",
        domain: "example.com",
        oidcConfig: {
            clientId: "your-client-id",
            clientSecret: "your-client-secret",
            authorizationEndpoint: "https://idp.example.com/authorize",
            tokenEndpoint: "https://idp.example.com/token",
            jwksEndpoint: "https://idp.example.com/jwks",
            discoveryEndpoint: "https://idp.example.com/.well-known/openid-configuration",
            scopes: ["openid", "email", "profile"],
            pkce: true,
            mapping: {
                id: "sub",
                email: "email",
                emailVerified: "email_verified",
                name: "name",
                image: "picture",
                extraFields: {
                    department: "department",
                    role: "role"
                }
            }
        }
    },
    headers,
});
```
    </Tab>
</Tabs>

### OIDC Discovery

Better Auth automatically fetches and validates the provider's [OpenID Connect Discovery Document](https://openid.net/specs/openid-connect-discovery-1_0.html) from:

```
{issuer}/.well-known/openid-configuration
```

This allows most endpoint-related fields in `oidcConfig` to be **optional** — they will be hydrated automatically from the Identity Provider (IdP).

<APIMethod path="/sso/register" method="POST" requireSession note="Minimal OIDC configuration — endpoints are discovered automatically from the issuer.">
```ts
type registerSSOProvider = {
    /**
     * Unique identifier for the provider
     */
    providerId: string = "okta"
    /**
     * The OIDC issuer URL. Discovery document is fetched from `{issuer}/.well-known/openid-configuration`
     */
    issuer: string = "https://your-org.okta.com"
    /**
     * Email domain for this provider
     */
    domain: string = "yourcompany.com"
    /**
     * OIDC configuration (most fields are auto-discovered)
     */
    oidcConfig: {
        /**
         * OAuth client ID from your IdP
         */
        clientId: string = "your-client-id"
        /**
         * OAuth client secret from your IdP
         */
        clientSecret: string = "your-client-secret"
    }
}
```
</APIMethod>

#### Fields Automatically Discovered

Better Auth fills in the following fields by reading the IdP's discovery document (if not explicitly provided):

- `authorizationEndpoint`
- `tokenEndpoint`
- `jwksEndpoint`
- `userInfoEndpoint`
- `discoveryEndpoint`
- `tokenEndpointAuthentication` (method for token endpoint client authentication)

Following the spec, our discovery process expects all URLs to be valid and to be absolute urls. Relative paths are also supported and resolved relative to the issuer's base URL preserving the path when available.

Example of relative endpoint and issuer without base path:

- `issuer`: `"https://your-org.okta.com"`
- `token_endpoint`: `"/v1/tokens"`
- normalized `token_endpoint`: `"https://your-org.okta.com/v1/tokens"`


Example of relative endpoint and issuer with base path:

- `issuer`: `"https://your-org.okta.com/v1"`
- `token_endpoint`: `"/tokens"`
- normalized `token_endpoint`: `"https://your-org.okta.com/v1/tokens"`

<Callout type="info">
If you explicitly set these fields in `oidcConfig`, your values override the discovered ones.
This is useful when you need to override the IdP's advertised metadata or when using incomplete mock servers.
</Callout>

#### Trusted origins

Both the discovery endpoint as well as any URL resolved through the discovery process are subject to your app's [`trustedOrigins`](/docs/reference/security#trusted-origins) configuration.
Discovery will fail with the `discovery_untrusted_origin` code unless you explicitly update your `trustedOrigins` configuration:

```ts
trustedOrigins: ["https://your-org.okta.com"],
```

If your use-case requires to support multiple arbitrary but known IDPs (e.g Okta), we recommend to:

1. Register a list of well known IDPs ahead of time

```ts
trustedOrigins: [
    "https://your-org.okta.com",
    "https://accounts.google.com",
    "https://login.microsoftonline.com",
    "https://auth0.com",
    "https://idp.example.com"
],
```

2. Or dynamically compute the `trustedOrigins` by specifying a callback function:

```ts
trustedOrigins: async (request) => {
    // request is undefined during initialization and auth.api calls
    if (!request) {
        return ["https://my-frontend.com"];
    }

    // SSO trusted origin list
    if (request.url.endsWith("/sso/register")) {
        const trustedOrigins = await fetchOriginList();
        return trustedOrigins;
    }

    // Your normal origin list for everything else
    return [];
}
```

See the [`trustedOrigins`](/docs/reference/security#trusted-origins) docs for more information.

#### Why Discovery Can Fail

Better Auth validates that the IdP's metadata is correct and complete **before** allowing registration. This prevents subtle runtime failures during sign-in or token validation.

<Callout type="info">
Better Auth does **not** support implicit-only OIDC flows.
For this reason, `token_endpoint` and `jwks_uri` are required even though the OIDC spec allows implicit-only providers to omit `token_endpoint`.
</Callout>

#### Discovery Errors

If the Identity Provider is misconfigured or unreachable, registration will fail with a structured error.

| Error Code | Meaning |
|------------|---------|
| `issuer_mismatch` | The IdP's discovery document reports a different `issuer` than the one you configured |
| `discovery_incomplete` | Required fields (`authorization_endpoint`, `token_endpoint`, `jwks_uri`) are missing |
| `discovery_not_found` | The discovery document endpoint returned 404 |
| `discovery_timeout` | The IdP did not respond within the timeout window (default: 10 seconds) |
| `discovery_invalid_url` | The discovery URL is malformed or uses an unsupported protocol |
| `discovery_untrusted_origin` | The discovery URL or one of the URLs discovered as part of this process was not trusted by your app's trusted origins configuration |
| `discovery_invalid_json` | The discovery response is empty or not valid JSON |
| `unsupported_token_auth_method` | The IdP only supports token auth methods that Better Auth doesn't support |

**Supported token auth methods:**
- `client_secret_basic`
- `client_secret_post`

<Callout type="warning">
If your IdP advertises only unsupported methods (e.g., `private_key_jwt`, `tls_client_auth`, or `"none"` for public clients), you can explicitly override the method:

```ts
oidcConfig: {
    clientId: "your-client-id",
    clientSecret: "your-client-secret",
    tokenEndpointAuthentication: "client_secret_basic", // Override discovery
}
```

This is especially common with mock OIDC servers or development IdPs that only advertise `"none"` as the supported method.
</Callout>

#### Summary

- Better Auth automatically performs OIDC discovery at registration time
- Most endpoint settings in `oidcConfig` become optional
- Explicit user configuration always overrides discovery
- Registration fails fast if the IdP is misconfigured
- Discovery errors are structured and well-defined
- Public-client IdPs or mock servers may require overriding `tokenEndpointAuthentication`

### Register a SAML Provider

To register a SAML provider, use the `registerSSOProvider` endpoint with SAML configuration details. The provider will act as a Service Provider (SP) and integrate with your Identity Provider (IdP).

<Tabs items={["client", "server"]}>
    <Tab value="client">
```ts title="register-saml-provider.ts"
import { authClient } from "@/lib/auth-client";

await authClient.sso.register({
    providerId: "saml-provider",
    issuer: "https://idp.example.com",
    domain: "example.com",
    samlConfig: {
        entryPoint: "https://idp.example.com/sso",
        cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----",
        callbackUrl: "https://yourapp.com/api/auth/sso/saml2/callback/saml-provider",
        audience: "https://yourapp.com",
        wantAssertionsSigned: true,
        signatureAlgorithm: "sha256",
        digestAlgorithm: "sha256",
        identifierFormat: "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress",
        idpMetadata: {
            metadata: "<!-- IdP Metadata XML -->",
            privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            privateKeyPass: "your-private-key-password",
            isAssertionEncrypted: true,
            encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            encPrivateKeyPass: "your-encryption-key-password"
        },
        spMetadata: {
            metadata: "<!-- SP Metadata XML -->",
            binding: "post",
            privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            privateKeyPass: "your-sp-private-key-password",
            isAssertionEncrypted: true,
            encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
            encPrivateKeyPass: "your-sp-encryption-key-password"
        },
        mapping: {
            id: "nameID",
            email: "email",
            name: "displayName",
            firstName: "givenName",
            lastName: "surname",
            emailVerified: "email_verified",
            extraFields: {
                department: "department",
                role: "role"
            }
        }
    }
});
```
    </Tab>

    <Tab value="server">
```ts title="register-saml-provider.ts"
const { headers } = await signInWithTestUser();
await auth.api.registerSSOProvider({
    body: {
        providerId: "saml-provider",
        issuer: "https://idp.example.com",
        domain: "example.com",
        samlConfig: {
            entryPoint: "https://idp.example.com/sso",
            cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----",
            callbackUrl: "https://yourapp.com/api/auth/sso/saml2/callback/saml-provider",
            audience: "https://yourapp.com",
            wantAssertionsSigned: true,
            signatureAlgorithm: "sha256",
            digestAlgorithm: "sha256",
            identifierFormat: "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress",
            idpMetadata: {
                metadata: "<!-- IdP Metadata XML -->",
                privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                privateKeyPass: "your-private-key-password",
                isAssertionEncrypted: true,
                encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                encPrivateKeyPass: "your-encryption-key-password"
            },
            spMetadata: {
                metadata: "<!-- SP Metadata XML -->",
                binding: "post",
                privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                privateKeyPass: "your-sp-private-key-password",
                isAssertionEncrypted: true,
                encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----",
                encPrivateKeyPass: "your-sp-encryption-key-password"
            },
            mapping: {
                id: "nameID",
                email: "email",
                name: "displayName",
                firstName: "givenName",
                lastName: "surname",
                emailVerified: "email_verified",
                extraFields: {
                    department: "department",
                    role: "role"
                }
            }
        }
    },
    headers,
});
```
    </Tab>
</Tabs>

### IdP-Initiated SSO

 For IdP-initiated flows (e.g., via Okta dashboard), your framework may require an explicit route handler to manage the redirect if the default handler doesn't support the `GET` request following the SAML POST.

 <Tabs items={["next-js-app-router"]}>
   <Tab value="next-js-app-router">
     Create this file to prevent 404 errors:

     ```ts title="app/api/auth/sso/saml2/callback/[providerId]/route.ts"
     import { auth } from "@/lib/auth";
     import { NextResponse } from "next/server";

     export async function POST(req: Request) {
         return auth.handler(req);
     }

     export async function GET(req: Request) {
         // Required: IdP-initiated flows redirect to this URL after POST
         return NextResponse.redirect(new URL("/", req.url));
     }
     ```
   </Tab>
</Tabs>

### Get Service Provider Metadata

For SAML providers, you can retrieve the Service Provider metadata XML that needs to be configured in your Identity Provider:

```ts title="get-sp-metadata.ts"
const response = await auth.api.spMetadata({
    query: {
        providerId: "saml-provider",
        format: "xml" // or "json"
    }
});

const metadataXML = await response.text();
console.log(metadataXML);
```

### Sign In with SSO

To sign in with an SSO provider, you can call `signIn.sso`

You can sign in using the email with domain matching:

```ts title="sign-in.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    email: "user@example.com",
    callbackURL: "/dashboard",
});
```

or you can specify the domain:

```ts title="sign-in-domain.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    domain: "example.com",
    callbackURL: "/dashboard",
});
```

You can also sign in using the organization slug if a provider is associated with an organization:

```ts title="sign-in-org.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    organizationSlug: "example-org",
    callbackURL: "/dashboard",
});
```

Alternatively, you can sign in using the provider's ID:

```ts title="sign-in-provider-id.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    providerId: "example-provider-id",
    callbackURL: "/dashboard",
});
```

Optionally, you can pass a login hint (for example, an email address or another identifier) to prefill or direct the identity provider:

```ts title="sign-in-with-login-hint.ts"
import { authClient } from "@/lib/auth-client"

const res = await authClient.signIn.sso({
    providerId: "example-provider-id",
    loginHint: "user@example.com",
    callbackURL: "/dashboard",
});
```

To use the server API you can use `signInSSO`

```ts title="sign-in-org.ts"
import { authClient } from "@/lib/auth-client"

const res = await auth.api.signInSSO({
    body: {
        organizationSlug: "example-org",
        callbackURL: "/dashboard",
    }
});
```

#### Full method

<APIMethod path="/sign-in/sso" method="POST">
```ts
type signInSSO = {
    /**
     * The email address to sign in with. This is used to identify the issuer to sign in with. It's optional if the issuer is provided. 
     */
    email?: string = "john@example.com"
    /**
     * The slug of the organization to sign in with. 
     */
    organizationSlug?: string = "example-org"
    /**
     * The ID of the provider to sign in with. This can be provided instead of email or issuer. 
     */
    providerId?: string = "example-provider"
    /**
     * The domain of the provider. 
     */
    domain?: string = "example.com"
    /**
     * The URL to redirect to after login. 
     */
    callbackURL: string = "https://example.com/callback"
    /**
     * The URL to redirect to after login. 
     */
    errorCallbackURL?: string = "https://example.com/callback"
    /**
     * The URL to redirect to after login if the user is new. 
     */
    newUserCallbackURL?: string = "https://example.com/new-user"
    /**
     * Scopes to request from the provider. 
     */
    scopes?: string[] = ["openid", "email", "profile", "offline_access"]
    /**
     * Login hint to send to the identity provider (e.g., email or identifier). 
     */
    loginHint?: string = "user@example.com"
    /**
     * Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. 
     */
    requestSignUp?: boolean = true
}
```
</APIMethod>

Note: If email is provided and loginHint is not specified, email will be sent as the login_hint to OIDC providers automatically. SAML flows do not support login_hint.

When a user is authenticated, if the user does not exist, the user will be provisioned using the `provisionUser` function. If the organization provisioning is enabled and a provider is associated with an organization, the user will be added to the organization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            provisionUser: async (user) => {
                // provision user
            },
            organizationProvisioning: {
                disabled: false,
                defaultRole: "member",
                getRole: async (user) => {
                    // get role if needed
                },
            },
        }),
    ],
});
```

## Provisioning

The SSO plugin provides powerful provisioning capabilities to automatically set up users and manage their organization memberships when they sign in through SSO providers.

### User Provisioning

User provisioning allows you to run custom logic whenever a user signs in through an SSO provider. This is useful for:

- Setting up user profiles with additional data from the SSO provider
- Synchronizing user attributes with external systems
- Creating user-specific resources
- Logging SSO sign-ins
- Updating user information from the SSO provider

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            provisionUser: async ({ user, userInfo, token, provider }) => {
                // Update user profile with SSO data
                await updateUserProfile(user.id, {
                    department: userInfo.attributes?.department,
                    jobTitle: userInfo.attributes?.jobTitle,
                    manager: userInfo.attributes?.manager,
                    lastSSOLogin: new Date(),
                });

                // Create user-specific resources
                await createUserWorkspace(user.id);

                // Sync with external systems
                await syncUserWithCRM(user.id, userInfo);

                // Log the SSO sign-in
                await auditLog.create({
                    userId: user.id,
                    action: 'sso_signin',
                    provider: provider.providerId,
                    metadata: {
                        email: userInfo.email,
                        ssoProvider: provider.issuer,
                    },
                });
            },
        }),
    ],
});
```

The `provisionUser` function receives:
- **user**: The user object from the database
- **userInfo**: User information from the SSO provider (includes attributes, email, name, etc.)
- **token**: OAuth2 tokens (for OIDC providers) - may be undefined for SAML
- **provider**: The SSO provider configuration

### Organization Provisioning

Organization provisioning automatically manages user memberships in organizations when SSO providers are linked to specific organizations. This is particularly useful for:

- Enterprise SSO where each company/domain maps to an organization
- Automatic role assignment based on SSO attributes
- Managing team memberships through SSO

#### Basic Organization Provisioning

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            organizationProvisioning: {
                disabled: false,           // Enable org provisioning
                defaultRole: "member",     // Default role for new members
            },
        }),
    ],
});
```

#### Advanced Organization Provisioning with Custom Roles

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            organizationProvisioning: {
                disabled: false,
                defaultRole: "member",
                getRole: async ({ user, userInfo, provider }) => {
                    // Assign roles based on SSO attributes
                    const department = userInfo.attributes?.department;
                    const jobTitle = userInfo.attributes?.jobTitle;
                    
                    // Admins based on job title
                    if (jobTitle?.toLowerCase().includes('manager') || 
                        jobTitle?.toLowerCase().includes('director') ||
                        jobTitle?.toLowerCase().includes('vp')) {
                        return "admin";
                    }
                    
                    // Special roles for IT department
                    if (department?.toLowerCase() === 'it') {
                        return "admin";
                    }
                    
                    // Default to member for everyone else
                    return "member";
                },
            },
        }),
    ],
});
```

#### Linking SSO Providers to Organizations

When registering an SSO provider, you can link it to a specific organization:

```ts title="register-org-provider.ts"
import { auth } from "@/lib/auth"

await auth.api.registerSSOProvider({
    body: {
        providerId: "acme-corp-saml",
        issuer: "https://acme-corp.okta.com",
        domain: "acmecorp.com",
        organizationId: "org_acme_corp_id", // Link to organization
        samlConfig: {
            // SAML configuration...
        },
    },
    headers: await headers() // headers containing the user's session token
});
```

Now when users from `acmecorp.com` sign in through this provider, they'll automatically be added to the "Acme Corp" organization with the appropriate role.

#### Multiple Organizations Example

You can set up multiple SSO providers for different organizations:

```ts title="multi-org-setup.ts"
import { auth } from "@/lib/auth"

// Acme Corp SAML provider
await auth.api.registerSSOProvider({
    body: {
        providerId: "acme-corp",
        issuer: "https://acme.okta.com",
        domain: "acmecorp.com",
        organizationId: "org_acme_id",
        samlConfig: { /* ... */ },
    },
    headers,
});

// TechStart OIDC provider
await auth.api.registerSSOProvider({
    body: {
        providerId: "techstart-google",
        issuer: "https://accounts.google.com",
        domain: "techstart.io",
        organizationId: "org_techstart_id",
        oidcConfig: { /* ... */ },
    },
    headers,
});
```

#### Organization Provisioning Flow

1. **User signs in** through an SSO provider linked to an organization
2. **User is authenticated** and either found or created in the database
3. **Organization membership is checked** - if the user isn't already a member of the linked organization
4. **Role is determined** using either the `defaultRole` or `getRole` function
5. **User is added** to the organization with the determined role
6. **User provisioning runs** (if configured) for additional setup

### Provisioning Best Practices

#### 1. Idempotent Operations
Make sure your provisioning functions can be safely run multiple times:

```ts
provisionUser: async ({ user, userInfo }) => {
    // Check if already provisioned
    const existingProfile = await getUserProfile(user.id);
    if (!existingProfile.ssoProvisioned) {
        await createUserResources(user.id);
        await markAsProvisioned(user.id);
    }
    
    // Always update attributes (they might change)
    await updateUserAttributes(user.id, userInfo.attributes);
},
```

#### 2. Error Handling
Handle errors gracefully to avoid blocking user sign-in:

```ts
provisionUser: async ({ user, userInfo }) => {
    try {
        await syncWithExternalSystem(user, userInfo);
    } catch (error) {
        // Log error but don't throw - user can still sign in
        console.error('Failed to sync user with external system:', error);
        await logProvisioningError(user.id, error);
    }
},
```

#### 3. Conditional Provisioning
Only run certain provisioning steps when needed:

```ts
organizationProvisioning: {
    disabled: false,
    getRole: async ({ user, userInfo, provider }) => {
        // Only process role assignment for certain providers
        if (provider.providerId.includes('enterprise')) {
            return determineEnterpriseRole(userInfo);
        }
        return "member";
    },
},
```

## SAML Configuration


### Default SSO Provider

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            defaultSSO: [
                {
                    providerId: "default-saml", // Provider ID for the default provider
                    domain: "http://your-app.com",
                    samlConfig: {
                        issuer: "https://your-app.com",
                        entryPoint: "https://idp.example.com/sso",
                        cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----",
                        callbackUrl: "http://localhost:3000/api/auth/sso/saml2/sp/acs",
                        spMetadata: {
                            entityID: "http://localhost:3000/api/auth/sso/saml2/sp/metadata",
                            metadata: "<!-- Your SP Metadata XML -->",
                        }
                    }
                }
            ]
        })
    ]
});
```

The defaultSSO provider will be used when:
1. No matching provider is found in the database

This allows you to test SAML authentication without setting up providers in the database. The defaultSSO provider supports all the same configuration options as regular SAML providers.

### Service Provider Configuration

When registering a SAML provider, you need to provide Service Provider (SP) metadata configuration:

- **metadata**: XML metadata for the Service Provider
- **binding**: The binding method, typically "post" or "redirect"
- **privateKey**: Private key for signing AuthnRequests
- **privateKeyPass**: Password for the private key
- **isAssertionEncrypted**: Whether assertions should be encrypted
- **encPrivateKey**: Private key for decryption (if encryption is enabled)
- **encPrivateKeyPass**: Password for the encryption private key

### Signed AuthnRequests

Some enterprise IdPs (Okta, Azure AD, ADFS) require signed AuthnRequests. Enable this with:

```ts
samlConfig: {
    // ... other config
    authnRequestsSigned: true,
    spMetadata: {
        privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...",
    }
}
```

The SP metadata endpoint will automatically include `AuthnRequestsSigned="true"` when enabled.

### Identity Provider Configuration

You also need to provide Identity Provider (IdP) configuration:

- **metadata**: XML metadata from your Identity Provider
- **privateKey**: Private key for the IdP communication (optional)
- **privateKeyPass**: Password for the IdP private key (if encrypted)
- **isAssertionEncrypted**: Whether assertions from IdP are encrypted
- **encPrivateKey**: Private key for IdP assertion decryption
- **encPrivateKeyPass**: Password for the IdP decryption key

### SAML Attribute Mapping

Configure how SAML attributes map to user fields:

```ts
mapping: {
    id: "nameID",           // Default: "nameID"
    email: "email",         // Default: "email" or "nameID"
    name: "displayName",    // Default: "displayName"
    firstName: "givenName", // Default: "givenName"
    lastName: "surname",    // Default: "surname"
    extraFields: {
        department: "department",
        role: "jobTitle",
        phone: "telephoneNumber"
    }
}
```

## SAML Security

The SSO plugin includes optional security features to protect against common SAML vulnerabilities.

### AuthnRequest / InResponseTo Validation

You can enable InResponseTo validation for SP-initiated SAML flows. When enabled, the plugin tracks AuthnRequest IDs and validates the `InResponseTo` attribute in SAML responses. This prevents:

- **Unsolicited responses**: Responses not triggered by a legitimate login request
- **Replay attacks**: Reusing old SAML responses
- **Cross-provider injection**: Responses meant for a different provider

<Callout type="info">
This feature is **opt-in** to ensure backward compatibility. Enable it explicitly for enhanced security.
</Callout>

#### Enabling Validation (Single Instance)

For single-instance deployments, enable validation with the built-in in-memory store:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            saml: {
                // Enable InResponseTo validation
                enableInResponseToValidation: true,
                // Optionally reject IdP-initiated SSO (stricter security)
                allowIdpInitiated: false,
                // Custom TTL for AuthnRequest validity (default: 5 minutes)
                requestTTL: 10 * 60 * 1000, // 10 minutes
            },
        }),
    ],
});
```

#### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enableInResponseToValidation` | `boolean` | `false` | Enable InResponseTo validation for SP-initiated flows. |
| `allowIdpInitiated` | `boolean` | `true` | Allow IdP-initiated SSO (responses without InResponseTo). Set to `false` for stricter security. Only applies when validation is enabled. |
| `requestTTL` | `number` | `300000` (5 min) | Time-to-live for AuthnRequest records in milliseconds. Requests older than this will be rejected. |

#### Error Handling

When InResponseTo validation fails, users are redirected with an error query parameter:

- `?error=invalid_saml_response&error_description=Unknown+or+expired+request+ID` — The request ID was not found or has expired
- `?error=invalid_saml_response&error_description=Provider+mismatch` — The response was meant for a different provider
- `?error=unsolicited_response&error_description=IdP-initiated+SSO+not+allowed` — IdP-initiated SSO is disabled

### Assertion Replay Protection

The SSO plugin includes assertion replay protection to prevent attackers from capturing and resubmitting valid SAML responses. Each SAML Assertion ID is tracked and rejected if reused.

<Callout type="info">
Replay protection is **always enabled**. This is a critical security feature that prevents attackers from reusing intercepted SAML responses.
</Callout>

#### How It Works

1. When a SAML response is received, the Assertion ID is extracted from the XML
2. The system checks if this Assertion ID has been seen before
3. If it's a new assertion, it's stored in the database until its `NotOnOrAfter` expiration
4. If it's a duplicate (replay attack), the request is rejected

**Both SAML endpoints are protected:**
- `/sso/saml2/callback/:providerId`
- `/sso/saml2/sp/acs/:providerId`

<Callout type="info">
Replay protection uses the database verification table, so it works correctly in multi-instance deployments without additional configuration.
</Callout>

#### Error Handling

When a replay attack is detected, users are redirected with an error:

- `?error=replay_detected&error_description=SAML+assertion+has+already+been+used` — The assertion ID was already used

### Timestamp Validation

The SSO plugin validates SAML assertion timestamps (`NotBefore` and `NotOnOrAfter`) to prevent acceptance of expired or future-dated assertions. This validation includes a configurable clock skew tolerance to account for time differences between servers.

#### SAML Specification Background

According to the **SAML 2.0 Core specification**, `NotBefore` and `NotOnOrAfter` attributes are **optional**. However, the widely-adopted **SAML2Int** (SAML V2.0 Implementation Profile for Federation Interoperability) specification **requires** these timestamps:

> "The Identity Provider MUST include a `<saml:Conditions>` element. Conditions restricting the period when the assertion is valid, the `@NotBefore` and `@NotOnOrAfter` MUST be included."

Better Auth provides flexibility to support both:
- **Default behavior**: Accepts assertions without timestamps (SAML 2.0 Core compliant) but logs a warning
- **Strict mode**: Rejects assertions without timestamps (SAML2Int compliant)

#### How It Works

For each SAML assertion:
- **NotBefore**: The assertion is rejected if current time is before `NotBefore - clockSkew`
- **NotOnOrAfter**: The assertion is rejected if current time is after `NotOnOrAfter + clockSkew`

#### Configuration

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            saml: {
                // Clock skew tolerance (default: 5 minutes)
                clockSkew: 5 * 60 * 1000,
                // Require timestamps in assertions (default: false)
                requireTimestamps: false,
            },
        }),
    ],
});
```

#### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `clockSkew` | `number` | `300000` (5 min) | Clock skew tolerance in milliseconds. Allows for time differences between IdP and SP servers. |
| `requireTimestamps` | `boolean` | `false` | When `true`, assertions without `NotBefore`/`NotOnOrAfter` conditions are rejected. When `false`, they are accepted but a warning is logged. |

#### When to Enable `requireTimestamps`

<Callout type="info">
**Recommendation**: Enable `requireTimestamps: true` for enterprise and high-security deployments.
</Callout>

Enable `requireTimestamps: true` when:
- Your IdP follows **SAML2Int** (most enterprise IdPs like Okta, Azure AD, OneLogin)
- You need **SOC 2**, **ISO 27001**, or similar compliance
- You want to prevent acceptance of malformed or test assertions
- You're in a **production environment** with proper IdP configuration

Keep `requireTimestamps: false` (default) when:
- Integrating with **legacy IdPs** that may not include timestamps
- During **development/testing** with mock IdPs
- You need **maximum compatibility** with various IdP implementations

#### Stricter Security (Enterprise/Production)

For enterprise environments following SAML2Int, configure stricter validation:

```ts title="auth.ts"
sso({
    saml: {
        clockSkew: 60 * 1000,      // 1 minute tolerance
        requireTimestamps: true,   // Reject assertions without timestamps (SAML2Int)
    },
})
```

#### Error Messages

- **"SAML assertion is not yet valid"** — Current time is before the `NotBefore` timestamp (minus clock skew)
- **"SAML assertion has expired"** — Current time is after the `NotOnOrAfter` timestamp (plus clock skew)
- **"SAML assertion missing required timestamp conditions"** — Assertion has no timestamps and `requireTimestamps` is enabled

### Algorithm Validation

Better Auth validates SAML cryptographic algorithms and warns about deprecated ones (SHA-1, RSA 1.5, 3DES) by default.

```ts title="auth.ts"
sso({
    saml: {
        algorithms: {
            // "warn" (default) | "reject" | "allow"
            onDeprecated: "warn",
        },
    },
})
```

| Value | Behavior |
|-------|----------|
| `"warn"` | Log warning, allow authentication (default) |
| `"reject"` | Throw error, block authentication |
| `"allow"` | Silent, no validation |

For strict security (production):

```ts title="auth.ts"
sso({
    saml: {
        algorithms: {
            onDeprecated: "reject",
        },
    },
})
```

#### Supported Algorithms

**Signature algorithms:**
- `RSA-SHA256`, `RSA-SHA384`, `RSA-SHA512`
- `ECDSA-SHA256`, `ECDSA-SHA384`, `ECDSA-SHA512`

**Digest algorithms:**
- `SHA256`, `SHA384`, `SHA512`

**Deprecated (triggers warning/rejection):**
- `RSA-SHA1` (signature)
- `SHA1` (digest)
- `RSA 1.5` (key encryption)
- `3DES` (data encryption)

### Size Limits

Better Auth enforces size limits on SAML payloads to protect against denial-of-service attacks via oversized XML.

| Option | Default | Description |
|--------|---------|-------------|
| `maxResponseSize` | 256KB | Maximum SAML response size in bytes |
| `maxMetadataSize` | 100KB | Maximum IdP metadata size in bytes |

#### Customizing Limits

```ts title="auth.ts"
sso({
    saml: {
        maxResponseSize: 512 * 1024, // 512KB for enterprise IdPs with large group claims
        maxMetadataSize: 100 * 1024, // 100KB
    },
})
```

<Callout type="info">
For true early rejection of oversized payloads (before they reach your application), configure size limits at your infrastructure level (nginx `client_max_body_size`, CDN settings, load balancer).
</Callout>

## Shared Redirect URI

By default, each OIDC provider gets its own callback URL (`/sso/callback/:providerId`). You can configure all providers to share a single redirect URI instead:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({
            redirectURI: "/sso/callback" // [!code highlight]
        })
    ]
});
```

The value can be a relative path or a full URL:

```ts
// Relative path (appended to your baseURL)
sso({ redirectURI: "/sso/callback" })

// Full URL
sso({ redirectURI: "https://login.example.com/callback" })
```

The provider ID is stored in the OAuth state so the callback can identify which provider initiated the flow.

<Callout type="info">
When using a full URL, make sure it routes to your Better Auth instance.
</Callout>

<Callout type="info">
This option only affects OIDC providers. SAML providers already support custom callback URLs via `callbackUrl` in `samlConfig`.
</Callout>

<Callout type="info">
Both the shared endpoint (`/sso/callback`) and the per-provider endpoints (`/sso/callback/:providerId`) are always registered for backward compatibility, so existing integrations continue to work regardless of this setting.
</Callout>

## Domain verification

Domain verification allows your application to automatically trust a new SSO provider
by automatically validating ownership via the associated domain.

When a provider's domain is verified, it is also trusted for **automatic account linking**. This means that if a user signs in with an SSO provider (OIDC or SAML) and an existing account with the same email exists, the accounts will be linked automatically — as long as the user's email domain matches the provider's verified domain.

<Tabs items={["client", "server"]}>
    <Tab value="client">
```ts title="auth-client.ts"
const authClient = createAuthClient({
    plugins: [
        ssoClient({ // [!code highlight]
            domainVerification: { // [!code highlight]
                enabled: true // [!code highlight]
            } // [!code highlight]
        }) // [!code highlight]
    ]
})
```
    </Tab>

    <Tab value="server">
```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sso } from "@better-auth/sso";

const auth = betterAuth({
    plugins: [
        sso({ // [!code highlight]
            domainVerification: { // [!code highlight]
                enabled: true // [!code highlight]
            } // [!code highlight]
        }) // [!code highlight]
    ]
});
```
    </Tab>
</Tabs>

Once enabled, make sure you migrate the database schema (again).

<Tabs items={["migrate", "generate"]}>
    <Tab value="migrate">
    ```bash
    npx auth migrate
    ```
    </Tab>
    <Tab value="generate">
    ```bash
    npx auth generate
    ```
    </Tab>
</Tabs>

See the [Schema](#if-you-have-enabled-domain-verification) section to add the fields manually.

### Verify your domain

When domain verification is enabled, every new SSO provider will be untrusted at first.
This means that new sign-ups or sign-ins will be allowed until the domain ownership has been verified.

To verify your ownership over a domain, follow these steps:

<Steps>
    <Step>
#### Acquire verification token
When an SSO provider is registered, a **verification token** will be issued to the provider (it will be returned as part of the response).
You can use this token to prove ownership over the domain.
    </Step>
    <Step>
#### Create `TXT` DNS record
To do this, you'll need to add a `TXT` record to your domain's DNS settings:

    *   **Host:** `_better-auth-token-{your-provider-id}` (**Note:** An underscore is automatically prepended to follow DNS infrastructure subdomain conventions. The `better-auth-token` part can be customized through the `domainVerification.tokenPrefix` option)
    *   **Value:** The verification token you were given.

**Save the record and wait for it to propagate.** This can take up to 48 hours, but it's usually much faster.
    </Step>
    <Step>
#### Submit a validation request
**Once the DNS record has propagated**, you can submit a validation request (See below)
    </Step>
</Steps>

### Domain validation request

Once you have configured your domain, you can use your `auth` instance to submit a validation request.
This request will either result in a rejection (could not prove your ownership over the domain)
or if the verification is successful, your SSO provider domain will be marked as verified.

<APIMethod path="/sso/verify-domain" method="POST" requireSession>
```ts
type verifyDomain = {
  /**
  * The provider id
  */
  providerId: string = "acme-corp"
}
```
</APIMethod>

### Creating a new verification token

Every domain verification token will have a default expiry of 1 week since the moment it was issued
or the moment when the SSO provider was registered.

After that time, the token will expire and cannot longer be used. When that happens,
you can create a new verification token:

<APIMethod path="/sso/request-domain-verification" method="POST" requireSession>
```ts
type requestDomainVerification = {
  /**
  * The provider id
  */
  providerId: string = "acme-corp"
}
```
</APIMethod>

### SAML Endpoints

The plugin automatically creates the following SAML endpoints:

- **SP Metadata**: `/api/auth/sso/saml2/sp/metadata?providerId={providerId}`
- **SAML Callback**: `/api/auth/sso/saml2/callback/{providerId}` (supports both GET and POST)

### SAML Callback URL Configuration

The SAML callback endpoint (`/api/auth/sso/saml2/callback/{providerId}`) handles both **SP-initiated** and **IdP-initiated** SSO flows:

- **SP-initiated**: User clicks "Sign in with SSO" in your app → redirects to IdP → IdP POSTs SAMLResponse to callback
- **IdP-initiated**: User clicks app icon in IdP dashboard (Okta, Azure AD, etc.) → IdP POSTs SAMLResponse to callback

**Important**: The `callbackUrl` in your SAML configuration should point to your application's destination URL (e.g., `/dashboard`), **not** the callback route itself. Better Auth automatically handles the callback route and redirects users to your specified `callbackUrl` after successful authentication.

```ts
samlConfig: {
  callbackUrl: "/dashboard", // Correct - points to your app destination
  // callbackUrl: "/api/auth/sso/saml2/callback/my-provider" // Incorrect - don't point to callback route
}
```

The callback route supports both GET and POST methods automatically, so you don't need to create any additional route handlers in your framework.

## Schema

The plugin requires additional fields in the `ssoProvider` table to store the provider's configuration.

<DatabaseTable
    fields={[
        {
            name: "id", type: "string", description: "A database identifier", isRequired: true, isPrimaryKey: true,
        },
        { name: "issuer", type: "string", description: "The issuer identifier", isRequired: true },
        { name: "domain", type: "string", description: "The domain of the provider", isRequired: true },
        { name: "oidcConfig", type: "string", description: "The OIDC configuration (JSON string)", isRequired: false },
        { name: "samlConfig", type: "string", description: "The SAML configuration (JSON string)", isRequired: false },
        { name: "userId", type: "string", description: "The user ID", isRequired: true, references: { model: "user", field: "id" } },
        { name: "providerId", type: "string", description: "The provider ID. Used to identify a provider and to generate a redirect URL.", isRequired: true, isUnique: true },
        { name: "organizationId", type: "string", description: "The organization Id. If provider is linked to an organization.", isRequired: false }
    ]}
/>

### If you have enabled domain verification:

The `ssoProvider` schema is extended as follows:

<DatabaseTable
    fields={[
        { name: "domainVerified", type: "boolean", description: "A flag indicating whether the provider domain has been verified.", isRequired: false },
    ]}
/>

### IdP-Initiated SAML SSO

Better Auth supports **IdP-initiated SSO flows**, where users access your application directly from their Identity Provider dashboard (e.g., Okta, Azure AD, OneLogin). This is common in enterprise environments where IT admins prefer centralized app access.

**How it works:**

1. User clicks your app icon in the IdP dashboard
2. IdP POSTs SAMLResponse to `/api/auth/sso/saml2/callback/{providerId}`
3. Better Auth processes the assertion, creates a session, and redirects to your `callbackUrl`
4. Browser follows the redirect with a GET request (handled automatically)

**No additional configuration required** - the callback route automatically handles both GET and POST requests.

<Callout type="info">
If you previously created a manual GET handler for the SAML callback route as a workaround, you can remove it after upgrading. Better Auth now handles GET requests automatically.
</Callout>

<Callout type="info">
**Security:** Better Auth validates all redirect URLs to prevent open redirect attacks. Only relative paths (e.g., `/dashboard`) and URLs matching your configured `trustedOrigins` are allowed. Malicious URLs like `https://evil.com` or protocol-relative URLs (`//evil.com`) are automatically blocked.
</Callout>

For a detailed guide on setting up SAML SSO with examples for Okta and testing with DummyIDP, see our [SAML SSO with Okta](/docs/guides/saml-sso-with-okta).

## Options

### Server

**provisionUser**: A custom function to provision a user when they sign in with an SSO provider.

**organizationProvisioning**: Options for provisioning users to an organization.

**defaultOverrideUserInfo**: Override user info with the provider info by default.

**disableImplicitSignUp**: Disable implicit sign up for new users.

If you want to allow account linking for specific trusted providers, enable the `accountLinking` option in your auth config and specify those providers in the `trustedProviders` list.

<TypeTable
  type={{
    provisionUser: {
        description: "A custom function to provision a user when they sign in with an SSO provider.",
        type: "function",
    },
    organizationProvisioning: {
        description: "Options for provisioning users to an organization.",
        type: "object",
        properties: {
            disabled: {
                description: "Disable organization provisioning.",
                type: "boolean",
                default: false,
            },
            defaultRole: {
                description: "The default role for new users.",
                type: "string",
                enum: ["member", "admin"],
                default: "member",
            },
            getRole: {
                description: "A custom function to determine the role for new users.",
                type: "function",
            },
        },
    },
    defaultOverrideUserInfo: {
        description: "Override user info with the provider info by default.",
        type: "boolean",
        default: false,
    },
    disableImplicitSignUp: {
        description: "Disable implicit sign up for new users. When set to true, sign-in needs to be called with requestSignUp as true to create new users.",
        type: "boolean",
        default: false,
    },
    providersLimit: {
        description: "Configure the maximum number of SSO providers a user can register. Set to 0 to disable SSO provider registration.",
        type: "number | function",
        default: 10,
    },
    redirectURI: {
        description: "Custom redirect URI for OIDC SSO callbacks. When set, all OIDC providers share this single callback URL instead of per-provider URLs. The provider ID is stored in the OAuth state. Can be a relative path (e.g., '/sso/callback') or a full URL.",
        type: "string",
        required: false,
    },
    domainVerification: {
        description: "Configure the domain verification feature",
        type: "object",
        properties: {
            enabled: {
                description: "Enables or disables the domain verification feature",
                type: "boolean",
                required: false
            },
            tokenPrefix: {
                description: "Prefix used to generate the domain verification identifier. An underscore is automatically prepended.",
                type: "string",
                required: false,
                default: "better-auth-token"
            },
        },
    },
    defaultSSO: {
        description: "Configure a default SSO provider for testing and development. This provider will be used when no matching provider is found in the database.",
        type: "array",
        items: {
            type: "object",
            properties: {
                domain: {
                    description: "The domain to match for this default provider.",
                    type: "string",
                    required: true,
                },
                providerId: {
                    description: "The provider ID to use for the default provider.",
                    type: "string",
                    required: true,
                },
                samlConfig: {
                    description: "SAML configuration for the default provider.",
                    type: "SAMLConfig",
                    required: false,
                },
                oidcConfig: {
                    description: "OIDC configuration for the default provider.",
                    type: "OIDCConfig",
                    required: false,
                },
            }
        },
    },
    saml: {
        description: "SAML security options for AuthnRequest/InResponseTo validation, replay protection, and timestamp handling.",
        type: "object",
        properties: {
            enableInResponseToValidation: {
                description: "Enable InResponseTo validation for SP-initiated SAML flows. Opt-in for backward compatibility.",
                type: "boolean",
                default: false,
            },
            allowIdpInitiated: {
                description: "Allow IdP-initiated SSO (unsolicited SAML responses). Set to false for stricter security. Only applies when validation is enabled.",
                type: "boolean",
                default: true,
            },
            requestTTL: {
                description: "TTL for AuthnRequest records in milliseconds. Only applies when validation is enabled.",
                type: "number",
                default: 300000,
            },
            clockSkew: {
                description: "Clock skew tolerance for SAML assertion timestamp validation (NotBefore/NotOnOrAfter) in milliseconds. Allows for minor time differences between IdP and SP servers.",
                type: "number",
                default: 300000,
            },
            requireTimestamps: {
                description: "Require timestamp conditions (NotBefore/NotOnOrAfter) in SAML assertions. When enabled, assertions without timestamps are rejected. When disabled, they are accepted with a warning logged.",
                type: "boolean",
                default: false,
            },
            algorithms: {
                description: "Algorithm validation options.",
                type: "object",
                properties: {
                    onDeprecated: {
                        description: "Behavior for deprecated algorithms (SHA-1, RSA 1.5, 3DES).",
                        type: "string",
                        enum: ["reject", "warn", "allow"],
                        default: "warn",
                    },
                },
            },
            maxResponseSize: {
                description: "Maximum allowed size for SAML responses in bytes.",
                type: "number",
                default: 262144,
            },
            maxMetadataSize: {
                description: "Maximum allowed size for IdP metadata XML in bytes.",
                type: "number",
                default: 102400,
            },
        },
    },
    modelName: {
        description: "The model name for the SSO provider table",
        type: "string",
        default: "ssoProvider"
    },
    fields: {
        issuer: {
            description: "Custom name for the issuer column",
            type: "string",
            default: "issuer",
        },
		oidcConfig: {
            description: "Custom name for the oidcConfig column",
            type: "string",
            default: "oidcConfig",
        },
		samlConfig: {
            description: "Custom name for the samlConfig column",
            type: "string",
            default: "samlConfig",
        },
		userId: {
            description: "Custom name for the userId column",
            type: "string",
            default: "userId",
        },
		providerId: {
            description: "Custom name for the providerId column",
            type: "string",
            default: "providerId",
        },
		organizationId: {
            description: "Custom name for the organizationId column",
            type: "string",
            default: "organizationId",
        },
		domain: {
            description: "Custom name for the domain column",
            type: "string",
            default: "domain",
        }
    }
  }}
/>
---
title: Open API
description: Open API reference for Better Auth.
---

This is a plugin that provides an Open API reference for Better Auth. It shows all endpoints added by plugins and the core. It also provides a way to test the endpoints. It uses [Scalar](https://scalar.com/) to display the Open API reference.


<Callout>
This plugin is still in the early stages of development. We are working on adding more features to it and filling in the gaps.
</Callout>


## Installation

<Steps>
    <Step>
    ### Add the plugin to your **auth** config
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { openAPI } from "better-auth/plugins" // [!code highlight]

    export const auth = betterAuth({
        plugins: [
            openAPI(), // [!code highlight]
        ]
    })
    ```
    </Step>
    <Step>
    ### Navigate to `/api/auth/reference` to view the Open API reference
    
    Each plugin endpoints are grouped by the plugin name. The core endpoints are grouped under the `Default` group. And Model schemas are grouped under the `Models` group.

    ![Open API reference](/open-api-reference.png)
    </Step>
</Steps>    



## Usage 

The Open API reference is generated using the [OpenAPI 3.0](https://swagger.io/specification/) specification. You can use the reference to generate client libraries, documentation, and more.

The reference is generated using the [Scalar](https://scalar.com/) library. Scalar provides a way to view and test the endpoints. You can test the endpoints by clicking on the `Try it out` button and providing the required parameters.

![Open API reference](/open-api-reference.png)

### Generated Schema

To get the generated Open API schema directly as JSON, you can do `auth.api.generateOpenAPISchema()`. This will return the Open API schema as a JSON object.

```ts
import { auth } from "@/lib/auth"

const openAPISchema = await auth.api.generateOpenAPISchema()
console.log(openAPISchema)
```

### Using Scalar with Multiple Sources

If you're using Scalar for your API documentation, you can add Better Auth as an additional source alongside your main API:

When using Hono with Scalar for OpenAPI documentation, you can integrate Better Auth by adding it as a source:

```ts
app.get("/docs", Scalar({
  pageTitle: "API Documentation", 
  sources: [
    { url: "/api/open-api", title: "API" },
    // Better Auth schema generation endpoint
    { url: "/api/auth/open-api/generate-schema", title: "Auth" },
  ],
}));
```

## Configuration

`path` - The path where the Open API reference is served. Default is `/api/auth/reference`. You can change it to any path you like, but keep in mind that it will be appended to the base path of your auth server.

`disableDefaultReference` - If set to `true`, the default Open API reference UI by Scalar will be disabled. Default is `false`.

This allows you to display both your application's API and Better Auth's authentication endpoints in a unified documentation interface.

`theme` - Allows you to change the theme of the OpenAPI reference page. Default is `default`.

`nonce` - Allows you to pass a nonce string to the inline scripts for Content Security Policy (CSP) compliance. Default is `undefined`.
---
title: MCP
description: MCP provider plugin for Better Auth
---

`OAuth` `MCP`

<Callout type="warn">
This plugin will soon be deprecated in favor of the [OAuth Provider Plugin](/docs/plugins/oauth-provider).
</Callout>

The **MCP** plugin lets your app act as an OAuth provider for MCP clients. It handles authentication and makes it easy to issue and manage access tokens for MCP applications.

<Callout type="warn">
This plugin is based on OIDC Provider plugin. It's currently not ready for production use. We are working on it and will update this documentation when it's ready.
</Callout>

## Installation

<Steps>
    <Step>
        ### Add the Plugin

        Add the MCP plugin to your auth configuration and specify the login page path.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { mcp } from "better-auth/plugins"; // [!code highlight]

        export const auth = betterAuth({
            plugins: [
                mcp({ // [!code highlight]
                    loginPage: "/sign-in" // path to your login page // [!code highlight]
                }) // [!code highlight]
            ]
        });
        ```
        <Callout>
            This doesn't have a client plugin, so you don't need to make any changes to your authClient.
        </Callout>
    </Step>

    <Step>
        ### Generate Schema

        Run the migration or generate the schema to add the necessary fields and tables to the database.

        <Tabs items={["migrate", "generate"]}>
            <Tab value="migrate">
            ```package-install
            npx auth migrate
            ```
            </Tab>
            <Tab value="generate">
            ```package-install
            npx auth generate
            ```
            </Tab>
        </Tabs>
        The MCP plugin uses the same schema as the OIDC Provider plugin. See the [OIDC Provider Schema](/docs/plugins/oidc-provider#schema) section for details.
    </Step>
</Steps>

## Usage

### OAuth Discovery Metadata

Better Auth already handles the `/api/auth/.well-known/oauth-authorization-server` route automatically but some client may fail to parse the `WWW-Authenticate` header and default to `/.well-known/oauth-authorization-server` (this can happen, for example, if your CORS configuration doesn't expose the `WWW-Authenticate`). For this reason it's better to add a route to expose OAuth metadata for MCP clients:

```ts title=".well-known/oauth-authorization-server/route.ts"
import { oAuthDiscoveryMetadata } from "better-auth/plugins";
import { auth } from "../../../lib/auth";

export const GET = oAuthDiscoveryMetadata(auth);
```

### OAuth Protected Resource Metadata

Better Auth already handles the `/api/auth/.well-known/oauth-protected-resource` route automatically but some client may fail to parse the `WWW-Authenticate` header and default to `/.well-known/oauth-protected-resource` (this can happen, for example, if your CORS configuration doesn't expose the `WWW-Authenticate`). For this reason it's better to add a route to expose OAuth metadata for MCP clients:

```ts title="/.well-known/oauth-protected-resource/route.ts"
import { oAuthProtectedResourceMetadata } from "better-auth/plugins";
import { auth } from "@/lib/auth";

export const GET = oAuthProtectedResourceMetadata(auth);
```

### MCP Session Handling

You can use the helper function `withMcpAuth` to get the session and handle unauthenticated calls automatically.


```ts title="api/[transport]/route.ts"
import { auth } from "@/lib/auth";
import { createMcpHandler } from "@vercel/mcp-adapter";
import { withMcpAuth } from "better-auth/plugins";
import { z } from "zod";

const handler = withMcpAuth(auth, (req, session) => {
    // session contains the access token record with scopes and user ID
    return createMcpHandler(
        (server) => {
            server.tool(
                "echo",
                "Echo a message",
                { message: z.string() },
                async ({ message }) => {
                    return {
                        content: [{ type: "text", text: `Tool echo: ${message}` }],
                    };
                },
            );
        },
        {
            capabilities: {
                tools: {
                    echo: {
                        description: "Echo a message",
                    },
                },
            },
        },
        {
            redisUrl: process.env.REDIS_URL,
            basePath: "/api",
            verboseLogs: true,
            maxDuration: 60,
        },
    )(req);
});

export { handler as GET, handler as POST, handler as DELETE };
```

You can also use `auth.api.getMcpSession` to get the session using the access token sent from the MCP client:

```ts title="api/[transport]/route.ts"
import { auth } from "@/lib/auth";
import { createMcpHandler } from "@vercel/mcp-adapter";
import { z } from "zod";

const handler = async (req: Request) => {
     // session contains the access token record with scopes and user ID
    const session = await auth.api.getMcpSession({
        headers: req.headers
    })
    if(!session){
        //this is important and you must return 401
        return new Response(null, {
            status: 401
        })
    }
    return createMcpHandler(
        (server) => {
            server.tool(
                "echo",
                "Echo a message",
                { message: z.string() },
                async ({ message }) => {
                    return {
                        content: [{ type: "text", text: `Tool echo: ${message}` }],
                    };
                },
            );
        },
        {
            capabilities: {
                tools: {
                    echo: {
                        description: "Echo a message",
                    },
                },
            },
        },
        {
            redisUrl: process.env.REDIS_URL,
            basePath: "/api",
            verboseLogs: true,
            maxDuration: 60,
        },
    )(req);
}

export { handler as GET, handler as POST, handler as DELETE };
```

## Configuration

The MCP plugin accepts the following configuration options:

<TypeTable
  type={{
    loginPage: {
        description: "Path to the login page where users will be redirected for authentication",
        type: "string",
        required: true
    },
    resource: {
        description: "The resource that should be returned by the protected resource metadata endpoint",
        type: "string",
        required: false
    },
    oidcConfig: {
        description: "Optional OIDC configuration options",
        type: "object",
        required: false
    }
  }}
/>

### OIDC Configuration

The plugin supports additional OIDC configuration options through the `oidcConfig` parameter:

<TypeTable
  type={{
    codeExpiresIn: {
        description: "Expiration time for authorization codes in seconds",
        type: "number",
        default: 600
    },
    accessTokenExpiresIn: {
        description: "Expiration time for access tokens in seconds",
        type: "number",
        default: 3600
    },
    refreshTokenExpiresIn: {
        description: "Expiration time for refresh tokens in seconds",
        type: "number",
        default: 604800
    },
    defaultScope: {
        description: "Default scope for OAuth requests",
        type: "string",
        default: "openid"
    },
    scopes: {
        description: "Additional scopes to support",
        type: "string[]",
        default: '["openid", "profile", "email", "offline_access"]'
    }
  }}
/>

## Remote MCP Client

The examples above use `withMcpAuth` which requires the Better Auth instance to be in the **same process** as the MCP server. If your MCP server runs as a separate service (different repo, different runtime, different language), you can use the **MCP Client** — a lightweight, framework-agnostic HTTP client that validates Bearer tokens against a remote Better Auth server.

<Callout>
    No additional packages needed — the MCP Client is included in `better-auth`.
</Callout>

### Setup

<Steps>
    <Step>
        ### Create the client

        Point it at your Better Auth server's URL (the same `baseURL` + `basePath` from your auth config):

        ```ts title="mcp-server.ts"
        import { createMcpAuthClient } from "better-auth/plugins/mcp/client" // [!code highlight]

        const mcpAuth = createMcpAuthClient({ // [!code highlight]
            authURL: "http://localhost:3000/api/auth" // [!code highlight]
        }) // [!code highlight]
        ```
    </Step>

    <Step>
        ### Protect your MCP routes

        Use the `handler` wrapper for Web Standard `Request`/`Response` (works with Deno, Bun, Cloudflare Workers, etc.):

        ```ts title="mcp-server.ts"
        const handler = mcpAuth.handler(async (req, session) => { // [!code highlight]
            // session.userId, session.scopes, session.clientId
            return new Response(JSON.stringify({
                jsonrpc: "2.0",
                result: { userId: session.userId },
                id: 1
            }))
        }) // [!code highlight]

        Deno.serve(handler)
        ```
    </Step>

    <Step>
        ### Mount discovery endpoints

        MCP clients need to discover your OAuth server. Mount these at the root of your MCP server:

        ```ts title="mcp-server.ts"
        const discovery = mcpAuth.discoveryHandler() // [!code highlight]
        const protectedResource = mcpAuth.protectedResourceHandler("http://localhost:4000") // [!code highlight]

        // GET /.well-known/oauth-authorization-server → proxied from Better Auth
        // GET /.well-known/oauth-protected-resource → points MCP clients to Better Auth
        ```

        These proxy and cache the metadata from your Better Auth server, so MCP clients can discover the authorization, token, and registration endpoints automatically.
    </Step>
</Steps>

### Framework Adapters

<Tabs items={["Hono", "Express", "Official MCP SDK", "mcp-use"]}>
    <Tab value="Hono">
        ```ts title="mcp-server.ts"
        import { Hono } from "hono"
        import { mcpAuthHono } from "better-auth/plugins/mcp/client/adapters" // [!code highlight]

        const app = new Hono()
        const { middleware, discoveryRoutes } = mcpAuthHono({ // [!code highlight]
            authURL: "http://localhost:3000/api/auth" // [!code highlight]
        }) // [!code highlight]

        // Mount OAuth discovery endpoints (required by MCP spec)
        discoveryRoutes(app, "http://localhost:4000") // [!code highlight]

        // Protect MCP routes
        app.use("/mcp/*", middleware) // [!code highlight]

        app.post("/mcp", (c) => {
            const session = c.get("mcpSession") // [!code highlight]
            // session.userId, session.scopes, etc.
        })
        ```
    </Tab>

    <Tab value="Express">
        ```ts title="mcp-server.ts"
        import express from "express"
        import { createMcpAuthClient } from "better-auth/plugins/mcp/client" // [!code highlight]

        const app = express()
        const mcpAuth = createMcpAuthClient({ // [!code highlight]
            authURL: "http://localhost:3000/api/auth" // [!code highlight]
        }) // [!code highlight]

        app.use("/mcp", mcpAuth.middleware()) // [!code highlight]

        app.post("/mcp", (req, res) => {
            const session = req.mcpSession // [!code highlight]
            // session.userId, session.scopes, etc.
        })
        ```
    </Tab>

    <Tab value="Official MCP SDK">
        ```ts title="mcp-server.ts"
        import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js"
        import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js"
        import { mcpAuthOfficial } from "better-auth/plugins/mcp/client/adapters" // [!code highlight]

        const auth = mcpAuthOfficial({ // [!code highlight]
            authURL: "http://localhost:3000/api/auth" // [!code highlight]
        }) // [!code highlight]

        const mcpServer = new McpServer({ name: "my-server", version: "1.0.0" })
        const app = express() // your HTTP framework

        app.post("/mcp", auth.handler(async (req, session) => { // [!code highlight]
            const transport = new StreamableHTTPServerTransport({
                sessionIdGenerator: () => crypto.randomUUID()
            })
            await mcpServer.connect(transport)
            return transport.handleRequest(req)
        }))
        ```
    </Tab>

    <Tab value="mcp-use">
        Drop-in replacement for `oauthWorkOSProvider`, `oauthSupabaseProvider`, etc.:

        ```ts title="mcp-server.ts"
        import { MCPServer } from "mcp-use/server"
        import { mcpAuthMcpUse } from "better-auth/plugins/mcp/client/adapters" // [!code highlight]

        const server = new MCPServer({
            name: "my-server",
            version: "1.0.0",
            oauth: mcpAuthMcpUse({ // [!code highlight]
                authURL: "http://localhost:3000/api/auth" // [!code highlight]
            }) // [!code highlight]
        })
        ```
    </Tab>
</Tabs>

### Options

<TypeTable
  type={{
    authURL: {
        description: "Full URL to Better Auth endpoints (baseURL + basePath)",
        type: "string",
        required: true
    },
    resource: {
        description: "Resource identifier for the protected resource metadata. Defaults to the origin of the server URL.",
        type: "string",
        required: false
    },
    allowedOrigin: {
        description: "Allowed CORS origin. Defaults to the authURL origin. Set to '*' to allow all origins (not recommended for production).",
        type: "string",
        required: false
    },
    fetch: {
        description: "Custom fetch implementation. Defaults to global fetch.",
        type: "typeof fetch",
        required: false
    }
  }}
/>

### Session Object

The session object returned by `verifyToken` and passed to handlers contains:

<TypeTable
  type={{
    accessToken: {
        description: "The opaque access token",
        type: "string"
    },
    refreshToken: {
        description: "The refresh token",
        type: "string"
    },
    accessTokenExpiresAt: {
        description: "When the access token expires",
        type: "string"
    },
    refreshTokenExpiresAt: {
        description: "When the refresh token expires",
        type: "string"
    },
    clientId: {
        description: "The OAuth client ID that requested the token",
        type: "string"
    },
    userId: {
        description: "The authenticated user's ID",
        type: "string"
    },
    scopes: {
        description: "Space-separated list of granted scopes",
        type: "string"
    }
  }}
/>

## Schema

The MCP plugin uses the same schema as the OIDC Provider plugin. See the [OIDC Provider Schema](/docs/plugins/oidc-provider#schema) section for details.
---
title: Basic Usage
description: Getting started with Better Auth
---

Better Auth provides built-in authentication support for:

- **Email and password**
- **Social provider (Google, GitHub, Apple, and more)**

But also can easily be extended using plugins, such as: [username](/docs/plugins/username), [magic link](/docs/plugins/magic-link), [passkey](/docs/plugins/passkey), [email-otp](/docs/plugins/email-otp), and more.

## Email & Password

To enable email and password authentication:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    emailAndPassword: {    // [!code highlight]
        enabled: true // [!code highlight]
    } // [!code highlight]
})
```

### Sign Up

To sign up a user you need to call the client method `signUp.email` with the user's information.

```ts title="sign-up.ts"
import { authClient } from "@/lib/auth-client"; //import the auth client // [!code highlight]

const { data, error } = await authClient.signUp.email({
        email, // user email address
        password, // user password -> min 8 characters by default
        name, // user display name
        image, // User image URL (optional)
        callbackURL: "/dashboard" // A URL to redirect to after the user verifies their email (optional)
    }, {
        onRequest: (ctx) => {
            //show loading
        },
        onSuccess: (ctx) => {
            //redirect to the dashboard or sign in page
        },
        onError: (ctx) => {
            // display the error message
            alert(ctx.error.message);
        },
});
```

By default, the users are automatically signed in after they successfully sign up. To disable this behavior you can set `autoSignIn` to `false`.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    emailAndPassword: {
    	enabled: true,
    	autoSignIn: false //defaults to true // [!code highlight]
  },
})
```


### Sign In

To sign a user in, you can use the `signIn.email` function provided by the client.

```ts title="sign-in"
const { data, error } = await authClient.signIn.email({
        /**
         * The user email
         */
        email,
        /**
         * The user password
         */
        password,
        /**
         * A URL to redirect to after the user verifies their email (optional)
         */
        callbackURL: "/dashboard",
        /**
         * remember the user session after the browser is closed. 
         * @default true
         */
        rememberMe: false
}, {
    //callbacks
})
```

<Callout type="warn">
Always invoke client methods from the client side. Don't call them from the server.
</Callout>

### Server-Side Authentication

To authenticate a user on the server, you can use the `auth.api` methods.

```ts title="server.ts"
import { auth } from "./auth"; // path to your Better Auth server instance

const response = await auth.api.signInEmail({
    body: {
        email,
        password
    },
    asResponse: true // returns a response object instead of data
});
```

<Callout>
If the server cannot return a response object, you'll need to manually parse and set cookies. But for frameworks like Next.js we provide [a plugin](/docs/integrations/next#server-action-cookies) to handle this automatically
</Callout>

## Social Sign-On

Better Auth supports multiple social providers, including Google, GitHub, Apple, Discord, and more. To use a social provider, you need to configure the ones you need in the `socialProviders` option on your `auth` object.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    socialProviders: { // [!code highlight]
        github: { // [!code highlight]
            clientId: process.env.GITHUB_CLIENT_ID!, // [!code highlight]
            clientSecret: process.env.GITHUB_CLIENT_SECRET!, // [!code highlight]
        } // [!code highlight]
    }, // [!code highlight]
})
```

### Sign in with social providers

To sign in using a social provider you need to call `signIn.social`. It takes an object with the following properties:

```ts title="sign-in.ts"
import { authClient } from "@/lib/auth-client"; //import the auth client // [!code highlight]

await authClient.signIn.social({
    /**
     * The social provider ID
     * @example "github", "google", "apple"
     */
    provider: "github",
    /**
     * A URL to redirect after the user authenticates with the provider
     * @default "/"
     */
    callbackURL: "/dashboard", 
    /**
     * A URL to redirect if an error occurs during the sign in process
     */
    errorCallbackURL: "/error",
    /**
     * A URL to redirect if the user is newly registered
     */
    newUserCallbackURL: "/welcome",
    /**
     * disable the automatic redirect to the provider. 
     * @default false
     */
    disableRedirect: true,
});
```

You can also authenticate using `idToken` or `accessToken` from the social provider instead of redirecting the user to the provider's site. See social providers documentation for more details. 

## Signout

To signout a user, you can use the `signOut` function provided by the client.

```ts title="user-card.tsx"
await authClient.signOut();
```

you can pass `fetchOptions` to redirect onSuccess
  
```ts title="user-card.tsx" 
await authClient.signOut({
  fetchOptions: {
    onSuccess: () => {
      router.push("/login"); // redirect to login page
    },
  },
});
```

## Session

Once a user is signed in, you'll want to access the user session. Better Auth allows you to easily access the session data from both the server and client sides.

### Client Side

#### Use Session

Better Auth provides a `useSession` hook to easily access session data on the client side. This hook is implemented using nanostore and has support for each supported framework and vanilla client, ensuring that any changes to the session (such as signing out) are immediately reflected in your UI.

<Tabs items={["React", "Vue","Svelte", "Solid", "Vanilla"]} defaultValue="react">
    <Tab value="React">
        ```tsx title="user.tsx"
        import { authClient } from "@/lib/auth-client" // import the auth client // [!code highlight] 

        export function User(){

            const { // [!code highlight]
                data: session, // [!code highlight]
                isPending, //loading state // [!code highlight]
                error, //error object // [!code highlight]
                refetch //refetch the session
            } = authClient.useSession() // [!code highlight]

            return (
                //...
            )
        }
        ```
    </Tab>

     <Tab value="Vue">
        ```vue title="index.vue"
        <script setup lang="ts">
        import { authClient } from "~/lib/auth-client" // [!code highlight]

        const session = authClient.useSession() // [!code highlight]
        </script>

        <template>
            <div>
                <div>
                    <pre>{{ session.data }}</pre>
                    <button v-if="session.data" @click="authClient.signOut()">
                        Sign out
                    </button>
                </div>
            </div>
        </template>
        ```
        </Tab>

        <Tab value="Svelte">
            ```svelte title="user.svelte"
            <script lang="ts">
            import { authClient } from "$lib/auth-client"; // [!code highlight]

            const session = authClient.useSession(); // [!code highlight]
            </script>
            <p>
                {$session.data?.user.email}
            </p>
            ```
        </Tab>
         <Tab value="Vanilla">
            ```ts title="auth-client.ts"
            import { authClient } from "~/lib/auth-client"; //import the auth client

            authClient.useSession.subscribe((value)=>{
                //do something with the session //
            }) 
            ```
        </Tab>

        <Tab value="Solid">
            ```tsx title="user.tsx"
            import { authClient } from "~/lib/auth-client"; // [!code highlight]

            export default function Home() {
                const session = authClient.useSession() // [!code highlight]
                return (
                    <pre>{JSON.stringify(session(), null, 2)}</pre>
                );
            }
            ```
        </Tab>
</Tabs>

#### Get Session

If you prefer not to use the hook, you can use the `getSession` method provided by the client.

```ts title="user.tsx"
import { authClient } from "@/lib/auth-client" // import the auth client // [!code highlight]

const { data: session, error } = await authClient.getSession()
```

You can also use it with client-side data-fetching libraries like [TanStack Query](https://tanstack.com/query/latest).

### Server Side

The server provides a `session` object that you can use to access the session data. It requires request headers object to be passed to the `getSession` method.

**Example: Using some popular frameworks**

<Tabs items={["Next.js", "Nuxt", "Svelte", "Astro", "Hono", "TanStack"]}>
    <Tab value="Next.js">
    ```ts title="server.ts"
    import { auth } from "./auth"; // path to your Better Auth server instance
    import { headers } from "next/headers";

    const session = await auth.api.getSession({
        headers: await headers() // you need to pass the headers object.
    })
    ```
    </Tab>
    <Tab value="react-router">
    ```ts title="route.ts"
    import { auth } from "lib/auth"; // path to your Better Auth server instance

    export async function loader({ request }: LoaderFunctionArgs) {
        const session = await auth.api.getSession({
            headers: request.headers
        })

        return json({ session })
    }
    ```
    </Tab>
    <Tab value="Astro">
    ```astro title="index.astro"
    ---
    import { auth } from "./auth";

    const session = await auth.api.getSession({
	    headers: Astro.request.headers,
    });
    ---
    <!-- Your Astro Template -->
    ```
    </Tab>
    <Tab value="Svelte">
    ```ts title="+page.ts"
    import { auth } from "./auth";

    export async function load({ request }) {
        const session = await auth.api.getSession({
            headers: request.headers
        })
        return {
            props: {
                session
            }
        }
    }
    ```
    </Tab>
    <Tab value="Hono">
    ```ts title="index.ts"
    import { auth } from "./auth";

    const app = new Hono();

    app.get("/path", async (c) => {
        const session = await auth.api.getSession({
            headers: c.req.raw.headers
        })
    });
    ```
    </Tab>

    <Tab value="Nuxt">
    ```ts title="server/session.ts"
    import { auth } from "~/utils/auth";

    export default defineEventHandler((event) => {
        const session = await auth.api.getSession({
            headers: event.headers,
        })
    });
    ```
    </Tab>
    <Tab value="TanStack">
    ```ts title="app/routes/api/index.ts"
    import { auth } from "./auth";
    import { createAPIFileRoute } from "@tanstack/start/api";

    export const APIRoute = createAPIFileRoute("/api/$")({
        GET: async ({ request }) => {
            const session = await auth.api.getSession({
                headers: request.headers
            })
        },
    });
    ```
    </Tab>
</Tabs>

<Callout>
For more details check [session-management](/docs/concepts/session-management) documentation.
</Callout>

## Using Plugins

One of the unique features of Better Auth is a plugins ecosystem. It allows you to add complex auth related functionality with small lines of code.

Below is an example of how to add two factor authentication using two factor plugin.

<Steps>

<Step>
### Server Configuration

To add a plugin, you need to import the plugin and pass it to the `plugins` option of the auth instance. For example, to add two factor authentication, you can use the following code:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { twoFactor } from "better-auth/plugins" // [!code highlight]

export const auth = betterAuth({
    //...rest of the options
    plugins: [ // [!code highlight]
        twoFactor() // [!code highlight]
    ] // [!code highlight]
})
```
now two factor related routes and method will be available on the server.

</Step>
<Step>
### Migrate Database

After adding the plugin, you'll need to add the required tables to your database. You can do this by running the `migrate` command, or by using the `generate` command to create the schema and handle the migration manually.

generating the schema:

```bash title="terminal"
npx auth generate
```

using the `migrate` command:

```bash title="terminal"
npx auth migrate
```

<Callout>
If you prefer adding the schema manually, you can check the schema required on the [two factor plugin](/docs/plugins/2fa#schema) documentation.
</Callout>

</Step>
<Step>
### Client Configuration

Once we're done with the server, we need to add the plugin to the client. To do this, you need to import the plugin and pass it to the `plugins` option of the auth client. For example, to add two factor authentication, you can use the following code:

```ts title="auth-client.ts"  
import { createAuthClient } from "better-auth/client";
import { twoFactorClient } from "better-auth/client/plugins"; // [!code highlight]

const authClient = createAuthClient({
    plugins: [ // [!code highlight]
        twoFactorClient({ // [!code highlight]
            twoFactorPage: "/two-factor" // the page to redirect if a user needs to verify 2nd factor // [!code highlight]
        }) // [!code highlight]
    ] // [!code highlight]
})
```

now two factor related methods will be available on the client.

```ts title="profile.ts"
import { authClient } from "./auth-client"

const enableTwoFactor = async() => {
    const data = await authClient.twoFactor.enable({
        password // the user password is required
    }) // this will enable two factor
}

const disableTwoFactor = async() => {
    const data = await authClient.twoFactor.disable({
        password // the user password is required
    }) // this will disable two factor
}

const signInWith2Factor = async() => {
    const data = await authClient.signIn.email({
        //...
    })
    //if the user has two factor enabled, it will redirect to the two factor page
}

const verifyTOTP = async() => {
    const data = await authClient.twoFactor.verifyTOTP({
        code: "123456", // the code entered by the user 
        /**
         * If the device is trusted, the user won't
         * need to pass 2FA again on the same device
         */
        trustDevice: true
    })
}
```
</Step>

<Step>
Next step: See the <Link href="/docs/plugins/2fa">two factor plugin documentation</Link>.
</Step>
</Steps>
---
title: Express Integration
description: Integrate Better Auth with Express.
---

This guide will show you how to integrate Better Auth with [express.js](https://expressjs.com/).

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

<Callout>
Note that CommonJS (cjs) isn't supported. Use ECMAScript Modules (ESM) by setting `"type": "module"` in your `package.json` or configuring your `tsconfig.json` to use ES modules.
</Callout>

### Mount the handler

To enable Better Auth to handle requests, we need to mount the handler to an API route. Create a catch-all route to manage all requests to `/api/auth/*` in case of ExpressJS v4 or `/api/auth/*splat` in case of ExpressJS v5 (or any other path specified in your Better Auth options).

<Callout type="warn">
Don’t use `express.json()` before the Better Auth handler. Use it only for other routes, or the client API will get stuck on "pending".
</Callout>

```ts title="server.ts"
import express from "express";
import { toNodeHandler } from "better-auth/node";
import { auth } from "./auth";

const app = express();
const port = 3005;

app.all("/api/auth/*", toNodeHandler(auth)); // For ExpressJS v4
// app.all("/api/auth/*splat", toNodeHandler(auth)); For ExpressJS v5 

// Mount express json middleware after Better Auth handler
// or only apply it to routes that don't interact with Better Auth
app.use(express.json());

app.listen(port, () => {
	console.log(`Example app listening on port ${port}`);
});
```

After completing the setup, start your server. Better Auth will be ready to use. You can send a `GET` request to the `/ok` endpoint (`/api/auth/ok`) to verify that the server is running.


### Cors Configuration

To add CORS (Cross-Origin Resource Sharing) support to your Express server when integrating Better Auth, you can use the `cors` middleware. Below is an updated example showing how to configure CORS for your server:

```ts
import express from "express";
import cors from "cors"; // Import the CORS middleware
import { toNodeHandler, fromNodeHeaders } from "better-auth/node";
import { auth } from "./auth";

const app = express();
const port = 3005;

// Configure CORS middleware
app.use(
  cors({
    origin: "http://your-frontend-domain.com", // Replace with your frontend's origin
    methods: ["GET", "POST", "PUT", "DELETE"], // Specify allowed HTTP methods
    credentials: true, // Allow credentials (cookies, authorization headers, etc.)
  })
);
```

### Getting the User Session

To retrieve the user's session, you can use the `getSession` method provided by the `auth` object. This method requires the request headers to be passed in a specific format. To simplify this process, Better Auth provides a `fromNodeHeaders` helper function that converts Node.js request headers to the format expected by Better Auth (a `Headers` object).

Here's an example of how to use `getSession` in an Express route:

```ts title="server.ts"
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "./auth"; // Your Better Auth instance

app.get("/api/me", async (req, res) => {
 	const session = await auth.api.getSession({
      headers: fromNodeHeaders(req.headers),
    });
	return res.json(session);
});
```
---
title: Expo Integration
description: Integrate Better Auth with Expo.
---

Expo is a popular framework for building cross-platform apps with React Native. Better Auth supports both Expo native and web apps.

## Installation

<Steps>
    <Step>
        ## Configure A Better Auth Backend
        Before using Better Auth with Expo, make sure you have a Better Auth backend set up. You can either use a separate server or leverage Expo's new [API Routes](https://docs.expo.dev/router/reference/api-routes) feature to host your Better Auth instance.

        To get started, check out our [installation](/docs/installation) guide for setting up Better Auth on your server. If you prefer to check out the full example, you can find it [here](https://github.com/better-auth/examples/tree/main/expo-example).

        To use the new API routes feature in Expo to host your Better Auth instance you can create a new API route in your Expo app and mount the Better Auth handler.

        ```ts title="app/api/auth/[...auth]+api.ts"
        import { auth } from "@/lib/auth"; // import Better Auth handler
        
        const handler = auth.handler;
        export { handler as GET, handler as POST }; // export handler for both GET and POST requests
        ```
    </Step>
    <Step>
        ## Install Server Dependencies

        Install both the Better Auth package and Expo plugin into your server application.

        ```package-install
        better-auth @better-auth/expo
        ```
        <Callout type="info">
            If you're using Expo's API Routes, you can follow the step below instead.
        </Callout>
    </Step>

    <Step>
        ## Install Client Dependencies

        - You also need to install both the Better Auth package and Expo plugin into your Expo application.

        ```package-install
        better-auth @better-auth/expo
        ```

        - And you need to install `expo-network` for network state detection.

        ```package-install
        expo-network
        ```

        - <small className='text-xs'>(Optional)</small> If you're using the default Expo template, these dependencies are already included, so you can skip this step. Otherwise, if you plan to use our social providers (e.g. Google, Apple), your Expo app requires a few additional dependencies.

        ```package-install
        expo-linking expo-web-browser expo-constants
        
        ```
    </Step>
    
    <Step>
        ## Add the Expo Plugin on Your Server

        Add the Expo plugin to your Better Auth server.

        ```ts title="lib/auth.ts"
        import { betterAuth } from "better-auth";
        import { expo } from "@better-auth/expo";

        export const auth = betterAuth({
            plugins: [expo()],
            emailAndPassword: { 
                enabled: true, // Enable authentication using email and password.
              }, 
        });
        ```
    </Step>

    <Step>
        ## Initialize Better Auth Client
        
        To initialize Better Auth in your Expo app, you need to call `createAuthClient` with the base URL of your Better Auth backend. Make sure to import the client from `/react`.

        Make sure you install the `expo-secure-store` package into your Expo app. This is used to store the session data and cookies securely.

        ```package-install
        expo-secure-store
        ```

        You need to also import client plugin from `@better-auth/expo/client` and pass it to the `plugins` array when initializing the auth client.

        This is important because:

        - **Social Authentication Support:** enables social auth flows by handling authorization URLs and callbacks within the Expo web browser.
        - **Secure Cookie Management:** stores cookies securely and automatically adds them to the headers of your auth requests.

        ```ts title="lib/auth-client.ts"
        import { createAuthClient } from "better-auth/react";
        import { expoClient } from "@better-auth/expo/client";
        import * as SecureStore from "expo-secure-store";

        export const authClient = createAuthClient({
            baseURL: "http://localhost:8081", // Base URL of your Better Auth backend.
            plugins: [
                expoClient({
                    scheme: "myapp",
                    storagePrefix: "myapp",
                    storage: SecureStore,
                })
            ]
        });
        ```
        <Callout>
         Be sure to include the full URL, including the path, if you've changed the default path from `/api/auth`.
        </Callout>
    </Step>

     <Step>
        ## Scheme and Trusted Origins

        Better Auth uses deep links to redirect users back to your app after authentication. To enable this, you need to add your app's scheme to the `trustedOrigins` list in your Better Auth config. 

        First, make sure you have a scheme defined in your `app.json` file.

        ```json title="app.json"
        {
            "expo": {
                "scheme": "myapp"
            }
        }
        ```

        Then, update your Better Auth config to include the scheme in the `trustedOrigins` list.

        ```ts title="auth.ts"
        export const auth = betterAuth({
            trustedOrigins: ["myapp://"]
        })
        ```

        If you have multiple schemes or need to support deep linking with various paths, you can use specific patterns or wildcards:

        ```ts title="auth.ts"
        export const auth = betterAuth({
            trustedOrigins: [
                // Basic scheme
                "myapp://", 
                
                // Production & staging schemes
                "myapp-prod://",
                "myapp-staging://",
                
                // Wildcard support for all paths following the scheme
                "myapp://*"
            ]
        })
        ```

        ### Development Mode

        During development, Expo uses the `exp://` scheme with your device's local IP address. To support this, you can use wildcards to match common local IP ranges:

        ```ts title="auth.ts"
        export const auth = betterAuth({
            trustedOrigins: [
                "myapp://",
                
                // Development mode - Expo's exp:// scheme with local IP ranges
                ...(process.env.NODE_ENV === "development" ? [
                    "exp://",                      // Trust all Expo URLs (prefix matching)
                    "exp://**",                    // Trust all Expo URLs (wildcard matching)
                    "exp://192.168.*.*:*/**",      // Trust 192.168.x.x IP range with any port and path
                ] : [])
            ]
        })
        ```

        For more information about trusted origins, see [here](/docs/reference/options#trustedorigins).

        <Callout type="warn">
          The wildcard patterns for `exp://` should only be used in development. In production, use your app's specific scheme (e.g., `myapp://`).
        </Callout>
    </Step>
 
    <Step>
        ## Configure Metro Bundler

        To resolve Better Auth exports you'll need to enable `unstable_enablePackageExports` in your metro config. 

        ```js title="metro.config.js"
        const { getDefaultConfig } = require("expo/metro-config");

        const config = getDefaultConfig(__dirname)

        config.resolver.unstable_enablePackageExports = true; // [!code highlight]

        module.exports = config;
        ```

        <Callout>In case you don't have a `metro.config.js` file in your project run `npx expo customize metro.config.js`.</Callout>
        
        If you can't enable `unstable_enablePackageExports` option, you can use [babel-plugin-module-resolver](https://github.com/tleunen/babel-plugin-module-resolver) to manually resolve the paths.

        ```ts title="babel.config.js"
        module.exports = function (api) {
            api.cache(true);
            return {
                presets: ["babel-preset-expo"],
                plugins: [
                    [
                        "module-resolver",
                        {
                            alias: {
                                "better-auth/react": "./node_modules/better-auth/dist/client/react/index.mjs",
                                "better-auth/client/plugins": "./node_modules/better-auth/dist/client/plugins/index.mjs",
                                "@better-auth/expo/client": "./node_modules/@better-auth/expo/dist/client.mjs",
                            },
                        },
                    ],
                ],
            }
        }
        ```

        <Callout>In case you don't have a `babel.config.js` file in your project run `npx expo customize babel.config.js`.</Callout>

        Don't forget to clear the cache after making changes.

        ```bash
        npx expo start --clear
        ```

    </Step>
</Steps>


## Usage

### Authenticating Users

With Better Auth initialized, you can now use the `authClient` to authenticate users in your Expo app.

<Tabs items={["sign-in", "sign-up"]}>
    <Tab value="sign-in">
        ```tsx title="app/sign-in.tsx"
        import { useState } from "react"; 
        import { View, TextInput, Button } from "react-native";
        import { authClient } from "@/lib/auth-client";

        export default function SignIn() {
            const [email, setEmail] = useState("");
            const [password, setPassword] = useState("");

            const handleLogin = async () => {
                await authClient.signIn.email({
                    email,
                    password,
                })
            };

            return (
                <View>
                    <TextInput
                        placeholder="Email"
                        value={email}
                        onChangeText={setEmail}
                    />
                    <TextInput
                        placeholder="Password"
                        value={password}
                        onChangeText={setPassword}
                    />
                    <Button title="Login" onPress={handleLogin} />
                </View>
            );
        }
        ```
    </Tab>
    <Tab value="sign-up">
        ```tsx title="app/sign-up.tsx"
        import { useState } from "react";
        import { View, TextInput, Button } from "react-native";
        import { authClient } from "@/lib/auth-client";

        export default function SignUp() {
            const [email, setEmail] = useState("");
            const [name, setName] = useState("");
            const [password, setPassword] = useState("");

            const handleLogin = async () => {
                await authClient.signUp.email({
                        email,
                        password,
                        name
                })
            };

            return (
                <View>
                    <TextInput
                        placeholder="Name"
                        value={name}
                        onChangeText={setName}
                    />
                    <TextInput
                        placeholder="Email"
                        value={email}
                        onChangeText={setEmail}
                    />
                    <TextInput
                        placeholder="Password"
                        value={password}
                        onChangeText={setPassword}
                    />
                    <Button title="Login" onPress={handleLogin} />
                </View>
            );
        }
        ```
    </Tab>
</Tabs>

#### Social Sign-In

For social sign-in, you can use the `authClient.signIn.social` method with the provider name and a callback URL.

```tsx title="app/social-sign-in.tsx"
import { Button } from "react-native";

export default function SocialSignIn() {
    const handleLogin = async () => {
        await authClient.signIn.social({
            provider: "google",
            callbackURL: "/dashboard" // this will be converted to a deep link (eg. `myapp://dashboard`) on native
        })
    };
    return <Button title="Login with Google" onPress={handleLogin} />;
}
```

#### IdToken Sign-In

If you want to make provider request on the mobile device and then verify the ID token on the server, you can use the `authClient.signIn.social` method with the `idToken` option.

```tsx title="app/social-sign-in.tsx"
import { Button } from "react-native";

export default function SocialSignIn() {
    const handleLogin = async () => {
        await authClient.signIn.social({
            provider: "google", // only google, apple and facebook are supported for idToken signIn
            idToken: {
                token: "...", // ID token from provider
                nonce: "...", // nonce from provider (optional)
            }
            callbackURL: "/dashboard" // this will be converted to a deep link (eg. `myapp://dashboard`) on native
        })
    };
    return <Button title="Login with Google" onPress={handleLogin} />;
}
```

<Accordions>
<Accordion title="Example: Google Sign-In with `@react-native-google-signin/google-signin`">

This example shows how to implement Google Sign-In using an idToken. No additional configuration is needed in Better Auth. However, since this approach uses native code, you'll need to configure Expo to obtain the idToken.

Follow the [Expo Google authentication guide](https://docs.expo.dev/guides/google-authentication/) to set up `@react-native-google-signin/google-signin`, then pass the idToken to Better Auth:

```tsx title="app/sign-in.tsx"
import {
  GoogleSignin,
  GoogleSigninButton,
  isSuccessResponse,
} from "@react-native-google-signin/google-signin";
import { View } from "react-native";
import { router } from "expo-router";
import { authClient } from "@/lib/auth-client";

GoogleSignin.configure({
  webClientId: process.env.EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID,
  iosClientId: process.env.EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID,
});

export default function GoogleSignIn() {
  const handleGoogle = async () => {
    await GoogleSignin.hasPlayServices();
    const response = await GoogleSignin.signIn();

    if (isSuccessResponse(response) && response.data.idToken) {
      const { error } = await authClient.signIn.social({
        provider: "google",
        idToken: { token: response.data.idToken },
      });
      if (!error) {
        router.replace("/dashboard");
      }
    }
  };

  return (
    <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
      <GoogleSigninButton onPress={handleGoogle} />
    </View>
  );
}
```
</Accordion>
</Accordions>

### Session

Better Auth provides a `useSession` hook to access the current user's session in your app.

```tsx title="app/index.tsx"
import { Text } from "react-native";
import { authClient } from "@/lib/auth-client";

export default function Index() {
    const { data: session } = authClient.useSession();

    return <Text>Welcome, {session?.user.name}</Text>;
}
```

On native, the session data will be cached in SecureStore. This will allow you to remove the need for a loading spinner when the app is reloaded. You can disable this behavior by passing the `disableCache` option to the client.


### Making Authenticated Requests to Your Server

To make authenticated requests to your server that require the user's session, you have to retrieve the session cookie from `SecureStore` and manually add it to your request headers.

```tsx
import { authClient } from "@/lib/auth-client";

const makeAuthenticatedRequest = async () => {
  const cookies = authClient.getCookie(); // [!code highlight]
  const headers = {
    "Cookie": cookies, // [!code highlight]
  };
  const response = await fetch("http://localhost:8081/api/secure-endpoint", { 
    headers,
    // 'include' can interfere with the cookies we just set manually in the headers
    credentials: "omit" // [!code highlight]
  });
  const data = await response.json();
  return data;
};
```

**Example: Usage With TRPC**
    
```tsx title="lib/trpc-provider.tsx"
//...other imports
import { authClient } from "@/lib/auth-client"; // [!code highlight]

export const api = createTRPCReact<AppRouter>();

export function TRPCProvider(props: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient());
  const [trpcClient] = useState(() =>
    api.createClient({
      links: [
        httpBatchLink({
          //...your other options
          headers() {
            const headers = new Map<string, string>(); // [!code highlight]
            const cookies = authClient.getCookie(); // [!code highlight]
            if (cookies) { // [!code highlight]
              headers.set("Cookie", cookies); // [!code highlight]
            } // [!code highlight]
            return Object.fromEntries(headers); // [!code highlight]
          },
        }),
      ],
    }),
  );

  return (
    <api.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {props.children}
      </QueryClientProvider>
    </api.Provider>
  );
}
```


## Options

### Expo Client

**storage**: the storage mechanism used to cache the session data and cookies.

```ts title="lib/auth-client.ts"
import { createAuthClient } from "better-auth/react";
import { expoClient } from "@better-auth/expo/client";
import SecureStorage from "expo-secure-store";

const authClient = createAuthClient({
    baseURL: "http://localhost:8081",
    plugins: [
        expoClient({
            storage: SecureStorage,
            // ...
        })
    ],
});
```

**scheme**: scheme is used to deep link back to your app after a user has authenticated using oAuth providers. By default, Better Auth tries to read the scheme from the `app.json` file. If you need to override this, you can pass the scheme option to the client.

```ts title="lib/auth-client.ts"
import { createAuthClient } from "better-auth/react";
import { expoClient } from "@better-auth/expo/client";

const authClient = createAuthClient({
    baseURL: "http://localhost:8081",
    plugins: [
        expoClient({
            scheme: "myapp",
            // ...
        }),
    ],
});
```

**disableCache**: By default, the client will cache the session data in SecureStore. You can disable this behavior by passing the `disableCache` option to the client.

```ts title="lib/auth-client.ts"
import { createAuthClient } from "better-auth/react";
import { expoClient } from "@better-auth/expo/client";

const authClient = createAuthClient({
    baseURL: "http://localhost:8081",
    plugins: [
        expoClient({
            disableCache: true,
            // ...
        }),
    ],
});
```

**cookiePrefix**: Prefix(es) for server cookie names to identify which cookies belong to better-auth. This prevents infinite refetching when third-party cookies are set. Can be a single string or an array of strings to match multiple prefixes. Defaults to `"better-auth"`.

```ts title="lib/auth-client.ts"
import { createAuthClient } from "better-auth/react";
import { expoClient } from "@better-auth/expo/client";
import * as SecureStore from "expo-secure-store";

const authClient = createAuthClient({
    baseURL: "http://localhost:8081",
    plugins: [
        expoClient({
            storage: SecureStore,
            // Single prefix
            cookiePrefix: "better-auth"
        })
    ]
});
```

You can also provide multiple prefixes to match cookies from different authentication systems:

```ts title="lib/auth-client.ts"
const authClient = createAuthClient({
    baseURL: "http://localhost:8081",
    plugins: [
        expoClient({
            storage: SecureStore,
            // Multiple prefixes
            cookiePrefix: ["better-auth", "my-app", "custom-auth"]
        })
    ]
});
```

<Callout type="info">
  **Important:** If you're using plugins like passkey with a custom `webAuthnChallengeCookie` option, make sure to include the cookie prefix in the `cookiePrefix` array. For example, if you set `webAuthnChallengeCookie: "my-app-passkey"`, include `"my-app"` in your `cookiePrefix`. See the [Passkey plugin documentation](/docs/plugins/passkey#expo-integration) for more details.
</Callout>


### Expo Servers

Server plugin options:

**disableOriginOverride**: Override the origin for Expo API routes (default: false). Enable this if you're facing cors origin issues with Expo API routes.
---
title: Nuxt Integration
description: Integrate Better Auth with Nuxt.
---

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

### Create API Route

We need to mount the handler to an API route. Create a file inside `/server/api/auth` called `[...all].ts` and add the following code:

```ts title="server/api/auth/[...all].ts"
import { auth } from "~/lib/auth"; // import your auth config

export default defineEventHandler((event) => {
	return auth.handler(toWebRequest(event));
});
```
<Callout type="info">
 You can change the path on your better-auth configuration but it's recommended to keep it as `/api/auth/[...all]`
</Callout>

## Create a client

Create a client instance. You can name the file anything you want. Here we are creating `client.ts` file inside the `lib/` directory.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/vue" // make sure to import from better-auth/vue

export const authClient = createAuthClient({
    //you can pass client configuration here
})
```

Once you have created the client, you can use it to sign up, sign in, and perform other actions.
Some of the actions are reactive.

### Example usage

```vue title="index.vue"
<script setup lang="ts">
import { authClient } from "~/lib/client"
const session = authClient.useSession()
</script>

<template>
    <div>
        <button v-if="!session?.data" @click="() => authClient.signIn.social({
            provider: 'github'
        })">
            Continue with GitHub
        </button>
        <div>
            <pre>{{ session.data }}</pre>
            <button v-if="session.data" @click="authClient.signOut()">
                Sign out
            </button>
        </div>
    </div>
</template>
```

### Server Usage

The `api` object exported from the auth instance contains all the actions that you can perform on the server. Every endpoint made inside Better Auth is a invocable as a function. Including plugins endpoints.

**Example: Getting Session on a server API route**

```tsx title="server/api/example.ts"
import { auth } from "~/lib/auth";

export default defineEventHandler((event) => {
    const session = await auth.api.getSession({
      headers: event.headers
    });

   if(session) {
     // access the session.session && session.user
   }
});
```


### SSR Usage

If you are using Nuxt with SSR, you can use the `useSession` function in the `setup` function of your page component and pass `useFetch` to make it work with SSR.

```vue title="index.vue"
<script setup lang="ts">
import { authClient } from "~/lib/auth-client";

const { data: session } = await authClient.useSession(useFetch);
</script>

<template>
    <p>
        {{ session }}
    </p>
</template>
```


### Middleware

To add middleware to your Nuxt project, you can use the `useSession` method from the client.

```ts title="middleware/auth.global.ts"
import { authClient } from "~/lib/auth-client";
export default defineNuxtRouteMiddleware(async (to, from) => {
	const { data: session } = await authClient.useSession(useFetch); 
	if (!session.value) {
		if (to.path === "/dashboard") {
			return navigateTo("/");
		}
	}
});
```

### Resources & Examples

- [Nuxt and Nuxt Hub example](https://github.com/atinux/nuxthub-better-auth) on GitHub.
- [NuxtZzle is Nuxt,Drizzle ORM example](https://github.com/leamsigc/nuxt-better-auth-drizzle) on GitHub [preview](https://nuxt-better-auth.giessen.dev/)
- [Nuxt example](https://stackblitz.com/github/better-auth/examples/tree/main/nuxt-example) on StackBlitz.
- [NuxSaaS (Github)](https://github.com/NuxSaaS/NuxSaaS) is a full-stack SaaS Starter Kit that leverages Better Auth for secure and efficient user authentication. [Demo](https://nuxsaas.com/)
- [NuxtOne (Github)](https://github.com/nuxtone/nuxt-one) is a Nuxt-based starter template for building AIaaS (AI-as-a-Service) applications.
---
title: Hono Integration
description: Integrate Better Auth with Hono.
---

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

### Mount the handler

We need to mount the handler to Hono endpoint.

```ts
import { Hono } from "hono";
import { auth } from "./auth";
import { serve } from "@hono/node-server";

const app = new Hono();

app.on(["POST", "GET"], "/api/auth/*", (c) => {
	return auth.handler(c.req.raw);
});

serve(app);
```

### Cors

To configure cors, you need to use the `cors` plugin from `hono/cors`.

```ts
import { Hono } from "hono";
import { auth } from "./auth";
import { serve } from "@hono/node-server";
import { cors } from "hono/cors";
 
const app = new Hono();

app.use(
	"/api/auth/*", // or replace with "*" to enable cors for all routes
	cors({
		origin: "http://localhost:3001", // replace with your origin
		allowHeaders: ["Content-Type", "Authorization"],
		allowMethods: ["POST", "GET", "OPTIONS"],
		exposeHeaders: ["Content-Length"],
		maxAge: 600,
		credentials: true,
	}),
);

app.on(["POST", "GET"], "/api/auth/*", (c) => {
	return auth.handler(c.req.raw);
});

serve(app);
```

> **Important:** CORS middleware must be registered before your routes. This ensures that cross-origin requests are properly handled before they reach your authentication endpoints.

### Middleware

You can add a middleware to save the `session` and `user` in a `context` and also add validations for every route.

```ts
import { Hono } from "hono";
import { auth } from "./auth";
import { serve } from "@hono/node-server";
import { cors } from "hono/cors";
 
const app = new Hono<{
	Variables: {
		user: typeof auth.$Infer.Session.user | null;
		session: typeof auth.$Infer.Session.session | null
	}
}>();

app.use("*", async (c, next) => {
	const session = await auth.api.getSession({ headers: c.req.raw.headers });

  	if (!session) {
    	c.set("user", null);
    	c.set("session", null);
    	await next();
        return;
  	}

  	c.set("user", session.user);
  	c.set("session", session.session);
  	await next();
});

app.on(["POST", "GET"], "/api/auth/*", (c) => {
	return auth.handler(c.req.raw);
});


serve(app);
```

This will allow you to access the `user` and `session` object in all of your routes.

```ts
app.get("/session", (c) => {
	const session = c.get("session")
	const user = c.get("user")
	
	if(!user) return c.body(null, 401);

  	return c.json({
	  session,
	  user
	});
});
```

### Cross-Domain Cookies

By default, all Better Auth cookies are set with `SameSite=Lax`. If you need to use cookies across different domains, you’ll need to set `SameSite=None` and `Secure=true`. However, we recommend using subdomains whenever possible, as this allows you to keep `SameSite=Lax`. To enable cross-subdomain cookies, simply turn on `crossSubDomainCookies` in your auth config.

```ts title="auth.ts"
export const auth = createAuth({
  advanced: {
    crossSubDomainCookies: {
      enabled: true
    }
  }
})
```

If you still need to set `SameSite=None` and `Secure=true`, you can adjust these attributes globally through `cookieOptions` in the `createAuth` configuration.

```ts title="auth.ts"
export const auth = createAuth({
  advanced: {
    defaultCookieAttributes: {
      sameSite: "none",
      secure: true,
      partitioned: true // New browser standards will mandate this for foreign cookies
    }
  }
})
```

You can also customize cookie attributes individually by setting them within `cookies` in your auth config.

```ts title="auth.ts"
export const auth = createAuth({
  advanced: {
    cookies: {
      sessionToken: {
        attributes: {
          sameSite: "none",
          secure: true,
          partitioned: true // New browser standards will mandate this for foreign cookies
        }
      }
    }
  }
})
```

### Client-Side Configuration

When using the Hono client (`@hono/client`) to make requests to your Better Auth-protected endpoints, you need to configure it to send credentials (cookies) with cross-origin requests.

```ts title="api.ts"
import { hc } from "hono/client";
import type { AppType } from "./server"; // Your Hono app type

const client = hc<AppType>("http://localhost:8787/", {
  init: {
    credentials: "include", // Required for sending cookies cross-origin
  },
});

// Now your client requests will include credentials
const response = await client.someProtectedEndpoint.$get();
```

This configuration is necessary when:
- Your client and server are on different domains/ports during development
- You're making cross-origin requests in production
- You need to send authentication cookies with your requests

The `credentials: "include"` option tells the fetch client to send cookies even for cross-origin requests. This works in conjunction with the CORS configuration on your server that has `credentials: true`.

> **Note:** Make sure your CORS configuration on the server matches your client's domain, and that `credentials: true` is set in both the server's CORS config and the client's fetch config.

### Cloudflare Workers

When deploying Better Auth with Hono on Cloudflare Workers, you may encounter issues with the CLI if your auth configuration depends on runtime environment variables (like `env.DB` for D1 databases).

#### The Problem

In Cloudflare Workers, environment variables are passed at runtime through request handlers, not available via `process.env` at build time. This makes it challenging to use the Better Auth CLI for migrations since the CLI needs to import your auth configuration file.

```typescript title="auth.ts"
// This won't work with the CLI because env is not available
export const createAuth = (env: Env) => betterAuth({
  database: env.DB, // env.DB is only available at runtime
  // ... rest of config
});
```

#### Solution 1: Programmatic Migrations (Built-in Kysely Adapter)

If you're using the built-in Kysely adapter (SQLite/D1, PostgreSQL, MySQL), you can run migrations programmatically through a custom endpoint:

```typescript title="src/index.ts"
import { Hono } from "hono";
import { getMigrations } from "better-auth/db/migration";
import { betterAuth } from "better-auth";

type Env = {
  DB: D1Database;
  // ... other bindings
};

const app = new Hono<{ Bindings: Env }>();

// Migration endpoint - call this to set up your database
app.post("/migrate", async (c) => {
  const authConfig = {
    database: c.env.DB,
    // Add all your other auth config options here
    // (socialProviders, plugins, etc.)
  };

  try {
    const { toBeCreated, toBeAdded, runMigrations } = await getMigrations(authConfig);

    if (toBeCreated.length === 0 && toBeAdded.length === 0) {
      return c.json({ message: "No migrations needed" });
    }

    await runMigrations();

    return c.json({
      message: "Migrations completed successfully",
      tablesCreated: toBeCreated.map(t => t.table),
      tablesUpdated: toBeAdded.map(t => t.table)
    });
  } catch (error) {
    return c.json({
      error: error instanceof Error ? error.message : "Migration failed"
    }, 500);
  }
});

// Your auth handler
app.on(["POST", "GET"], "/api/auth/*", async (c) => {
  const auth = betterAuth({
    database: c.env.DB,
    // ... your config
  });
  return auth.handler(c.req.raw);
});

export default app;
```

**Usage:**
1. Deploy your worker
2. Call the migration endpoint once: `curl -X POST https://your-worker.workers.dev/migrate`
3. Remove or protect the migration endpoint after running

<Callout type="warn">
**Security Note**: Protect your migration endpoint in production! Consider:
- Adding authentication/authorization
- Using environment-based checks to only allow migrations in development
- Removing the endpoint entirely after initial setup
</Callout>

#### Solution 2: Use `cloudflare:workers` Import (Prisma/Drizzle)

For Prisma or Drizzle users, Cloudflare now supports importing environment variables from `cloudflare:workers`:

```typescript title="auth.ts"
import { env } from "cloudflare:workers";
import { drizzle } from "drizzle-orm/d1";
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  database: drizzle(env.DB),
  // ... rest of your config
});
```

This allows you to use the standard CLI commands:

```bash
npx auth generate
```

See the [Cloudflare changelog](https://developers.cloudflare.com/changelog/2025-03-17-importable-env/) for more details on this feature.

#### Solution 3: Use `process.env` with Compatibility Flag

Add the `nodejs_compat_populate_process_env` flag to your `wrangler.toml`:

```toml title="wrangler.toml"
compatibility_flags = ["nodejs_compat_populate_process_env"]
```

Then use `process.env` in your auth config:

```typescript title="auth.ts"
import { drizzle } from "drizzle-orm/d1";
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  database: drizzle(process.env.DB as any),
  // ... rest of config
});
```

For compatibility dates on or after `2025-04-01`, this is the default behavior when `nodejs_compat` is enabled. See the [Cloudflare documentation](https://developers.cloudflare.com/workers/runtime-apis/nodejs/process/) for more details.

<Callout type="info">
For more information on programmatic migrations, see the [Database documentation](/docs/concepts/database#programmatic-migrations).
</Callout>
---
title: Nitro Integration
description: Integrate Better Auth with Nitro.
---

Better Auth can be integrated with your [Nitro Application](https://nitro.build/) (an open source framework to build web servers).

This guide aims to help you integrate Better Auth with your Nitro application in a few simple steps.

## Create a new Nitro Application

Start by scaffolding a new Nitro application using the following command:

```bash title="Terminal"
npx giget@latest nitro nitro-app --install
```

This will create the `nitro-app` directory and install all the dependencies. You can now open the `nitro-app` directory in your code editor.

### Prisma Adapter Setup

<Callout>
  This guide assumes that you have a basic understanding of Prisma. If you are new to Prisma, you can check out the [Prisma documentation](https://www.prisma.io/docs/getting-started).

  The `sqlite` database used in this guide will not work in a production environment. You should replace it with a production-ready database like `PostgreSQL`.
</Callout>

For this guide, we will be using the Prisma adapter. You can install prisma client by running the following command:

```package-install
@prisma/client
```

`prisma` can be installed as a dev dependency using the following command:

```package-install
-D prisma
```

Generate a `schema.prisma` file in the `prisma` directory by running the following command:

```bash title="Terminal"
npx prisma init
```

You can now replace the contents of the `schema.prisma` file with the following:

```prisma title="prisma/schema.prisma"
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Will be deleted. Just need it to generate the prisma client
model Test {
  id   Int    @id @default(autoincrement())
  name String
}
```

Ensure that you update the `DATABASE_URL` in your `.env` file to point to the location of your database.

```txt title=".env"
DATABASE_URL="file:./dev.db"
```

Run the following command to generate the Prisma client & sync the database:

```bash title="Terminal"
npx prisma db push
```

### Install & Configure Better Auth

Follow steps 1 & 2 from the [installation guide](/docs/installation) to install Better Auth in your Nitro application & set up the environment variables.

Once that is done, create your Better Auth instance within the `server/utils/auth.ts` file.

```ts title="server/utils/auth.ts"
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();
export const auth = betterAuth({
  database: prismaAdapter(prisma, { provider: "sqlite" }),
  emailAndPassword: { enabled: true },
});
```

### Update Prisma Schema

Use the Better Auth CLI to update your Prisma schema with the required models by running the following command:

```bash title="Terminal"
npx auth generate --config server/utils/auth.ts
```

<Callout>
  The `--config` flag is used to specify the path to the file where you have created your Better Auth instance.
</Callout>

Head over to the `prisma/schema.prisma` file & save the file to trigger the format on save.

After saving the file, you can run the `npx prisma db push` command to update the database schema.

## Mount The Handler

You can now mount the Better Auth handler in your Nitro application. You can do this by adding the following code to your `server/routes/api/auth/[...all].ts` file:

```ts title="server/routes/api/auth/[...all].ts"
export default defineEventHandler((event) => {
  return auth.handler(toWebRequest(event));
});
```
<Callout>
  This is a [catch-all](https://nitro.build/guide/routing#catch-all-route) route that will handle all requests to `/api/auth/*`.
</Callout>

### CORS

You can configure CORS for your Nitro app by creating a plugin.

Start by installing the cors package:

```package-install
cors
```

You can now create a new file `server/plugins/cors.ts` and add the following code:

```ts title="server/plugins/cors.ts"
import cors from "cors";
export default defineNitroPlugin((plugin) => {
  plugin.h3App.use(
    fromNodeMiddleware(
      cors({
        origin: "*",
      }),
    ),
  );
});
```
<Callout>
  This will enable CORS for all routes. You can customize the `origin` property to allow requests from specific domains. Ensure that the config is in sync with your frontend application.
</Callout>

### Auth Guard/Middleware

You can add an auth guard to your Nitro application to protect routes that require authentication. You can do this by creating a new file `server/utils/require-auth.ts` and adding the following code:

```ts title="server/utils/require-auth.ts"
import { EventHandler, H3Event } from "h3";
import { fromNodeHeaders } from "better-auth/node";

/**
 * Middleware used to require authentication for a route.
 *
 * Can be extended to check for specific roles or permissions.
 */
export const requireAuth: EventHandler = async (event: H3Event) => {
  const headers = event.headers;

  const session = await auth.api.getSession({
    headers: headers,
  });
  if (!session)
    throw createError({
      statusCode: 401,
      statusMessage: "Unauthorized",
    });
  // You can save the session to the event context for later use
  event.context.auth = session;
};
```

You can now use this event handler/middleware in your routes to protect them:

```ts title="server/routes/api/secret.get.ts"
// Object syntax of the route handler
export default defineEventHandler({
  // The user has to be logged in to access this route
  onRequest: [requireAuth],
  handler: async (event) => {
    setResponseStatus(event, 201, "Secret data");
    return { message: "Secret data" };
  },
});
```

### Example

You can find an example of a Nitro application integrated with Better Auth & Prisma [here](https://github.com/BayBreezy/nitrojs-better-auth-prisma).
---
title: Waku Integration
description: Integrate Better Auth with Waku.
---

Better Auth can be easily integrated with Waku. Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

## Create auth instance

Create a file named `auth.ts` in your application. Import Better Auth and create your instance.

<Callout type="warn">
Make sure to export the auth instance with the variable name `auth` or as a `default` export.
</Callout>

```ts title="src/auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    database: {
        provider: "postgres", //change this to your database provider
        url: process.env.DATABASE_URL, // path to your database or connection string
    }
})
```

## Create API Route

We need to mount the handler to a API route. Create a directory for Waku's file system router at `src/pages/api/auth`. Create a catch-all route file `[...route].ts` inside the `src/pages/api/auth` directory. And add the following code:

```ts title="src/pages/_api/api/auth/[...route].ts"
import { auth } from "../../../../auth" // Adjust the path as necessary

export const GET = async (request: Request): Promise<Response> => {
  return auth.handler(request)
}

export const POST = async (request: Request): Promise<Response> => {
  return auth.handler(request)
}
```

<Callout type="info">
 You can change the path on your better-auth configuration but it's recommended to keep it as `src/pages/_api/api/auth/[...route].ts`
</Callout>

## Create a client

Create a client instance. Here we are creating `auth-client.ts` file inside the `lib/` directory.

```ts title="src/lib/auth-client.ts"
import { createAuthClient } from "better-auth/react" // make sure to import from better-auth/react

export const authClient = createAuthClient({
    //you can pass client configuration here
})

export type Session = typeof authClient.$Infer.Session // you can infer typescript types from the authClient
```

Once you have created the client, you can use it to sign up, sign in, and perform other actions.
Some of the actions are reactive. The client uses [nano-store](https://github.com/nanostores/nanostores) to store the state and re-render the components when the state changes.

The client also uses [better-fetch](https://github.com/bekacru/better-fetch) to make the requests. You can pass the fetch configuration to the client.

## RSC and Server actions

The `api` object exported from the auth instance contains all the actions that you can perform on the server. Every endpoint made inside Better Auth is a invocable as a function. Including plugins endpoints.

**Example: Getting Session on a server action**

```tsx title="server.ts"
"use server" // Waku currently only supports file-level "use server"

import { auth } from "./auth"
import { unstable_getHeaders as getHeaders } from "waku/server"

export const someAuthenticatedAction = async () => {
  "use server"
  const headers = getHeaders()
  const session = await auth.api.getSession({
      headers,
  })
};
```

**Example: Getting Session on a RSC**


```tsx
import { auth } from "../auth"
import { unstable_getHeaders as getHeaders } from "waku/server"

export async function ServerComponent() {
  const headers = getHeaders()
  const session = await auth.api.getSession({
      headers,
  })
  if(!session) {
      return <div>Not authenticated</div>
  }
  return (
      <div>
          <h1>Welcome {session.user.name}</h1>
      </div>
  )
}
```

<Callout type="warn">RSCs that run after the response has started streaming cannot set cookies. The [cookie cache](/docs/concepts/session-management#cookie-cache) will not be refreshed until the server is interacted with from the client via Server Actions or Route Handlers.</Callout>

### Server Action Cookies

When you call a function that needs to set cookies, like `signInEmail` or `signUpEmail` in a server action, cookies won’t be set.

We can create a plugin that works together with our middleware to set cookies.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { unstable_getContextData as getContextData } from "waku/server"

export const auth = betterAuth({
    //...your config
    plugins: [wakuCookies()] // make sure this is the last plugin in the array // [!code highlight]
})

function wakuCookies() {
  return {
    id: "waku-cookies",
    hooks: {
      after: [
        {
          matcher(ctx) {
            return true;
          },
          handler: createAuthMiddleware(async (ctx) => {
            const returned = ctx.context.responseHeaders;
            if ("_flag" in ctx && ctx._flag === "router") {
              return;
            }
            if (returned instanceof Headers) {
              const setCookieHeader = returned?.get("set-cookie");
              if (!setCookieHeader) return;
              const contextData = getContextData();
              contextData.betterAuthSetCookie = setCookieHeader;
            }
          }),
        },
      ],
    },
  } satisfies BetterAuthPlugin;
}
```

See below for the middleware to create to add the `contextData.betterAuthSetCookie` cookies to the response.
Now, when you call functions that set cookies, they will be automatically set.

```ts
"use server";
import { auth } from "../auth"

const signIn = async () => {
    await auth.api.signInEmail({
        body: {
            email: "user@email.com",
            password: "password",
        }
    })
}
```

### Middleware

In Waku middleware, it's recommended to only check for the existence of a session cookie to handle redirection. This avoids blocking requests by making API or database calls.

You can use the `getSessionCookie` helper from Better Auth for this purpose:

<Callout type="warn">
The <code>getSessionCookie()</code> function does not automatically reference the auth config specified in <code>auth.ts</code>. Therefore, if you customized the cookie name or prefix, you need to ensure that the configuration in <code>getSessionCookie()</code> matches the config defined in your <code>auth.ts</code>.
</Callout>

```ts title="src/middleware/auth.ts"
import type { MiddlewareHandler } from "hono"
import { getSession } from "../auth"
import { getSessionCookie } from "better-auth/cookies"
import type { MiddlewareHandler } from "hono";
import { unstable_getContextData as getContextData } from "waku/server";

const authMiddleware: () => MiddlewareHandler = () => {
  return async (c, next) => {
    const reqUrl = new URL(c.req.url);
    const sessionCookie = getSessionCookie(c.req.raw);
    // THIS IS NOT SECURE!
    // This is the recommended approach to optimistically redirect users
    // We recommend handling auth checks in each page/route
    if (
      !sessionCookie &&
      reqUrl.pathname !== "/" &&
      !reqUrl.pathname.startsWith("/api")
    ) {
      if (!reqUrl.pathname.endsWith(".txt")) {
        // Currently RSC requests end in .txt and don't handle redirect responses
        // The redirect needs to be encoded in the React flight stream somehow
        // There is some functionality in Waku to do this from a server component
        // but not from middleware.
        return c.redirect("/", 302);
      }
    }

    // TODO possible to inspect c.req.url and not do this on every request
    // Or skip starting the promise here and just invoke from server components and functions
    getSession();
    await next();
    const contextData = getContextData();
    const betterAuthSetCookie = contextData.betterAuthSetCookie as
      | string
      | undefined;
    if (betterAuthSetCookie) {
      c.header("set-cookie", betterAuthSetCookie, { append: true });
    }
  };
};

export default authMiddleware;
```

<Callout type="warn">
	**Security Warning:** The `getSessionCookie` function only checks for the
	existence of a session cookie; it does **not** validate it. Relying solely
	on this check for security is dangerous, as anyone can manually create a
	cookie to bypass it. You must always validate the session on your server for
	any protected actions or pages.
</Callout>

<Callout type="info">
If you have a custom cookie name or prefix, you can pass it to the `getSessionCookie` function.
```ts
const sessionCookie = getSessionCookie(request, {
    cookieName: "my_session_cookie",
    cookiePrefix: "my_prefix"
})
```
</Callout>

Alternatively, you can use the `getCookieCache` helper to get the session object from the cookie cache.

```ts
import { getCookieCache } from "better-auth/cookies"

const authMiddleware: () => MiddlewareHandler = () => {
    return async (c, next) => {
        const reqUrl = new URL(c.req.url);
        const session = await getCookieCache(c.req.raw)
        if (!session && reqUrl.pathname !== "/") {
            if (!reqUrl.pathname.endsWith(".txt")) {
                ctx.res.status = 302
                ctx.res.headers = {
                    Location: new URL("/", reqUrl).toString(),
                }
            }
        }
    }
    await next();
  }
}

export default authMiddleware;
```

If you place your middleware file in `./src/middleware`, it will automatically get loaded by Waku's default server adapter.

### How to handle auth checks in each page/route

In this example, we are using the `auth.api.getSession` function within a server component to get the session object,
then we are checking if the session is valid. If it's not, we are redirecting the user to the sign-in page.
Waku has `getContext` to get the request headers and `getContextData()` to store data per request. We can use this
to avoid fetching the session more than once per request.

```ts title="auth.ts"
import { unstable_getContext as getContext, unstable_getContextData as getContextData } from "waku/server";

// Code from above to create the server auth config
// export const auth = ...

export function getSession(): Promise<Session | null> {
  const contextData = getContextData();
  const ctx = getContext();
  const existingSessionPromise = contextData.sessionPromise as
    | Promise<Session | null>
    | undefined;
  if (existingSessionPromise) {
    return existingSessionPromise;
  }
  const sessionPromise = auth.api.getSession({
    headers: new Headers(ctx.req.headers),
  });
  contextData.sessionPromise = sessionPromise;
  return sessionPromise;
}
```


```tsx title="src/pages/dashboard.tsx"
import { getSession } from "../auth";
import { unstable_redirect as redirect } from 'waku/router/server';

export default async function DashboardPage() {
    const session = await getSession()

    if (!session) {
        redirect("/sign-in")
    }

    return (
        <div>
            <h1>Welcome {session.user.name}</h1>
        </div>
    )
}
```

### Example usage

#### Sign Up

```ts title="src/components/signup.tsx"
"use client"

import { useState } from "react"
import { authClient } from "../lib/auth-client"

export default function SignUp() {
  const [email, setEmail] = useState("")
  const [name, setName] = useState("")
  const [password, setPassword] = useState("")

  const signUp = async () => {
    await authClient.signUp.email(
      {
        email,
        password,
        name,
      },
      {
        onRequest: (ctx) => {
          // show loading state
        },
        onSuccess: (ctx) => {
          // redirect to home
        },
        onError: (ctx) => {
          alert(ctx.error)
        },
      },
    )
  }

  return (
    <div>
      <h2>
        Sign Up
      </h2>
      <form
        onSubmit={signUp}
      >
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Name"
        />
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
        />
        <button
          type="submit"
        >
          Sign Up
        </button>
      </form>
    </div>
  )
}

```

#### Sign In

```ts title="src/components/signin.tsx"
"use client"

import { useState } from "react"
import { authClient } from "../lib/auth-client"

export default function SignIn() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")

  const signIn = async () => {
    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onRequest: (ctx) => {
          // show loading state
        },
        onSuccess: (ctx) => {
          // redirect to home
        },
        onError: (ctx) => {
          alert(ctx.error)
        },
      },
    )
  }

  return (
    <div>
      <h2>
        Sign In
      </h2>
      <form onSubmit={signIn}>
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <button
          type="submit"
        >
          Sign In
        </button>
      </form>
    </div>
  )
}
```
---
title: Convex Integration
description: Integrate Better Auth with Convex.
---

In this guide, we'll walk through the steps to integrate Better Auth with [Convex](https://www.convex.dev).

<Steps>
<Step>
## Prerequisites

### Create a Convex project

To use Better Auth with Convex, you need a Convex project. If you don’t have one, run the following command to create a new project. For more details, see the [Convex documentation](https://docs.convex.dev/home).

```package-install
npm create convex@latest

# Choose user authentication:
# > none
```

### Run `convex dev`

Running the CLI during setup will initialize your Convex deployment
if it doesn't already exist, and keeps generated types current through the process. Keep it running.

```package-install
npx convex dev
```
</Step>

<Step>
## Install packages

Install a pinned version of Better Auth and the Convex component for Better Auth, and make sure you are using the latest version of Convex.

```package-install
npm install better-auth@1.4.9 --save-exact
npm install @convex-dev/better-auth
```

<Callout type="info">
`@convex-dev/better-auth` is maintained by Convex. For issues or more details, please visit [here](https://github.com/get-convex/better-auth).
</Callout>
</Step>

<Step>
## Set environment variables

Generate a secret for encryption and generating hashes. Use the command below if you have openssl installed, or use `npx auth secret` to generate one.

```package-install
npx convex env set BETTER_AUTH_SECRET=$(openssl rand -base64 32)
```

Add your site URL to your Convex deployment.

```package-install
npx convex env set SITE_URL http://localhost:3000
```

Add environment variables to the `.env.local` file created by `npx convex dev`.
It will be picked up by your framework dev server.

```sh title=".env.local" tab="Cloud"
# Deployment used by `npx convex dev`
CONVEX_DEPLOYMENT=dev:adjective-animal-123 # team: team-name, project: project-name

NEXT_PUBLIC_CONVEX_URL=https://adjective-animal-123.convex.cloud

# Same as NEXT_PUBLIC_CONVEX_URL but ends in .site // [!code ++]
NEXT_PUBLIC_CONVEX_SITE_URL=https://adjective-animal-123.convex.site # [!code ++]

# Your local site URL // [!code ++]
NEXT_PUBLIC_SITE_URL=http://localhost:3000 # [!code ++]
```

```sh title=".env.local" tab="Self hosted"
# Deployment used by `npx convex dev`
CONVEX_DEPLOYMENT=dev:adjective-animal-123 # team: team-name, project: project-name

NEXT_PUBLIC_CONVEX_URL=http://127.0.0.1:3210

# Will generally be one number higher than NEXT_PUBLIC_CONVEX_URL,
# so if your convex url is :3212, your site url will be :3213
NEXT_PUBLIC_CONVEX_SITE_URL=http://127.0.0.1:3211 # [!code ++]

# Your local site URL // [!code ++]
NEXT_PUBLIC_SITE_URL=http://localhost:3000 # [!code ++]
```

<Callout type="info">
Since the Better Auth instance runs on Convex, environment variables used by the auth instance should be configured through the Convex CLI or dashboard, not in `.env.local`.

e.g. `BETTER_AUTH_SECRET`, `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET` ...
</Callout>
</Step>

<Step>
## Add Convex auth config

Add a `convex/auth.config.ts` file to configure Better Auth as an authentication provider.

```ts title="convex/auth.config.ts"
import { getAuthConfigProvider } from "@convex-dev/better-auth/auth-config";
import type { AuthConfig } from "convex/server";

export default {
  providers: [getAuthConfigProvider()],
} satisfies AuthConfig;
```
</Step>

<Step>
## Create the Better Auth Convex Component

Convex components can be installed from NPM or a local folder. While the NPM version is available [here](https://www.convex.dev/components/better-auth), this guide uses a local folder setup to unlock the full potential of Better Auth.

### Create the component definition

Create a `convex/betterAuth/convex.config.ts` file to define the component. This will signal to Convex that the `convex/betterAuth` directory is a locally installed component.

```ts title="convex/betterAuth/convex.config.ts"
import { defineComponent } from "convex/server";

const component = defineComponent("betterAuth");

export default component;
```
### Register the component

Register the Better Auth component in your Convex project.

```ts title="convex/convex.config.ts"
import { defineApp } from "convex/server";
import betterAuth from "./betterAuth/convex.config";

const app = defineApp();

app.use(betterAuth);

export default app;
```

### Create a Better Auth instance

Create a Better Auth instance and initialize the component.

<Callout type="info">
- This file is not yet complete before the next step.
- Some TypeScript errors will show until you save the file.
</Callout>

```ts title="convex/betterAuth/auth.ts"
import { createClient } from "@convex-dev/better-auth";
import { convex } from "@convex-dev/better-auth/plugins";
import type { GenericCtx } from "@convex-dev/better-auth/utils";
import type { BetterAuthOptions } from "better-auth";
import { betterAuth } from "better-auth";
import { components } from "../_generated/api";
import type { DataModel } from "../_generated/dataModel";
import authConfig from "../auth.config";
import schema from "./schema";

// Better Auth Component
export const authComponent = createClient<DataModel, typeof schema>(
  components.betterAuth,
  {
    local: { schema },
    verbose: false,
  },
);

// Better Auth Options
export const createAuthOptions = (ctx: GenericCtx<DataModel>) => {
  return {
    appName: "My App",
    baseURL: process.env.SITE_URL,
    secret: process.env.BETTER_AUTH_SECRET,
    database: authComponent.adapter(ctx),
    emailAndPassword: {
      enabled: true,
    },
    plugins: [convex({ authConfig })],
  } satisfies BetterAuthOptions;
};

// For `auth` CLI
export const options = createAuthOptions({} as GenericCtx<DataModel>);

// Better Auth Instance
export const createAuth = (ctx: GenericCtx<DataModel>) => {
  return betterAuth(createAuthOptions(ctx));
};
```

### Generate the schema

After configuring your Better Auth instance, create a `convex/betterAuth/schema.ts` file and run the command below to generate the schema.

```package-install
npx auth generate --config ./convex/betterAuth/auth.ts --output ./convex/betterAuth/schema.ts
```

<Callout type="info">
If you need to modify your Better Auth instance, use this command to update the schema.
</Callout>

### Export adapter functions

Export adapter functions for the Better Auth component.

```ts title="convex/betterAuth/adapter.ts"
import { createApi } from "@convex-dev/better-auth";
import { createAuthOptions } from "./auth";
import schema from "./schema";

export const {
  create,
  findOne,
  findMany,
  updateOne,
  updateMany,
  deleteOne,
  deleteMany,
} = createApi(schema, createAuthOptions);
```
</Step>

<Step>
## Create the Better Auth client instance

Create the Better Auth client instance for interacting with the Better Auth server from your client.

```ts title="lib/auth-client.ts"
import { convexClient } from "@convex-dev/better-auth/client/plugins";
import { createAuthClient } from "better-auth/react";

export const authClient = createAuthClient({
  plugins: [convexClient()],
});
```
</Step>

<Step>
## Configure Next.js server helpers

Configure a set of helper functions for authenticated SSR, server functions, and route handlers.

```ts title="lib/auth-server.ts"
import { convexBetterAuthNextJs } from "@convex-dev/better-auth/nextjs";

export const {
  handler,
  preloadAuthQuery,
  isAuthenticated,
  getToken,
  fetchAuthQuery,
  fetchAuthMutation,
  fetchAuthAction,
} = convexBetterAuthNextJs({
  convexUrl: process.env.NEXT_PUBLIC_CONVEX_URL!,
  convexSiteUrl: process.env.NEXT_PUBLIC_CONVEX_SITE_URL!,
});
```
</Step>

<Step>
## Mount handlers

Register Better Auth route handlers on your Convex deployment.

```ts title="convex/http.ts"
import { httpRouter } from "convex/server";
import { authComponent, createAuth } from "./betterAuth/auth";

const http = httpRouter();

authComponent.registerRoutes(http, createAuth);

export default http;
```

Set up route handlers to proxy auth requests from Next.js to your Convex deployment.

```ts title="app/api/auth/[...all]/route.ts"
import { handler } from "@/lib/auth-server";

export const { GET, POST } = handler;
```
</Step>

<Step>
## Set up Convex client provider

Create a `ConvexClientProvider` component.

```tsx title="components/ConvexClientProvider.tsx"
"use client";

import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
import { ConvexReactClient } from "convex/react";
import { authClient } from "@/lib/auth-client";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({
  children,
  initialToken,
}: {
  children: React.ReactNode;
  initialToken?: string | null;
}) {
  return (
    <ConvexBetterAuthProvider
      client={convex}
      authClient={authClient}
      initialToken={initialToken}
    >
      {children}
    </ConvexBetterAuthProvider>
  );
}
```

Wrap your app with the `ConvexClientProvider` component.

```tsx title="app/layout.tsx"
import { ConvexClientProvider } from "@/components/ConvexClientProvider";
import { getToken } from "@/lib/auth-server";

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const token = await getToken();
  return (
    <html>
      <body>
        <ConvexClientProvider initialToken={token}>
          {children}
        </ConvexClientProvider>
      </body>
    </html>
  );
}
```
</Step>
</Steps>

## Done 🎉

You're now ready to start using Better Auth with Convex.

---

## Usage

### Create your functions

Better Auth's `auth.api` methods would normally run in your server, but with Convex being your backend, these methods need to run in a Convex function. The Convex function can then be called from the client via hooks like `useMutation` or in server functions and other server code using one of the auth-server utilities like `fetchAuthMutation`.

Convex has a convention of creating functions in the `convex/` directory. For example, you can create auth-related functions in the `convex/auth.ts` file like this:

```ts title="convex/auth.ts"
import { query } from "./_generated/server";

export const getCurrentUser = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    return identity;
  },
});

// ... other functions
```

### Using the Better Auth client

You can use the `authClient` like the Better Auth client normally.

```tsx title="app/sign-in/page.tsx"
"use client";

import { Button } from "@/components/ui/button";
import { authClient } from "@/lib/auth-client";

const Page = () => {
  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <Button
        onClick={async () => {
          await authClient.signIn.social({
            provider: "github",
            callbackURL: "/dashboard",
          });
        }}
      >
        Sign in with GitHub
      </Button>
    </div>
  );
};

export default Page;
```

### Using the Convex React hooks

If you've created Convex functions, you can use the Convex React hooks to query or mutate data in the client side like the usual way.

```tsx title="app/dashboard/page.tsx"
"use client";

import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";

const Page = () => {
  const user = useQuery(api.auth.getCurrentUser);

  if (user === undefined) {
    return <div>Loading...</div>;
  }

  if (user === null) {
    return <div>Unauthorized</div>;
  }

  return (
    <div>
      <pre>{JSON.stringify(user, null, 2)}</pre>
    </div>
  );
};

export default Page;
```

### Using the server helpers

You can use the server helpers to perform authentication related operations in the server side.

```tsx title="app/protected/page.tsx"
import { isAuthenticated } from "@/lib/auth-server";

const Page = async () => {
  const hasToken = await isAuthenticated();
  if (!hasToken) {
    return <div>Unauthorized</div>;
  }

  return (
    <div>
      <p>Hello</p>
    </div>
  );
};

export default Page;
```

### SSR with server components

Convex queries can be preloaded in server components and rendered in client components via `preloadAuthQuery` and `usePreloadedAuthQuery`.

<Callout type="info">
`preloadAuthQuery` is recommended for use when you want to handle different UI based on the data state, rather than for protecting resources.
</Callout>

*Preloading in a server component:*

```tsx title="app/landing/page.tsx"
import { api } from "@/convex/_generated/api";
import { preloadAuthQuery } from "@/lib/auth-server";
import Header from "./header";

const Page = async () => {
  const preloadedUserQuery = await preloadAuthQuery(api.auth.getCurrentUser);

  return (
    <div>
      <Header preloadedUserQuery={preloadedUserQuery} />
    </div>
  );
};

export default Page;
```

*Rendering preloaded data in a client component:*

```tsx title="app/landing/header.tsx"
"use client";

import { usePreloadedAuthQuery } from "@convex-dev/better-auth/nextjs/client";
import type { Preloaded } from "convex/react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import type { api } from "@/convex/_generated/api";

export const Header = ({
  preloadedUserQuery,
}: {
  preloadedUserQuery: Preloaded<typeof api.auth.getCurrentUser>;
}) => {
  const user = usePreloadedAuthQuery(preloadedUserQuery);
  return (
    <div>
      {user ? (
        <Button asChild>
          <Link href="/dashboard">Dashboard</Link>
        </Button>
      ) : (
        <Button asChild>
          <Link href="/sign-in">Sign in</Link>
        </Button>
      )}
    </div>
  );
};

export default Header;
```

## Additional Resources

- [Convex Documentation](https://docs.convex.dev/home)
- [`@convex-dev/better-auth` Documentation](https://labs.convex.dev/better-auth)
- [`@convex-dev/better-auth` GitHub Repository](https://github.com/get-convex/better-auth)---
title: Elysia Integration
description: Integrate Better Auth with Elysia.
---

This integration guide is assuming you are using Elysia with bun server.

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

### Mount the handler

We need to mount the handler to Elysia endpoint.

```ts
import { Elysia } from "elysia";
import { auth } from "./auth";

const app = new Elysia().mount(auth.handler).listen(3000);

console.log(
  `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port}`,
);
```

### CORS

To configure cors, you can use the `cors` plugin from `@elysiajs/cors`.

```ts
import { Elysia } from "elysia";
import { cors } from "@elysiajs/cors";

import { auth } from "./auth";

const app = new Elysia()
  .use(
    cors({
      origin: "http://localhost:3001",
      methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
      credentials: true,
      allowedHeaders: ["Content-Type", "Authorization"],
    }),
  )
  .mount(auth.handler)
  .listen(3000);

console.log(
  `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port}`,
);
```

### Macro

You can use [macro](https://elysiajs.com/patterns/macro.html#macro) with [resolve](https://elysiajs.com/essential/handler.html#resolve) to provide session and user information before pass to view.

```ts
import { Elysia } from "elysia";
import { auth } from "./auth";

// user middleware (compute user and session and pass to routes)
const betterAuth = new Elysia({ name: "better-auth" })
  .mount(auth.handler)
  .macro({
    auth: {
      async resolve({ status, request: { headers } }) {
        const session = await auth.api.getSession({
          headers,
        });

        if (!session) return status(401);

        return {
          user: session.user,
          session: session.session,
        };
      },
    },
  });

const app = new Elysia()
  .use(betterAuth)
  .get("/user", ({ user }) => user, {
    auth: true,
  })
  .listen(3000);

console.log(
  `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port}`,
);
```

This will allow you to access the `user` and `session` object in all of your routes.
---
title: Electron Integration
description: Integrate Better Auth with Electron.
---

Electron is a popular framework for building cross-platform desktop applications using web technologies.

Better Auth can be integrated into Electron apps to provide secure authentication flows, leveraging the system browser.

## Installation

<Steps>
  <Step>
    ### Configure a Better Auth front- & back-end
    
    Before integrating with Electron, ensure you have a Better Auth server and client set up.
    
    To get started, check out our [installation](/docs/installation) guide for setting up Better Auth.
  </Step>
  
  <Step>
    ### Install the required packages

    Install the Better Auth server package and the Electron integration package in your server, Electron app, and web client projects.

    **In each project, run:**

    ```package-install
    better-auth @better-auth/electron
    ```

    <Callout type="info">
      We support two major versions behind the latest stable major release of Electron.
      This keeps you on versions that receive security updates and aligns with [Electron's version support policy](https://www.electronjs.org/docs/latest/tutorial/electron-timelines#breaking-api-changes).
    </Callout>

  </Step>
  
  <Step>
    ### Add the Electron plugin to your Better Auth server
  
    Add the Electron plugin to your Better Auth server.
    
    ```ts title="web/lib/auth.ts"
    import { betterAuth } from "better-auth";
    import { electron } from "@better-auth/electron";
    
    export const auth = betterAuth({
      plugins: [electron()],
      emailAndPassword: {
        enabled: true,
      },
      social: {
        google: {
          clientId: process.env.GOOGLE_CLIENT_ID!,
          clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
        },
      },
    });
    ```
  </Step>
  
  <Step>
    ### Add the proxy plugin to your web client

    On your frontend, add the proxy plugin to handle redirects back into the Electron app.

    ```ts title="web/lib/auth-client.ts"
    import { createAuthClient } from "better-auth/client";
    import { electronProxyClient } from "@better-auth/electron/proxy";

    export const authClient = createAuthClient({
      baseURL: "http://localhost:8081",
      plugins: [
        electronProxyClient({
          protocol: {
            scheme: "com.example.app"
          },
        }),
      ],
    });
    ```

  </Step>
  
  <Step>
      ### Initialize the Electron client
  
      ```ts title="electron/lib/auth-client.ts"
      import { createAuthClient } from "better-auth/client";
      import { electronClient } from "@better-auth/electron/client";
      
      export const authClient = createAuthClient({
        baseURL: "http://localhost:8081", // Base URL of your Better Auth frontend
        plugins: [
          electronClient({
            signInURL: "https://app.example.com/sign-in", // The URL to redirect to for authentication
            protocol: {
              scheme: "com.example.app" // The custom protocol scheme registered by your Electron app
            },
            storage: {
              getItem: async (key) => {
                // retrieve entry from storage
              },
              setItem: async (key, value) => {
                // set entry in storage
              },
            },
          }),
        ],
      });
      ```
      
      If you'd rather not implement your own storage solution, we offer a default option:
      
      1. Make sure to install the `conf` package:
      ```package-install
      conf
      ```
      2. Then, you can use it as follows:
      
      ```ts title="electron/lib/auth-client.ts"
      import { storage } from "@better-auth/electron/storage";
      
      electronClient({
        storage: storage(),
      });
      ```

      <Callout type="warning">
          You should never expose the authClient directly
          to the renderer process. Instead, [create an IPC bridge](#creating-ipc-bridges) to securely communicate between the main and renderer processes.

          Also make sure not to expose any sensitive data like tokens or cookies to the renderer process to mitigate injection attacks.
      </Callout>

  </Step>
  
  <Step>
      ### Scheme and Trusted Origins
  
      The Electron plugin uses deep links to redirect users back to your app after authentication.
      To enable this, you need to add your app's protocol scheme to the `trustedOrigins` on your **Better Auth server**.
      
      First, make sure you have a custom protocol scheme registered in your build configuration.
      
      <Tabs items={["electron-forge", "electron-builder"]}>
        <Tab value="electron-forge">
          ```ts title="forge.config.js"
          module.exports = {
            packagerConfig: {
              protocols: [{
                name: "MyApp Protocol",
                schemes: ["com.example.app"],
              }],
            },
            // ...other config options
          };
          ```
        </Tab>
        
        <Tab value="electron-builder">
        ```ts title="electron-builder.json5"
        {
          "protocols": [
            {
              "name": "MyApp Protocol",
              "schemes": ["com.example.app"]
            }
          ],
          // ...other config options
        }
        ```
        </Tab>
      </Tabs>
      
      Then, update your Better Auth config to include the scheme in `trustedOrigins`:
      
      ```ts title="web/lib/auth.ts"
      export const auth = betterAuth({
        trustedOrigins: ["com.example.app:/"],
      });
      ```
  </Step>
  
  <Step>
      ### Configure the BrowserWindow
      
      Ensure that your `BrowserWindow` is configured with `nodeIntegration` set to `false` and `contextIsolation` set to `true`, to ensure NodeJS APIs aren't exposed to any JavaScript process running in the browser.
      
      ```ts title="electron/main.ts"
      import { BrowserWindow } from "electron";
      import { join } from "node:path";

      const win = new BrowserWindow({
        webPreferences: {
          preload: join(__dirname, "preload.mjs"),
          nodeIntegration: false,
          contextIsolation: true,
        },
      });
      ```

      <Callout type="warning">
        To run your process in `sandbox` mode, you need to ensure that `@better-auth/electron` is bundled into the preload script.
        Import only `@better-auth/electron/preload` inside the preload script with tree-shaking enabled, to avoid bundling unwanted dependencies.

        The following example uses electron-vite, but the concept applies to any bundler:

        ```ts title="electron.vite.config.ts"
        import { defineConfig } from "electron-vite";

        export default defineConfig({
          preload: {
            build: {
              externalizeDeps: { // [!code highlight]
                exclude: ["@better-auth/electron"], // [!code highlight]
              }, // [!code highlight]
            },
          },
        });
        ```

        If your config uses a list of externals instead, do **not** add `@better-auth/electron` to that list so it gets bundled.
      </Callout>

  </Step>
  
  <Step>
      ### Setup the Main Process
      
      In your Electron main process, use the `setupMain()` method from the Electron auth client to handle necessary configurations.
      
      This will:
      - Register the protocol handler for deep links.
      - Register the [user image proxy](#user-image-proxy) protocol.
      - Set up content security policies.
      - Set up IPC bridges for communication between main and renderer processes.
      
      ```ts title="electron/main.ts"
      import { authClient } from "./lib/auth-client";
      
      authClient.setupMain();
      ```
      
      Note that this must be called before the app is ready.
  </Step>
  
  <Step>
      ### Setup the Renderer Process

      In your preload script, use the `setupRenderer()` method from the Electron auth client to expose safe IPC bridges to the renderer process.

      ```ts title="electron/preload.ts"
      import { setupRenderer } from "@better-auth/electron/preload";

      setupRenderer();
      ```

      Note that this must also be called before the app is ready.

      <Callout type="info">
        To infer the types of the exposed bridges, you can use `authClient.$Infer.Bridges` to extend the `Window` interface.

        ```ts title="electron/preload.d.ts"
        import type { authClient } from "./lib/auth-client";

        declare global {
          type Bridges = typeof authClient.$Infer.Bridges;
          interface Window extends Bridges {}
        }
        ```
      </Callout>

  </Step>
</Steps>

## Usage

### Handling Authorization in the Browser

In order to redirect users back to your Electron application, you need to call the `ensureElectronRedirect()` method on your web sign-in callback page. Also make sure to preserve any PKCE and state parameters during the sign-in initiation, by passing them via `fetchOptions.query`.

The following example uses React, but the same logic applies to any framework:

```tsx title="web/pages/sign-in.tsx"
import { useEffect, use } from "react";
import { authClient } from "../auth-client";

function SignIn({
  searchParams,
}: {
  searchParams: Promise<{
    client_id?: string | undefined;
    state?: string | undefined;
    code_challenge?: string | undefined;
    code_challenge_method?: string | undefined;
  }>;
}) {
  const query = use(searchParams);

  useEffect(() => {
    const id = authClient.ensureElectronRedirect();
    return () => {
      clearTimeout(id);
    }
  }, []);

  return (
    <button
      onClick={() =>
        authClient.signIn.social({
          provider: "google",
          fetchOptions: { query }, // preserve PKCE/state
        });
      }
    >
      Sign in with Google
    </button>
  );
}
```

To handle already signed-in users, you can use the `electron.transferUser` method on the client and `electronTransferUser` on the server to transfer the user to the Electron app. [See Example](https://github.com/better-auth/better-auth/blob/main/demo/nextjs/app/(auth)/sign-in/_components/electron.tsx)

### Handling Authentication in Electron

In your Electron renderer process, you can use the IPC bridges exposed by the preload script.

```tsx title="electron/App.tsx"
function Auth() {
  useEffect(() => {
    const unsubscribeAuthenticated =
      window.onAuthenticated((user) => {
        console.log("Authenticated user:", user);
      });
    const unsubscribeAuthError =
      window.onAuthError((ctx) => {
        toast.error(`Authentication error: ${ctx.message}`);
      });

    return () => {
      unsubscribeAuthenticated();
      unsubscribeAuthError();
    };
  }, []);

  return (
    <>
      <button onClick={() => window.requestAuth()}>
        Sign in with Browser
      </button>
      <button
        onClick={() =>
          window.requestAuth({
            provider: "google", // sign in with social provider, redirecting directly to the provider
          });
        }
      >
        Sign in with Google
      </button>
    </>
  );
}
```

In the main process, you can call from the auth client directly:

```ts title="electron/main.ts"
import { authClient } from "./lib/auth-client";

authClient.requestAuth();
```

### Sign Out

To sign out the user inside the renderer process, you can use the `signOut` bridge in the renderer process:

```ts title="electron/App.tsx"
<button onClick={() => window.signOut()}>Sign out</button>
```

### Subscribing to User Updates

You can listen for user changes via the `onUserUpdated` bridge in the renderer process:

```ts title="electron/App.tsx"
useEffect(() => {
  const unsubscribe = window.onUserUpdated((user) => {
    console.log("User updated:", user);
  });
  return () => unsubscribe();
}, []);
```

### Handling Errors

Listen for authentication errors via the `onAuthError` bridge in the renderer process. The bridge will receive error context forwarded from fetch hooks.

```ts title="electron/error-listener.tsx"
useEffect(() => {
  const unsubscribe = window.onAuthError((ctx) => {
    console.error("Authentication error:", ctx);
  });
  return () => unsubscribe();
}, []);
```

### Manual Token Exchange

In some environments, deep link redirects may not work reliably (e.g. certain Linux desktop environments, sandboxed browsers, or when the Electron app isn't registered as the default handler for the protocol scheme).
As a fallback, users can manually copy the authorization code from the web UI and paste it into the Electron app.

**Front-end:**

After authentication completes, the authorization code is available via the `electron.getAuthorizationCode()` method on the proxy client. You can display this code to the user so they can copy it:

```tsx title="web/components/providers.tsx"
import { useEffect } from "react";
import { authClient } from "../auth-client";

function Providers({ children }) {
  useEffect(() => {
    const authorizationCode = authClient.electron.getAuthorizationCode();
    if (authorizationCode) {
      // Display the code to the user
      console.log("Authorization code:", authorizationCode);
    }
  }, []);

  return <>{children}</>;
}
```

The authorization code is also returned after a successful sign-in initiated from the Electron app or when using the `transferUser` method.


```tsx title="web/pages/sign-in.tsx"
const { data } = await authClient.electron.transferUser({
  fetchOptions: {
    query: params,
  },
});

if (data?.electron_authorization_code) {
  // Display the code to the user
}
```

**Electron:**

In the Electron renderer, provide an input for the user to paste the authorization code, then call `window.authenticate()` to exchange it for a session:

```tsx title="electron/App.tsx"
function ManualCodeEntry() {
  return (
    <input
      type="text"
      placeholder="Paste code here"
      maxLength={32}
      onChange={(e) => {
        if (e.target.value.length === 32) {
          // Important: requestAuth() must have been called before
          window.authenticate({ token: e.target.value }); // [!code highlight]
        }
      }}
    />
  );
}
```

The `authenticate` bridge sends the authorization code to the main process, which exchanges it for a session using the stored PKCE code verifier and state. On success, the `onAuthenticated` bridge is triggered.

<Callout type="info">
  The authorization code is a short-lived 32-character string. A `requestAuth()` call must have been made before `authenticate()` can be used, as it relies on the code verifier and state generated during the initial request.
</Callout>

### User Image Proxy

To avoid CSP issues, the Electron plugin securely proxies user avatar images through a custom `user-image://` protocol.

You can use the image URL directly in your renderer:

```tsx title="electron/App.tsx"
<img src={user.image} alt="Avatar" />
{/* or <img src="user-image://<user-id>" /> */}
```

To configure or disable the proxy, see the [`userImageProxy`](#userimageproxy) option.

### Creating IPC bridges

You should create IPC bridges to extend the functionality exposed to your renderer process. This ensures a minimal, safe API surface.

First, create an IPC handler in the main process that uses the `authClient` to perform the desired action:

```ts title="electron/main.ts"
import { authClient } from "./lib/auth-client";
import { ipcMain } from "electron";

ipcMain.handle("myBridge", async (_event, data) => {
  const cookie = authClient.getCookie();
  return await authClient.someEndpoint({
    data,
    fetchOptions: {
      headers: { cookie },
    },
  });
});
```

Next, expose the bridge in your preload script using `contextBridge`:

```ts title="electron/preload.ts"
import { contextBridge, ipcRenderer } from "electron";

contextBridge.exposeInMainWorld("myBridge", (data: Record<string, any>) => {
  return ipcRenderer.invoke("myBridge", data);
});
```

<Callout type="info">
    To infer the types of your bridge, extend the `Window` interface:

    ```ts title="electron/preload.d.ts"
    import type { authClient } from "./lib/auth-client";

    declare global {
      type Bridges = typeof authClient.$Infer.Bridges;
      interface Window extends Bridges {
        myBridge: (data: Record<string, any>) => Promise<any>;
      }
    }
    ```

</Callout>

Now you can call your custom bridge from anywhere in the renderer process:

```ts title="electron/App.tsx"
useEffect(() => {
  window
    .myBridge({
      foo: "bar",
    })
    .then((res) => {
      console.log("Bridge response:", res);
    });
}, []);
```

For more details, check out Electron's [Inter-Process Communication](https://www.electronjs.org/docs/latest/tutorial/ipc) tutorial.

## Options

### Server plugin

#### `codeExpiresIn?`

The duration, in seconds, for which the authorization code is valid. (defaults to `300`)

Note that the authorization code will be refreshed during active endpoint usage.

```ts title="web/auth.ts"
electron({
  codeExpiresIn: 300, // 5 minutes
});
```

#### `redirectCookieExpiresIn?`

The duration, in seconds, for which the redirect cookie remains valid. (defaults to `120`)

```ts title="web/auth.ts"
electron({
  redirectCookieExpiresIn: 120, // 2 minutes
});
```

The redirect cookie name is derived by the `clientID`.

#### `cookiePrefix?`

The prefix to use for cookies set by the plugin. (defaults to `better-auth`)

```ts title="web/auth.ts"
electron({
  cookiePrefix: "better-auth",
});
```

#### `clientID?`

The client id to use for identifying the Electron client during authorization. (defaults to `electron`)

Make sure this matches the clientID provided to both the proxy and electron client plugin.

```ts title="web/auth.ts"
electron({
  clientID: "electron",
});
```

#### `disableOriginOverride?`

Override the origin for Electron API routes. (defaults to `false`)

Enable this if you're facing cors origin issues with Electron API routes.

```ts title="web/auth.ts"
electron({
  disableOriginOverride: true,
});
```

### Proxy client

#### `protocol`

The protocol scheme to use for deep linking in Electron.

Should follow the [reverse domain name notation](https://datatracker.ietf.org/doc/html/rfc8252#section-7.1) to ensure uniqueness.

Make sure this matches the protocol scheme provided to the Electron client and `trustedOrigins`.

```ts title="web/auth-client.ts"
electronProxyClient({
  protocol: "com.example.app",
});
```

```ts title="web/auth-client.ts"
electronProxyClient({
  protocol: {
    scheme: "com.example.app",
  },
});
```

#### `callbackPath?`

The callback path to use for authentication redirects. (defaults to `/auth/callback`)

Make sure this matches the path provided to the electron client plugin.

```ts title="web/auth-client.ts"
electronProxyClient({
  callbackPath: "/auth/callback",
});
```

#### `clientID?`

The client id to use for identifying the Electron client during authorization. (defaults to `electron`)

Make sure this matches the clientID provided to both the server and electron client plugin.

```ts title="web/auth-client.ts"
electronProxyClient({
  clientID: "electron",
});
```

#### `cookiePrefix?`

The prefix to use for cookies set by the plugin. (defaults to `better-auth`)

```ts title="web/auth-client.ts"
electronProxyClient({
  cookiePrefix: "better-auth",
});
```

### Client plugin

#### `signInURL`

The URL to redirect to for authentication.

```ts title="electron/auth-client.ts"
electronClient({
  signInURL: "http://localhost:3000/sign-in",
});
```

#### `protocol`

The protocol scheme to use for deep linking in Electron.

Should follow the [reverse domain name notation](https://datatracker.ietf.org/doc/html/rfc8252#section-7.1) to ensure uniqueness.

Make sure this matches the protocol scheme provided to the proxy client and `trustedOrigins`.

```ts title="web/auth-client.ts"
electronProxyClient({
  protocol: "com.example.app",
});
```

```ts title="web/auth-client.ts"
electronProxyClient({
  protocol: {
    scheme: "com.example.app",
  },
});
```

#### `callbackPath?`

The callback path to use for authentication redirects. (defaults to `/auth/callback`)

Make sure this matches the path provided to the proxy client plugin.

```ts title="electron/auth-client.ts"
electronClient({
  callbackPath: "/auth/callback",
});
```

#### `storage`

Storage solution to use to store session and cookie data.

By default a storage file is generated in the `userData` directory. The name is derived by the project name.

```ts title="electron/auth-client.ts"
electronClient({
  storage: {
    getItem: (key) => {
      // get entry from storage
    },
    setItem: (key, value) => {
      // set entry in storage
    },
  },
});
```

#### `storagePrefix?`

Prefix for local storage keys. (defaults to `better-auth`)

```ts title="electron/auth-client.ts"
electronClient({
  storagePrefix: "better-auth",
});
```

#### `cookiePrefix?`

Prefix(es) for server cookie names to filter. (defaults to `better-auth`)

This is used to identify which cookies belong to better-auth to
prevent infinite refetching when third-party cookies are set.

```ts title="electron/auth-client.ts"
electronClient({
  cookiePrefix: "better-auth",
});
```

```ts title="electron/auth-client.ts"
electronClient({
  cookiePrefix: ["better-auth", "my-app"],
});
```

#### `channelPrefix?`

Channel prefix for IPC bridges. (defaults to `better-auth`)

```ts title="electron/auth-client.ts"
electronClient({
  channelPrefix: "myapp",
});
```

#### `clientID?`

The client id to use for identifying the Electron client during authorization. (defaults to `electron`)

Make sure this matches the clientID provided to both the server and proxy client plugin.

```ts title="electron/auth-client.ts"
electronClient({
  clientID: "electron",
});
```

#### `sanitizeUser?`

A function to sanitize the user object before it is sent to the renderer process. Use this to strip sensitive fields.

```ts title="electron/auth-client.ts"
electronClient({
  sanitizeUser: (user) => {
    const { sensitiveField, ...rest } = user;
    return rest;
  },
});
```

#### `userImageProxy?`

Configuration for the user image proxy. See [User Image Proxy](#user-image-proxy) for details.

```ts title="electron/auth-client.ts"
electronClient({
  userImageProxy: {
    enabled: true, // default: true
    maxSize: 1024 * 1024 * 5, // default: 5MB
  },
});
```

To disable the proxy entirely:

```ts title="electron/auth-client.ts"
electronClient({
  userImageProxy: {
    enabled: false,
  },
});
```

#### `disableCache?`

Whether to disable caching the session data locally. (defaults to `false`)

```ts title="electron/auth-client.ts"
electronClient({
  disableCache: true,
});
```
---
title: Better Auth Fastify Integration Guide
description: Learn how to seamlessly integrate Better Auth with your Fastify application.
---

This guide provides step-by-step instructions for configuring both essential handlers and CORS settings.

<Callout type="important">
A configured Better Auth instance is required before proceeding. If you haven't set this up yet, please consult our [Installation Guide](/docs/installation).
</Callout>

### Prerequisites

Verify the following requirements before integration:

- **Node.js Environment**: v16 or later installed
- **ES Module Support**: Enable ES modules in either:
  - `package.json`: `{ "type": "module" }`
  - TypeScript `tsconfig.json`: `{ "module": "ESNext" }`
- **Fastify Dependencies**:
  ```package-install
  fastify @fastify/cors
  ```

<Callout type="tip"> For TypeScript: Ensure your `tsconfig.json` includes `"esModuleInterop": true` for optimal compatibility. </Callout>

### Authentication Handler Setup

Configure Better Auth to process authentication requests by creating a catch-all route:

```ts title="server.ts"
import Fastify from "fastify";
import { auth } from "./auth"; // Your configured Better Auth instance

const fastify = Fastify({ logger: true });

// Register authentication endpoint
fastify.route({
  method: ["GET", "POST"],
  url: "/api/auth/*",
  async handler(request, reply) {
    try {
      // Construct request URL
      const url = new URL(request.url, `http://${request.headers.host}`);
      
      // Convert Fastify headers to standard Headers object
      const headers = new Headers();
      Object.entries(request.headers).forEach(([key, value]) => {
        if (value) headers.append(key, value.toString());
      });

      // Create Fetch API-compatible request
      const req = new Request(url.toString(), {
        method: request.method,
        headers,
        ...(request.body ? { body: JSON.stringify(request.body) } : {}),
      });

      // Process authentication request
      const response = await auth.handler(req);

      // Forward response to client
      reply.status(response.status);
      response.headers.forEach((value, key) => reply.header(key, value));
      reply.send(response.body ? await response.text() : null);

    } catch (error) {
      fastify.log.error("Authentication Error:", error);
      reply.status(500).send({ 
        error: "Internal authentication error",
        code: "AUTH_FAILURE"
      });
    }
  }
});

// Initialize server
fastify.listen({ port: 4000 }, (err) => {
  if (err) {
    fastify.log.error(err);
    process.exit(1);
  }
  console.log("Server running on port 4000");
});
```

### Trusted origins

When a request is made from a different origin, the request will be blocked by default. You can add trusted origins to the `auth` instance.

```ts
export const auth = betterAuth({
  trustedOrigins: ["http://localhost:3000", "https://example.com"],
});
```

### Configuring CORS

Secure your API endpoints with proper CORS configuration:

```ts
import fastifyCors from "@fastify/cors";

// Configure CORS policies
fastify.register(fastifyCors, {
  origin: process.env.CLIENT_ORIGIN || "http://localhost:3000",
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: [
    "Content-Type",
    "Authorization",
    "X-Requested-With"
  ],
  credentials: true,
  maxAge: 86400
});

// Mount authentication handler after CORS registration
// (Use previous handler configuration here)
```

<Callout type="warning"> Always restrict CORS origins in production environments. Use environment variables for dynamic configuration. </Callout>
---
title: Next.js integration
description: Integrate Better Auth with Next.js.
---

Better Auth can be easily integrated with Next.js. Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

### Create API Route

We need to mount the handler to an API route. Create a route file inside `/api/auth/[...all]` directory. And add the following code:

```ts title="api/auth/[...all]/route.ts"
import { auth } from "@/lib/auth";
import { toNextJsHandler } from "better-auth/next-js";

export const { GET, POST } = toNextJsHandler(auth);
```

<Callout type="info">
 You can change the path on your better-auth configuration but it's recommended to keep it as `/api/auth/[...all]`
</Callout>


For `pages` route, you need to use `toNodeHandler` instead of `toNextJsHandler` and set `bodyParser` to `false` in the `config` object. Here is an example:

```ts title="pages/api/auth/[...all].ts"
import { toNodeHandler } from "better-auth/node"
import { auth } from "@/lib/auth"

// Disallow body parsing, we will parse it manually
export const config = { api: { bodyParser: false } }

export default toNodeHandler(auth.handler)
```

## Create a client

Create a client instance. You can name the file anything you want. Here we are creating `auth-client.ts` file inside the `lib/` directory.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/react" // make sure to import from better-auth/react

export const authClient =  createAuthClient({
    //you can pass client configuration here
})
```

Once you have created the client, you can use it to sign up, sign in, and perform other actions.
Some of the actions are reactive. The client uses [nano-store](https://github.com/nanostores/nanostores) to store the state and re-render the components when the state changes.

The client also uses [better-fetch](https://github.com/bekacru/better-fetch) to make the requests. You can pass the fetch configuration to the client.


## RSC and Server actions

The `api` object exported from the auth instance contains all the actions that you can perform on the server. Every endpoint made inside Better Auth is a invocable as a function. Including plugins endpoints.

**Example: Getting Session on a server action**

```tsx title="server.ts"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"

const someAuthenticatedAction = async () => {
    "use server";
    const session = await auth.api.getSession({
        headers: await headers()
    })
};
```

**Example: Getting Session on a RSC**


```tsx
import { auth } from "@/lib/auth"
import { headers } from "next/headers"

export async function ServerComponent() {
    const session = await auth.api.getSession({
        headers: await headers()
    })
    if(!session) {
        return <div>Not authenticated</div>
    }
    return (
        <div>
            <h1>Welcome {session.user.name}</h1>
        </div>
    )
}
```

<Callout type="warn">As RSCs cannot set cookies, the [cookie cache](/docs/concepts/session-management#cookie-cache) will not be refreshed until the server is interacted with from the client via Server Actions or Route Handlers.</Callout>

### Server Action Cookies

When you call a function that needs to set cookies, like `signInEmail` or `signUpEmail` in a server action, cookies won’t be set. This is because server actions need to use the `cookies` helper from Next.js to set cookies.

To simplify this, you can use the `nextCookies` plugin, which will automatically set cookies for you whenever a `Set-Cookie` header is present in the response.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { nextCookies } from "better-auth/next-js";

export const auth = betterAuth({
    //...your config
    plugins: [nextCookies()] // make sure this is the last plugin in the array // [!code highlight]
})
```

Now, when you call functions that set cookies, they will be automatically set.

```ts
"use server";
import { auth } from "@/lib/auth"

const signIn = async () => {
    await auth.api.signInEmail({
        body: {
            email: "user@email.com",
            password: "password",
        }
    })
}
```

## Auth Protection

In Next.js proxy/middleware, it's recommended to only check for the existence of a session cookie to handle redirection. To avoid blocking requests by making API or database calls.

### Next.js 16+ (Proxy)

Next.js 16 replaces "middleware" with "proxy". You can use the Node.js runtime for full session validation with database checks:

```ts title="proxy.ts"
import { NextRequest, NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

export async function proxy(request: NextRequest) {
    const session = await auth.api.getSession({
        headers: await headers()
    })

    // THIS IS NOT SECURE!
    // This is the recommended approach to optimistically redirect users
    // We recommend handling auth checks in each page/route
    if(!session) {
        return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    return NextResponse.next();
}

export const config = {
  matcher: ["/dashboard"], // Specify the routes the middleware applies to
};
```

For cookie-only checks (faster but less secure), use `getSessionCookie`:

```ts title="proxy.ts"
import { NextRequest, NextResponse } from "next/server";
import { getSessionCookie } from "better-auth/cookies";

export async function proxy(request: NextRequest) {
	const sessionCookie = getSessionCookie(request);

    // THIS IS NOT SECURE!
    // This is the recommended approach to optimistically redirect users
    // We recommend handling auth checks in each page/route
	if (!sessionCookie) {
		return NextResponse.redirect(new URL("/", request.url));
	}

	return NextResponse.next();
}

export const config = {
	matcher: ["/dashboard"], // Specify the routes the middleware applies to
};
```

<Callout type="info">
**Migration from middleware:** Rename `middleware.ts` → `proxy.ts` and `middleware` → `proxy` function. All Better Auth methods work identically.
</Callout>

### Next.js 15.2.0+ (Node.js Runtime Middleware)

From Next.js 15.2.0, you can use the Node.js runtime in middleware for full session validation with database checks:

```ts title="middleware.ts"
import { NextRequest, NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

export async function middleware(request: NextRequest) {
    const session = await auth.api.getSession({
        headers: await headers()
    })

    // THIS IS NOT SECURE!
    // This is the recommended approach to optimistically redirect users
    // We recommend handling auth checks in each page/route
    if(!session) {
        return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    return NextResponse.next();
}

export const config = {
  runtime: "nodejs", // Required for auth.api calls
  matcher: ["/dashboard"], // Specify the routes the middleware applies to
};
```

<Callout type="warn">
Node.js runtime in middleware is experimental in Next.js versions before 16. Consider upgrading to Next.js 16+ for stable proxy support.
</Callout>

### Next.js 13-15.1.x (Edge Runtime Middleware)

In older Next.js versions, middleware runs on the Edge Runtime and cannot make database calls. Use cookie-based checks for optimistic redirects:

<Callout type="warn">
The <code>getSessionCookie()</code> function does not automatically reference the auth config specified in <code>auth.ts</code>. Therefore, if you customized the cookie name or prefix, you need to ensure that the configuration in <code>getSessionCookie()</code> matches the config defined in your <code>auth.ts</code>.
</Callout>

#### For Next.js release `15.1.7` and below

If you need the full session object, you'll have to fetch it from the `/api/auth/get-session` API route. Since Next.js middleware doesn't support running Node.js APIs directly, you must make an HTTP request.

<Callout>
  The example uses [better-fetch](https://better-fetch.vercel.app), but you can use any fetch library.
</Callout>

```ts title="middleware.ts"
import { betterFetch } from "@better-fetch/fetch";
import type { auth } from "@/lib/auth";
import { NextRequest, NextResponse } from "next/server";

type Session = typeof auth.$Infer.Session;

export async function middleware(request: NextRequest) {
	const { data: session } = await betterFetch<Session>("/api/auth/get-session", {
		baseURL: request.nextUrl.origin,
		headers: {
			cookie: request.headers.get("cookie") || "", // Forward the cookies from the request
		},
	});

	if (!session) {
		return NextResponse.redirect(new URL("/sign-in", request.url));
	}

	return NextResponse.next();
}

export const config = {
	matcher: ["/dashboard"], // Apply middleware to specific routes
};
```

#### For Next.js release `15.2.0` and above

From Next.js 15.2.0, you can use the Node.js runtime in middleware for full session validation with database checks:

<Callout type="warn">
  You may refer to the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/routing/middleware#runtime) for more information about runtime configuration, and how to enable it.
  Be careful when using the new runtime. It's an experimental feature and it may be subject to breaking changes.
</Callout>

```ts title="middleware.ts"
import { NextRequest, NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

export async function middleware(request: NextRequest) {
    const session = await auth.api.getSession({
        headers: await headers()
    })

    if(!session) {
        return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    return NextResponse.next();
}

export const config = {
  runtime: "nodejs",
  matcher: ["/dashboard"], // Apply middleware to specific routes
};
```

#### Cookie-based checks (recommended for all versions)

```ts title="middleware.ts"
import { NextRequest, NextResponse } from "next/server";
import { getSessionCookie } from "better-auth/cookies";

export async function middleware(request: NextRequest) {
	const sessionCookie = getSessionCookie(request);

    // THIS IS NOT SECURE!
    // This is the recommended approach to optimistically redirect users
    // We recommend handling auth checks in each page/route
	if (!sessionCookie) {
		return NextResponse.redirect(new URL("/", request.url));
	}

	return NextResponse.next();
}

export const config = {
	matcher: ["/dashboard"], // Specify the routes the middleware applies to
};
```

<Callout type="warn">
	**Security Warning:** The `getSessionCookie` function only checks for the
	existence of a session cookie; it does **not** validate it. Relying solely
	on this check for security is dangerous, as anyone can manually create a
	cookie to bypass it. You must always validate the session on your server for
	any protected actions or pages.
</Callout>

<Callout type="info">
If you have a custom cookie name or prefix, you can pass it to the `getSessionCookie` function.
```ts
const sessionCookie = getSessionCookie(request, {
    cookieName: "my_session_cookie",
    cookiePrefix: "my_prefix"
});
```
</Callout>

Alternatively, you can use the `getCookieCache` helper to get the session object from the cookie cache.

```ts title="middleware.ts"
import { getCookieCache } from "better-auth/cookies";

export async function middleware(request: NextRequest) {
	const session = await getCookieCache(request);
	if (!session) {
		return NextResponse.redirect(new URL("/sign-in", request.url));
	}
	return NextResponse.next();
}
```

### How to handle auth checks in each page/route

In this example, we are using the `auth.api.getSession` function within a server component to get the session object,
then we are checking if the session is valid. If it's not, we are redirecting the user to the sign-in page.

```tsx title="app/dashboard/page.tsx"
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { redirect } from "next/navigation";

export default async function DashboardPage() {
    const session = await auth.api.getSession({
        headers: await headers()
    })

    if(!session) {
        redirect("/sign-in")
    }

    return <h1>Welcome {session.user.name}</h1>
}
```

## Next.js 16 Compatibility

Better Auth is fully compatible with Next.js 16. The main change is that "middleware" is now called "proxy". See the [Auth Protection](#auth-protection) section above for Next.js 16+ proxy examples.

### Migration Guide

Use Next.js codemod for automatic migration:
```bash
npx @next/codemod@canary middleware-to-proxy .
```

Or manually:
- Rename `middleware.ts` → `proxy.ts`
- Change function name: `middleware` → `proxy`

All Better Auth methods work identically. See the [Next.js migration guide](https://nextjs.org/docs/app/api-reference/file-conventions/proxy#migration-to-proxy) for details.
---
title: NestJS Integration
description: Integrate Better Auth with NestJS.
---

This guide will show you how to integrate Better Auth with [NestJS](https://nestjs.com/).

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

<Callout type="info">
The NestJS integration is **community maintained**. If you encounter any issues, please open them at [nestjs-better-auth](https://github.com/ThallesP/nestjs-better-auth).
</Callout>

## Installation

Install the NestJS integration library:

```package-install
@thallesp/nestjs-better-auth
```

## Basic Setup

<Callout type="warn">
Currently the library has beta support for Fastify, if you experience any issues with it, please open an issue at [nestjs-better-auth](https://github.com/ThallesP/nestjs-better-auth).
</Callout>

### 1. Disable Body Parser

Disable NestJS's built-in body parser to allow Better Auth to handle the raw request body:

```ts title="main.ts"
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    bodyParser: false, // Required for Better Auth
  });
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

### 2. Import AuthModule

Import the `AuthModule` in your root module:

```ts title="app.module.ts"
import { Module } from '@nestjs/common';
import { AuthModule } from '@thallesp/nestjs-better-auth';
import { auth } from "./auth"; // Your Better Auth instance

@Module({
  imports: [
    AuthModule.forRoot({ auth }),
  ],
})
export class AppModule {}
```

### 3. Route Protection

**Global by default**: An `AuthGuard` is registered globally by this module. All routes are protected unless you explicitly allow access.

Use the `Session` decorator to access the user session:

```ts title="user.controller.ts"
import { Controller, Get } from '@nestjs/common';
import { Session, UserSession, AllowAnonymous, OptionalAuth } from '@thallesp/nestjs-better-auth';

@Controller('users')
export class UserController {
  @Get('me')
  async getProfile(@Session() session: UserSession) {
    return { user: session.user };
  }

  @Get('public')
  @AllowAnonymous() // Allow anonymous access
  async getPublic() {
    return { message: 'Public route' };
  }

  @Get('optional')
  @OptionalAuth() // Authentication is optional
  async getOptional(@Session() session: UserSession) {
    return { authenticated: !!session };
  }
}
```

## Full Documentation

For comprehensive documentation including decorators, hooks, global guards, and advanced configuration, visit the [NestJS Better Auth repository](https://github.com/thallesp/nestjs-better-auth).
---
title: Astro Integration
description: Integrate Better Auth with Astro.
---

Better Auth comes with first class support for Astro. This guide will show you how to integrate Better Auth with Astro.

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

### Mount the handler

To enable Better Auth to handle requests, we need to mount the handler to a catch all API route. Create a file inside `/pages/api/auth` called `[...all].ts` and add the following code:

```ts title="pages/api/auth/[...all].ts"
import { auth } from "~/auth";
import type { APIRoute } from "astro";

export const ALL: APIRoute = async (ctx) => {
	// If you want to use rate limiting, make sure to set the 'x-forwarded-for' header to the request headers from the context
	// ctx.request.headers.set("x-forwarded-for", ctx.clientAddress);
	return auth.handler(ctx.request);
};
```

<Callout>
    You can change the path on your better-auth configuration but it's recommended to keep it as `/api/auth/[...all]`
</Callout>

## Create a client

Astro supports multiple frontend frameworks, so you can easily import your client based on the framework you're using.

If you're not using a frontend framework, you can still import the vanilla client.


<Tabs items={[ "vanilla", "react", "vue", "svelte", "solid",
 ]} defaultValue="react">
    <Tab value="vanilla">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/client"
            export const authClient =  createAuthClient()
            ```
    </Tab>
    <Tab value="react" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/react"
            export const authClient =  createAuthClient()
            ```
    </Tab>
    <Tab value="vue" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/vue"
            export const authClient =  createAuthClient()
            ```
    </Tab>
    <Tab value="svelte" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/svelte"
            export const authClient =  createAuthClient()
            ```
    </Tab>
    <Tab value="solid" title="lib/auth-client.ts">
            ```ts title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/solid"
            export const authClient =  createAuthClient()
            ```
    </Tab>
</Tabs>

## Auth Middleware

### Astro Locals types

To have types for your Astro locals, you need to set it inside the `env.d.ts` file.

```ts title="env.d.ts"

/// <reference path="../.astro/types.d.ts" />

declare namespace App {
    // Note: 'import {} from ""' syntax does not work in .d.ts files.
    interface Locals {
        user: import("better-auth").User | null;
        session: import("better-auth").Session | null;
    }
}
```

### Middleware

To protect your routes, you can check if the user is authenticated using the `getSession` method in middleware and set the user and session data using the Astro locals with the types we set before. Start by creating a `middleware.ts` file in the root of your project and follow the example below:

```ts title="middleware.ts"
import { auth } from "@/auth";
import { defineMiddleware } from "astro:middleware";

export const onRequest = defineMiddleware(async (context, next) => {
    const isAuthed = await auth.api
        .getSession({
            headers: context.request.headers,
        })

    if (isAuthed) {
        context.locals.user = isAuthed.user;
        context.locals.session = isAuthed.session;
    } else {
        context.locals.user = null;
        context.locals.session = null;
    }

    return next();
});
```

### Getting session on the server inside `.astro` file

You can use `Astro.locals` to check if the user has session and get the user data from the server side. Here is an example of how you can get the session inside an `.astro` file:

```astro
---
import { UserCard } from "@/components/user-card";

const session = () => {
    if (Astro.locals.session) {
        return Astro.locals.session;
    } else {
        // Redirect to login page if the user is not authenticated
        return Astro.redirect("/login");
    }
}

---

<UserCard initialSession={session} />
```
---
title: TanStack Start Integration
description: Integrate Better Auth with TanStack Start.
---

This integration guide is assuming you are using TanStack Start.

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

## Quick Start

You can create a new TanStack Start project with Better Auth integrated using the following command. This CLI sets up a project with an auth instance configured with the plugin and mounted handlers.

```package-install
npm create @tanstack/start

◇  What add-ons would you like for your project?
│  Better Auth
```

## Usage

### Mount the handler

We need to mount the handler to a TanStack API endpoint/Server Route.
Create a new file: `/src/routes/api/auth/$.ts`

```ts title="src/routes/api/auth/$.ts"
import { auth } from '@/lib/auth'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/api/auth/$')({
    server: {
        handlers: {
            GET: async ({ request }:{ request: Request }) => {
                return await auth.handler(request)
            },
            POST: async ({ request }:{ request: Request }) => {
                return await auth.handler(request)
            },
        },
    },
})
```

### Usage tips

- We recommend using the client SDK or `authClient` to handle authentication, rather than server actions with `auth.api`.
- When you call functions that need to set cookies (like `signInEmail` or `signUpEmail`), you'll need to handle cookie setting for TanStack Start. Better Auth provides a `tanstackStartCookies` plugin to automatically handle this for you.

For React (TanStack Start with React):

```ts title="src/lib/auth.ts"
import { betterAuth } from "better-auth";
import { tanstackStartCookies } from "better-auth/tanstack-start";

export const auth = betterAuth({
    //...your config
    plugins: [tanstackStartCookies()] // make sure this is the last plugin in the array
})
```

For Solid.js (TanStack Start with Solid):

```ts title="src/lib/auth.ts"
import { betterAuth } from "better-auth";
import { tanstackStartCookies } from "better-auth/tanstack-start/solid";

export const auth = betterAuth({
    //...your config
    plugins: [tanstackStartCookies()] // make sure this is the last plugin in the array
})
```

Now, when you call functions that set cookies, they will be automatically set using TanStack Start's cookie handling system.

```ts
import { auth } from "@/lib/auth"

const signIn = async () => {
    await auth.api.signInEmail({
        body: {
            email: "user@email.com",
            password: "password",
        }
    })
}
```

### Protecting Resources

To protect resources that require authentication, use `beforeLoad` with a server function. This ensures authentication is checked on every navigation, including client-side navigation via `<Link>` components.

First, create server-side helpers to check the session:

```ts title="src/lib/auth.server.ts"
import { createServerFn } from "@tanstack/react-start";
import { getRequestHeaders } from "@tanstack/react-start/server";
import { auth } from "@/lib/auth";

export const getSession = createServerFn({ method: "GET" }).handler(async () => {
    const headers = getRequestHeaders();
    const session = await auth.api.getSession({ headers });

    return session;
});

export const ensureSession = createServerFn({ method: "GET" }).handler(async () => {
    const headers = getRequestHeaders();
    const session = await auth.api.getSession({ headers });

    if (!session) {
        throw new Error("Unauthorized");
    }

    return session;
});
```

#### Protecting Routes

Use `beforeLoad` in your route definitions:

```tsx title="src/routes/dashboard.tsx"
import { createFileRoute, redirect } from '@tanstack/react-router'
import { getSession } from '@/lib/auth.server'

export const Route = createFileRoute('/dashboard')({
  beforeLoad: async () => {
    const session = await getSession();

    if (!session) {
      throw redirect({ to: "/login" });
    }

    return { user: session.user };
  },
  component: Dashboard,
})

function Dashboard() {
  const { user } = Route.useRouteContext();
  
  return <div>Welcome, {user.name}!</div>
}
```

#### Protecting Multiple Routes (Layout)

For protecting multiple routes, use a pathless layout route:

```tsx title="src/routes/_protected.tsx"
import { createFileRoute, redirect, Outlet } from '@tanstack/react-router'
import { getSession } from '@/lib/auth.server'

export const Route = createFileRoute('/_protected')({
  beforeLoad: async ({ location }) => {
    const session = await getSession();

    if (!session) {
      throw redirect({
        to: "/login",
        search: { redirect: location.href },
      });
    }

    return { user: session.user };
  },
  component: () => <Outlet />,
})
```

Then nest protected routes under `_protected`:

<Files>
  <Folder name="src" defaultOpen>
    <Folder name="routes" defaultOpen>
      <Folder name="_protected" defaultOpen>
        <File name="dashboard.tsx" />
        <File name="settings.tsx" />
      </Folder>
      <File name="_protected.tsx" />
      <File name="login.tsx" />
    </Folder>
  </Folder>
</Files>

#### Protecting Server Functions

Use `ensureSession` helper to protect server functions:

```ts title="src/lib/posts.server.ts"
import { createServerFn } from "@tanstack/react-start";
import { ensureSession } from "./auth.server";

export const createPost = createServerFn({ method: "POST" })
  .inputValidator((data: { title: string }) => data)
  .handler(async ({ data }) => {
    const session = await ensureSession();
    const post = await db.posts.create({
      title: data.title,
      authorId: session.user.id,
    });
    
    return post;
  });
```
---
title: SvelteKit Integration
description: Integrate Better Auth with SvelteKit.
---

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

### Mount the handler

We need to mount the handler to SvelteKit server hook.

```ts title="hooks.server.ts"
import { auth } from "$lib/auth";
import { svelteKitHandler } from "better-auth/svelte-kit";
import { building } from "$app/environment";

export async function handle({ event, resolve }) {
  return svelteKitHandler({ event, resolve, auth, building });
}
```

### Populate session data in the event (`event.locals`)

The `svelteKitHandler` does not automatically populate `event.locals.user` or `event.locals.session`. If you want to access the current session in your server code (e.g., in `+layout.server.ts`, actions, or endpoints), populate `event.locals` in your `handle` hook:

```ts title="hooks.server.ts"
import { auth } from "$lib/auth";
import { svelteKitHandler } from "better-auth/svelte-kit";
import { building } from "$app/environment";

export async function handle({ event, resolve }) {
  // Fetch current session from Better Auth
  const session = await auth.api.getSession({
    headers: event.request.headers,
  });

  // Make session and user available on server
  if (session) {
    event.locals.session = session.session;
    event.locals.user = session.user;
  }

  return svelteKitHandler({ event, resolve, auth, building });
}
```

### Server Action Cookies

To ensure cookies are properly set when you call functions like `signInEmail` or `signUpEmail` in a server action, you should use the `sveltekitCookies` plugin. This plugin will automatically handle setting cookies for you in SvelteKit.

You need to add it as a plugin to your Better Auth instance.

<Callout>
  The `getRequestEvent` function is available in SvelteKit `2.20.0` and later.
  Make sure you are using a compatible version.
</Callout>

```ts title="lib/auth.ts"
import { betterAuth } from "better-auth";
import { sveltekitCookies } from "better-auth/svelte-kit";
import { getRequestEvent } from "$app/server";

export const auth = betterAuth({
  // ... your config
  plugins: [sveltekitCookies(getRequestEvent)], // make sure this is the last plugin in the array
});
```

## Create a client

Create a client instance. You can name the file anything you want. Here we are creating `client.ts` file inside the `lib/` directory.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/svelte"; // make sure to import from better-auth/svelte

export const authClient = createAuthClient({
  // you can pass client configuration here
});
```

Once you have created the client, you can use it to sign up, sign in, and perform other actions.
Some of the actions are reactive. The client use [nano-store](https://github.com/nanostores/nanostores) to store the state and reflect changes when there is a change like a user signing in or out affecting the session state.

### Example usage

```svelte
<script lang="ts">
  import { authClient } from "$lib/client";
  const session = authClient.useSession();
</script>
    <div>
      {#if $session.data}
        <div>
          <p>
            {$session.data.user.name}
          </p>
          <button
            on:click={async () => {
              await authClient.signOut();
            }}
          >
            Sign Out
          </button>
        </div>
      {:else}
        <button
          on:click={async () => {
            await authClient.signIn.social({
              provider: "github",
            });
          }}
        >
          Continue with GitHub
        </button>
      {/if}
    </div>
```
---
title: SolidStart Integration
description: Integrate Better Auth with SolidStart.
---

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

### Mount the handler

We need to mount the handler to SolidStart server. Put the following code in your `*auth.ts` file inside `/routes/api/auth` folder.

```ts title="*auth.ts"
import { auth } from "~/lib/auth";
import { toSolidStartHandler } from "better-auth/solid-start";

export const { GET, POST } = toSolidStartHandler(auth);
```---
title: React Router v7 Integration
description: Integrate Better Auth with React Router v7 (formerly Remix).
---

Better Auth can be easily integrated with React Router v7. This guide will show you how to integrate Better Auth with React Router v7.

<Callout type="info">
    React Router v7 is the successor to Remix. If you're using Remix v2, the main difference is changing your imports from `@remix-run/*` to `react-router`. The APIs remain the same.
</Callout>

You can follow the steps from [installation](/docs/installation) to get started or you can follow this guide to make it the React Router way.

If you have followed the installation steps, you can skip the first step.

## Create auth instance

Create a file named `auth.server.ts` in one of these locations:
   - Project root
   - `lib/` folder
   - `utils/` folder

You can also nest any of these folders under `app/` folder. (e.g. `app/lib/auth.server.ts`)

And in this file, import Better Auth and create your instance.

<Callout type="warn">
Make sure to export the auth instance with the variable name `auth` or as a `default` export.
</Callout>

```ts title="app/lib/auth.server.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    database: {
        provider: "postgres", //change this to your database provider
        url: process.env.DATABASE_URL, // path to your database or connection string
    }
})
```

## Create API Route

We need to mount the handler to a API route. Create a resource route file `api.auth.$.ts` inside `app/routes/` directory. And add the following code:

### React Router v7
```ts title="app/routes/api.auth.$.ts"
import { auth } from '~/lib/auth.server' // Adjust the path as necessary
import type { LoaderFunctionArgs, ActionFunctionArgs } from "react-router"

export async function loader({ request }: LoaderFunctionArgs) {
    return auth.handler(request)
}

export async function action({ request }: ActionFunctionArgs) {
    return auth.handler(request)
}
```

### Remix v2 (Legacy)

If you're still using Remix v2, the only difference is the import:
```ts title="app/routes/api.auth.$.ts"
import { auth } from '~/lib/auth.server' // Adjust the path as necessary
import type { LoaderFunctionArgs, ActionFunctionArgs } from "@remix-run/node"

export async function loader({ request }: LoaderFunctionArgs) {
    return auth.handler(request)
}

export async function action({ request }: ActionFunctionArgs) {
    return auth.handler(request)
}
```

<Callout type="info">
 You can change the path on your better-auth configuration but it's recommended to keep it as `routes/api.auth.$.ts`
</Callout>

## Create a client

Create a client instance. Here we are creating `auth-client.ts` file inside the `lib/` directory.

```ts title="app/lib/auth-client.ts"
import { createAuthClient } from "better-auth/react" // make sure to import from better-auth/react

export const authClient = createAuthClient({
    //you can pass client configuration here
})
```

Once you have created the client, you can use it to sign up, sign in, and perform other actions.

### Example usage

### Sign Up

#### React Router v7
```ts title="app/routes/signup.tsx"
import { Form } from "react-router"
import { useState } from "react"
import { authClient } from "~/lib/auth-client"

export default function SignUp() {
  const [email, setEmail] = useState("")
  const [name, setName] = useState("")
  const [password, setPassword] = useState("")

  const signUp = async () => {
    await authClient.signUp.email(
      {
        email,
        password,
        name,
      },
      {
        onRequest: (ctx) => {
          // show loading state
        },
        onSuccess: (ctx) => {
          // redirect to home
        },
        onError: (ctx) => {
          alert(ctx.error)
        },
      },
    )
  }

  return (
    <div>
      <h2>
        Sign Up
      </h2>
      <Form
        onSubmit={signUp}
      >
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Name"
        />
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
        />
        <button
          type="submit"
        >
          Sign Up
        </button>
      </Form>
    </div>
  )
}
```

#### Remix v2 (Legacy)
```ts title="app/routes/signup.tsx"
import { Form } from "@remix-run/react"
import { useState } from "react"
import { authClient } from "~/lib/auth-client"

export default function SignUp() {
  const [email, setEmail] = useState("")
  const [name, setName] = useState("")
  const [password, setPassword] = useState("")

  const signUp = async () => {
    await authClient.signUp.email(
      {
        email,
        password,
        name,
      },
      {
        onRequest: (ctx) => {
          // show loading state
        },
        onSuccess: (ctx) => {
          // redirect to home
        },
        onError: (ctx) => {
          alert(ctx.error)
        },
      },
    )
  }

  return (
    <div>
      <h2>
        Sign Up
      </h2>
      <Form
        onSubmit={signUp}
      >
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Name"
        />
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
        />
        <button
          type="submit"
        >
          Sign Up
        </button>
      </Form>
    </div>
  )
}
```

### Sign In

#### React Router v7
```ts title="app/routes/signin.tsx"
import { Form } from "react-router"
import { useState } from "react"
import { authClient } from "~/lib/auth-client"

export default function SignIn() {
  const [email, setEmail] = useState("")
  const [name, setName] = useState("")
  const [password, setPassword] = useState("")

  const signIn = async () => {
    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onRequest: (ctx) => {
          // show loading state
        },
        onSuccess: (ctx) => {
          // redirect to home
        },
        onError: (ctx) => {
          alert(ctx.error)
        },
      },
    )
  }

  return (
    <div>
      <h2>
        Sign In
      </h2>
      <Form
        onSubmit={signIn}
      >
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Name"
        />
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
        />
        <button
          type="submit"
        >
          Sign In
        </button>
      </Form>
    </div>
  )
}
```

### Remix v2 (Legacy)
```ts title="app/routes/signin.tsx"
import { Form } from "@remix-run/react"
import { useState } from "react"
import { authClient } from "~/lib/auth-client"

export default function SignIn() {
  const [email, setEmail] = useState("")
  const [name, setName] = useState("")
  const [password, setPassword] = useState("")

  const signIn = async () => {
    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onRequest: (ctx) => {
          // show loading state
        },
        onSuccess: (ctx) => {
          // redirect to home
        },
        onError: (ctx) => {
          alert(ctx.error)
        },
      },
    )
  }

  return (
    <div>
      <h2>
        Sign In
      </h2>
      <Form
        onSubmit={signIn}
      >
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Name"
        />
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
        />
        <button
          type="submit"
        >
          Sign In
        </button>
      </Form>
    </div>
  )
}
```
---
title: Lynx Integration
description: Integrate Better Auth with Lynx cross-platform framework.
---

This integration guide is for using Better Auth with [Lynx](https://lynxjs.org), a cross-platform rendering framework that enables developers to build applications for Android, iOS, and Web platforms with native rendering performance.

Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation).

## Installation

Install Better Auth and the Lynx React dependency:

```package-install
better-auth @lynx-js/react
```

## Create Client Instance

Import `createAuthClient` from `better-auth/lynx` to create your client instance:

```ts title="lib/auth-client.ts"
import { createAuthClient } from "better-auth/lynx"

export const authClient = createAuthClient({
    baseURL: "http://localhost:3000" // The base URL of your auth server
})
```

## Usage

The Lynx client provides the same API as other Better Auth clients, with optimized integration for Lynx's reactive system.

### Authentication Methods

```ts
import { authClient } from "./lib/auth-client"

// Sign in with email and password
await authClient.signIn.email({
    email: "test@user.com",
    password: "password1234"
})

// Sign up
await authClient.signUp.email({
    email: "test@user.com", 
    password: "password1234",
    name: "John Doe"
})

// Sign out
await authClient.signOut()
```

### Hooks

The Lynx client includes reactive hooks that integrate seamlessly with Lynx's component system:

#### useSession

```tsx title="components/user.tsx"
import { authClient } from "../lib/auth-client"

export function User() {
    const {
        data: session,
        isPending, // loading state
        error // error object 
    } = authClient.useSession()

    if (isPending) return <div>Loading...</div>
    if (error) return <div>Error: {error.message}</div>

    return (
        <div>
            {session ? (
                <div>
                    <p>Welcome, {session.user.name}!</p>
                    <button onClick={() => authClient.signOut()}>
                        Sign Out
                    </button>
                </div>
            ) : (
                <button onClick={() => authClient.signIn.social({
                    provider: 'github'
                })}>
                    Sign In with GitHub
                </button>
            )}
        </div>
    )
}
```

### Store Integration

The Lynx client uses [nanostores](https://github.com/nanostores/nanostores) for state management and provides a `useStore` hook for accessing reactive state:

```tsx title="components/session-info.tsx"
import { useStore } from "better-auth/lynx"
import { authClient } from "../lib/auth-client"

export function SessionInfo() {
    // Access the session store directly
    const session = useStore(authClient.$store.session)
    
    return (
        <div>
            {session && (
                <pre>{JSON.stringify(session, null, 2)}</pre>
            )}
        </div>
    )
}
```

### Advanced Store Usage

You can use the store with selective key watching for optimized re-renders:

```tsx title="components/optimized-user.tsx"
import { useStore } from "better-auth/lynx"
import { authClient } from "../lib/auth-client"

export function OptimizedUser() {
    // Only re-render when specific keys change
    const session = useStore(authClient.$store.session, {
        keys: ['user.name', 'user.email'] // Only watch these specific keys
    })
    
    return (
        <div>
            {session?.user && (
                <div>
                    <h2>{session.user.name}</h2>
                    <p>{session.user.email}</p>
                </div>
            )}
        </div>
    )
}
```

## Plugin Support

The Lynx client supports all Better Auth plugins:

```ts title="lib/auth-client.ts"
import { createAuthClient } from "better-auth/lynx"
import { magicLinkClient } from "better-auth/client/plugins"

const authClient = createAuthClient({
    plugins: [
        magicLinkClient()
    ]
})

// Use plugin methods
await authClient.signIn.magicLink({
    email: "test@email.com"
})
```

## Error Handling

Error handling works the same as other Better Auth clients:

```tsx title="components/login-form.tsx"
import { authClient } from "../lib/auth-client"

export function LoginForm() {
    const signIn = async (email: string, password: string) => {
        const { data, error } = await authClient.signIn.email({
            email,
            password
        })
        
        if (error) {
            console.error('Login failed:', error.message)
            return
        }
        
        console.log('Login successful:', data)
    }
    
    return (
        <form onSubmit={(e) => {
            e.preventDefault()
            const formData = new FormData(e.target)
            signIn(formData.get('email'), formData.get('password'))
        }}>
            <input name="email" type="email" placeholder="Email" />
            <input name="password" type="password" placeholder="Password" />
            <button type="submit">Sign In</button>
        </form>
    )
}
```

## Features

The Lynx client provides:

- **Cross-Platform Support**: Works across Android, iOS, and Web platforms
- **Optimized Performance**: Built specifically for Lynx's reactive system
- **Nanostores Integration**: Uses nanostores for efficient state management  
- **Selective Re-rendering**: Watch specific store keys to minimize unnecessary updates
- **Full API Compatibility**: All Better Auth methods and plugins work seamlessly
- **TypeScript Support**: Full type safety with TypeScript inference

The Lynx integration maintains all the features and benefits of Better Auth while providing optimal performance and developer experience within Lynx's cross-platform ecosystem.---
title: Introduction
description: Introduction to Better Auth.
---

Better Auth is a framework-agnostic, universal authentication and authorization framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities. Whether you need 2FA, passkey, multi-tenancy, multi-session support, or even enterprise features like SSO, creating your own IDP, it lets you focus on building your application instead of reinventing the wheel.

## Features

Better Auth aims to be the most comprehensive auth library. It provides a wide range of features out of the box and allows you to extend it with plugins. Here are some of the features:

<Features/>

...and much more!

---

## AI tooling

### LLMs.txt

Better Auth exposes an `LLMs.txt` that helps AI models understand how to integrate and interact with your authentication system. See it at [https://better-auth.com/llms.txt](https://better-auth.com/llms.txt).

### Skills

Better Auth provides skills that can be added to your AI coding assistant to help it understand Better Auth best practices and implementation patterns.

```bash title="terminal"
npx skills add better-auth/skills
```

### MCP

Better Auth provides an MCP server so you can use it with any AI model that supports the Model Context Protocol (MCP).

<AddToCursor />

#### CLI Options

Use the Better Auth CLI to easily add the MCP server to your preferred client:

<Tabs items={["Cursor", "Claude Code", "Open Code", "Manual"]}>
    <Tab value="Cursor">
      ```bash title="terminal"
      npx auth mcp --cursor
      ```
    </Tab>
    <Tab value="Claude Code">
      ```bash title="terminal"
      npx auth mcp --claude-code
      ```
    </Tab>
    <Tab value="Open Code">
      ```bash title="terminal"
      npx auth mcp --open-code
      ```
    </Tab>
    <Tab value="Manual">
      ```bash title="terminal"
      npx auth mcp --manual
      ```
    </Tab>
</Tabs>

#### Manual Configuration

Alternatively, you can manually configure the MCP server for each client:

<Tabs items={["Claude Code", "Open Code", "Manual"]}>
    <Tab value="Claude Code">
      ```bash title="terminal"
      claude mcp add --transport http better-auth https://mcp.inkeep.com/better-auth/mcp
      ```
    </Tab>
    <Tab value="Open Code">
      ```json title="opencode.json"
        {
            "$schema": "https://opencode.ai/config.json",
            "mcp": {
                "better-auth": {
                    "type": "remote",
                    "url": "https://mcp.inkeep.com/better-auth/mcp",
                    "enabled": true,
                }
            }
        }
      ```
    </Tab>
    <Tab value="Manual">
     ```json title="mcp.json"
    {
        "better-auth": {
            "url": "https://mcp.inkeep.com/better-auth/mcp"
        }
    }
    ```
    </Tab>
</Tabs>

<Callout>
We provide a first‑party MCP, powered by [Inkeep](https://inkeep.com). You can alternatively use [`context7`](https://context7.com/) and other MCP providers.
</Callout>

---
title: MongoDB Adapter
description: Integrate Better Auth with MongoDB.
---

MongoDB is a popular NoSQL database that is widely used for building scalable and flexible applications. It provides a flexible schema that allows for easy data modeling and querying.

Before getting started, make sure you have MongoDB installed and configured. For more information, see [MongoDB Documentation](https://www.mongodb.com/docs/)

## Example Usage

You can use the MongoDB adapter to connect to your database as follows.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { MongoClient } from "mongodb";
import { mongodbAdapter } from "better-auth/adapters/mongodb";

const client = new MongoClient("mongodb://localhost:27017/database");
const db = client.db();

export const auth = betterAuth({
  database: mongodbAdapter(db, {
    // Optional: if you don't provide a client, database transactions won't be enabled.
    client
  }),
});
```

## Schema generation & migration

For MongoDB, we don't need to generate or migrate the schema.


## Joins (Experimental)

Database joins is useful when Better-Auth needs to fetch related data from multiple tables in a single query.
Endpoints like `/get-session`, `/get-full-organization` and many others benefit greatly from this feature,
seeing upwards of 2x to 3x performance improvements depending on database latency.

The MongoDB adapter supports joins out of the box since version `1.4.0`.
To enable this feature, you need to set the `experimental.joins` option to `true` in your auth configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  experimental: { joins: true }
});
```
## Additional Information

- If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>.
---
title: Other Relational Databases
description: Integrate Better Auth with other relational databases.
---

Better Auth supports a wide range of database dialects out of the box thanks to <Link href="https://kysely.dev/">Kysely</Link>.

Any dialect supported by Kysely can be utilized with Better Auth, including capabilities for generating and migrating database schemas through the <Link href="/docs/concepts/cli">CLI</Link>.

## Core Dialects

- [MySQL](/docs/adapters/mysql)
- [SQLite](/docs/adapters/sqlite)
- [PostgreSQL](/docs/adapters/postgresql)
- [MS SQL](/docs/adapters/mssql)

## Kysely Organization Dialects

- [Postgres.js](https://github.com/kysely-org/kysely-postgres-js)
- [SingleStore Data API](https://github.com/kysely-org/kysely-singlestore)
- [Supabase](https://github.com/kysely-org/kysely-supabase)

## Kysely Community dialects

- [PlanetScale Serverless Driver](https://github.com/depot/kysely-planetscale)
- [Cloudflare D1](https://github.com/aidenwallis/kysely-d1)
- [AWS RDS Data API](https://github.com/serverless-stack/kysely-data-api)
- [Prisma Postgres](https://github.com/kysely-org/kysely-prisma-postgres)
- [SurrealDB](https://github.com/igalklebanov/kysely-surrealdb)
- [Neon](https://github.com/seveibar/kysely-neon)
- [Xata](https://github.com/xataio/client-ts/tree/main/packages/plugin-client-kysely)
- [AWS S3 Select](https://github.com/igalklebanov/kysely-s3-select)
- [libSQL/sqld](https://github.com/libsql/kysely-libsql)
- [Fetch driver](https://github.com/andersgee/kysely-fetch-driver)
- [SQLite WASM](https://github.com/DallasHoff/sqlocal)
- [Deno SQLite](https://gitlab.com/soapbox-pub/kysely-deno-sqlite)
- [TiDB Cloud Serverless Driver](https://github.com/tidbcloud/kysely)
- [Capacitor SQLite Kysely](https://github.com/DawidWetzler/capacitor-sqlite-kysely)
- [BigQuery](https://github.com/maktouch/kysely-bigquery)
- [Clickhouse](https://github.com/founderpathcom/kysely-clickhouse)
- [PGLite](https://github.com/czeidler/kysely-pglite-dialect)

<Callout>
  You can see the full list of supported Kysely dialects{" "}
  <Link href="https://kysely.dev/docs/dialects">here</Link>.
</Callout>
---
title: Community Adapters
description: Integrate Better Auth with community made database adapters.
---

This page showcases a list of recommended community made database adapters.
We encourage you to create any missing database adapters and maybe get added to the list!

| Adapter                                                                                                 | Database Dialect                           | Author                                                                                                                                                            |
| ------------------------------------------------------------------------------------------------------- | ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [convex-better-auth](https://github.com/get-convex/better-auth)                                         | [Convex Database](https://www.convex.dev/) | <img src="https://github.com/erquhart.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [erquhart](https://github.com/erquhart)          |
| [surreal-better-auth](https://github.com/oskar-gmerek/surreal-better-auth)                              | [SurrealDB](https://surrealdb.com/)        | <img src="https://github.com/oskar-gmerek.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> <a href="https://oskargmerek.com" alt="Web Developer UK">Oskar Gmerek</a>   |
| [surrealdb-better-auth](https://github.com/Necmttn/surrealdb-better-auth)                               | [Surreal Database](https://surrealdb.com/) | <img src="https://github.com/Necmttn.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [Necmttn](https://github.com/Necmttn)             |
| [better-auth-surrealdb](https://github.com/msanchezdev/better-auth-surrealdb)                           | [Surreal Database](https://surrealdb.com/) | <img src="https://github.com/msanchezdev.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [msanchezdev](https://github.com/msanchezdev)             |
| [@payload-auth/better-auth-plugin](https://github.com/payload-auth/payload-auth)                        | [Payload CMS](https://payloadcms.com/)     | <img src="https://github.com/forrestdevs.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [forrestdevs](https://github.com/forrestdevs) |
| [better-auth-instantdb](https://github.com/daveyplate/better-auth-instantdb)                            | [InstantDB](https://www.instantdb.com/)    | <img src="https://github.com/daveycodez.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [daveycodez](https://github.com/daveycodez)    |
| [@nerdfolio/remult-better-auth](https://github.com/nerdfolio/remult-better-auth)                        | [Remult](https://remult.dev/)              | <img src="https://github.com/taivo.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [Tai Vo](https://github.com/taivo)                  |
| [pocketbase-better-auth](https://github.com/LightInn/pocketbase-better-auth)                             | [PocketBase](https://pocketbase.io/)       | <img src="https://github.com/LightInn.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [LightInn](https://github.com/LightInn)          |
| [better-auth-firestore](https://github.com/yultyyev/better-auth-firestore) | [Firebase Firestore](https://firebase.google.com/docs/firestore) | <img src="https://github.com/yultyyev.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [yultyyev](https://github.com/yultyyev) |
| [@zenstackhq/better-auth](https://github.com/zenstackhq/zenstack-v3/tree/main/packages/auth-adapters/better-auth) | [ZenStack](https://zenstack.dev) | <img src="https://github.com/zenstackhq.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [zenstackhq](https://github.com/zenstackhq) |
| [@strapi-community/plugin-better-auth](https://github.com/strapi-community/plugin-better-auth)          | [Strapi CMS](https://strapi.io/)           | <img src="https://github.com/boazpoolman.png" className="rounded-full w-6 h-6 border opacity-70 m-0 inline mr-1" /> [boazpoolman](https://github.com/boazpoolman) |
---
title: Drizzle ORM Adapter
description: Integrate Better Auth with Drizzle ORM.
---

Drizzle ORM is a powerful and flexible ORM for Node.js and TypeScript. It provides a simple and intuitive API for working with databases, and supports a wide range of databases including MySQL, PostgreSQL, SQLite, and more.

Before getting started, make sure you have Drizzle installed and configured. For more information, see [Drizzle Documentation](https://orm.drizzle.team/docs/overview/)

## Example Usage

You can use the Drizzle adapter to connect to your database as follows.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { db } from "./database.ts";

export const auth = betterAuth({
  database: drizzleAdapter(db, { // [!code highlight]
    provider: "sqlite", // or "pg" or "mysql" // [!code highlight]
  }), // [!code highlight]
  //... the rest of your config
});
```

## Schema generation & migration

The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate
your database schema based on your Better Auth configuration and plugins.

To generate the schema required by Better Auth, run the following command:

```package-install
npx auth@latest generate
```

To generate and apply the migration, run the following commands:

   <Tabs items={["generate", "migrate"]}>
      <Tab value="generate">
      ```package-install
      npx drizzle-kit generate # generate the migration file
      ```
      </Tab>
      <Tab value="migrate">
      ```package-install
      npx drizzle-kit migrate # apply the migration
      ```
      </Tab>
    </Tabs>


## Joins (Experimental)

Database joins is useful when Better-Auth needs to fetch related data from multiple tables in a single query.
Endpoints like `/get-session`, `/get-full-organization` and many others benefit greatly from this feature,
seeing upwards of 2x to 3x performance improvements depending on database latency.

The Drizzle adapter supports joins out of the box since version `1.4.0`.
To enable this feature, you need to set the `experimental.joins` option to `true` in your auth configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  experimental: { joins: true }
});
```
<Callout type="warn">
  Please make sure that your Drizzle schema has the necessary relations defined.
  If you do not see any relations in your Drizzle schema, you can manually add them using the [`relation`](https://orm.drizzle.team/docs/relations) drizzle-orm function
  or run our latest CLI version `npx auth@latest generate` to generate a new Drizzle schema with the relations.

  Additionally, you're required to pass each [relation](https://orm.drizzle.team/docs/relations) through the drizzle adapter schema object.
</Callout>

## Modifying Table Names

The Drizzle adapter expects the schema you define to match the table names. For example, if your Drizzle schema maps the `user` table to `users`, you need to manually pass the schema and map it to the user table.

```ts
import { betterAuth } from "better-auth";
import { db } from "./drizzle";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { schema } from "./schema";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "sqlite", // or "pg" or "mysql"
    schema: { // [!code highlight]
      ...schema, // [!code highlight]
      user: schema.users, // [!code highlight]
    }, // [!code highlight]
  }),
});
```

You can either modify the provided schema values like the example above,
or you can mutate the auth config's `modelName` property directly.
For example:

```ts
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "sqlite", // or "pg" or "mysql"
    schema,
  }),
  user: {
    modelName: "users", // [!code highlight]
  }
});
```

## Modifying Field Names

We map field names based on property you passed to your Drizzle schema.
For example, if you want to modify the `email` field to `email_address`,
you simply need to change the Drizzle schema to:

```ts
export const user = mysqlTable("user", {
  // Changed field name without changing the schema property name
  // This allows drizzle & better-auth to still use the original field name,
  // while your DB uses the modified field name
  email: varchar("email_address", { length: 255 }).notNull().unique(), // [!code highlight]
  // ... others
});
```

You can either modify the Drizzle schema like the example above,
or you can mutate the auth config's `fields` property directly.
For example:

```ts
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "sqlite", // or "pg" or "mysql"
    schema,
  }),
  user: {
    fields: {
      email: "email_address", // [!code highlight]
    }
  }
});
```

## Using Plural Table Names

If all your tables are using plural form, you can just pass the `usePlural` option:

```ts
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    ...
    usePlural: true, // [!code highlight]
  }),
});
```

## Additional Information

- If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>.
---
title: SQLite
description: Integrate Better Auth with SQLite.
---

SQLite is a lightweight, serverless, self-contained SQL database engine that is widely used for local data storage in applications.
Read more [here.](https://www.sqlite.org/)

## Example Usage

Better Auth supports multiple SQLite drivers. Choose the one that best fits your environment:

### Better-SQLite3 (Recommended)

The most popular and stable SQLite driver for Node.js:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import Database from "better-sqlite3";

export const auth = betterAuth({
  database: new Database("database.sqlite"),
});
```

<Callout>
  For more information, read Kysely's documentation to the
  [SqliteDialect](https://kysely-org.github.io/kysely-apidoc/classes/SqliteDialect.html).
</Callout>

### Node.js Built-in SQLite (Experimental)

<Callout type="warning">
  The `node:sqlite` module is still experimental and may change at any time. It requires Node.js 22.5.0 or later.
</Callout>

Starting from Node.js 22.5.0, you can use the built-in [SQLite](https://nodejs.org/api/sqlite.html) module:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { DatabaseSync } from "node:sqlite";

export const auth = betterAuth({
  database: new DatabaseSync("database.sqlite"),
});
```

To run your application with Node.js SQLite:
```bash
node your-app.js
```

### Bun Built-in SQLite

You can also use the built-in [SQLite](https://bun.com/docs/api/sqlite) module in Bun, which is similar to the Node.js version:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { Database } from "bun:sqlite";

export const auth = betterAuth({
  database: new Database("database.sqlite"),
});
```

## Schema generation & migration

The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate
your database schema based on your Better Auth configuration and plugins.

<table>
  <thead>
    <tr className="border-b">
      <th>
        <p className="font-bold text-[16px] mb-1">SQLite Schema Generation</p>
      </th>
      <th>
        <p className="font-bold text-[16px] mb-1">SQLite Schema Migration</p>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr className="h-10">
      <td>&#9989; Supported</td>
      <td>&#9989; Supported</td>
    </tr>
  </tbody>
</table>

<Tabs items={["migrate", "generate"]}>
   <Tab value="migrate">
   ```package-install
   npx auth@latest migrate
   ```
   </Tab>
   <Tab value="generate">
   ```package-install
   npx auth@latest generate
   ```
   </Tab>
 </Tabs>

## Joins (Experimental)

Database joins is useful when Better-Auth needs to fetch related data from multiple tables in a single query.
Endpoints like `/get-session`, `/get-full-organization` and many others benefit greatly from this feature,
seeing upwards of 2x to 3x performance improvements depending on database latency.

The Kysely SQLite dialect supports joins out of the box since version `1.4.0`.
To enable this feature, you need to set the `experimental.joins` option to `true` in your auth configuration.

```ts title="auth.ts"
export const auth = betterAuth({
  experimental: { joins: true }
});
```
<Callout type="warn">
  It's possible that you may need to run migrations after enabling this feature.
</Callout>

## Additional Information

SQLite is supported under the hood via the [Kysely](https://kysely.dev/) adapter, any database supported by Kysely would also be supported. (<Link href="/docs/adapters/other-relational-databases">Read more here</Link>)

If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>.
---
title: MS SQL
description: Integrate Better Auth with MS SQL.
---

Microsoft SQL Server is a relational database management system developed by Microsoft, designed for enterprise-level data storage, management, and analytics with robust security and scalability features.
Read more [here](https://en.wikipedia.org/wiki/Microsoft_SQL_Server).

## Example Usage

Make sure you have MS SQL installed and configured.
Then, you can connect it straight into Better Auth.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { MssqlDialect } from "kysely";
import * as Tedious from 'tedious'
import * as Tarn from 'tarn'

const dialect = new MssqlDialect({
  tarn: {
    ...Tarn,
    options: {
      min: 0,
      max: 10,
    },
  },
  tedious: {
    ...Tedious,
    connectionFactory: () => new Tedious.Connection({
      authentication: {
        options: {
          password: 'password',
          userName: 'username',
        },
        type: 'default',
      },
      options: {
        database: 'some_db',
        port: 1433,
        trustServerCertificate: true,
      },
      server: 'localhost',
    }),
  },
  TYPES: {
		...Tedious.TYPES,
		DateTime: Tedious.TYPES.DateTime2,
	},
})

export const auth = betterAuth({
  database: {
    dialect,
    type: "mssql"
  }
});


```
<Callout>
    For more information, read Kysely's documentation to the [MssqlDialect](https://kysely-org.github.io/kysely-apidoc/classes/MssqlDialect.html).
</Callout>

## Schema generation & migration

The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate
your database schema based on your Better Auth configuration and plugins.

<table>
  <thead>
    <tr className="border-b">
      <th>
        <p className="font-bold text-[16px] mb-1">MS SQL Schema Generation</p>
      </th>
      <th>
        <p className="font-bold text-[16px] mb-1">MS SQL Schema Migration</p>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr className="h-10">
      <td>&#9989; Supported</td>
      <td>&#9989; Supported</td>
    </tr>
  </tbody>
</table>

   <Tabs items={["migrate", "generate"]}>
      <Tab value="migrate">
      ```package-install
      npx auth@latest migrate
      ```
      </Tab>
      <Tab value="generate">
      ```package-install
      npx auth@latest generate
      ```
      </Tab>
    </Tabs>

## Joins (Experimental)

Database joins is useful when Better-Auth needs to fetch related data from multiple tables in a single query.
Endpoints like `/get-session`, `/get-full-organization` and many others benefit greatly from this feature,
seeing upwards of 2x to 3x performance improvements depending on database latency.

The Kysely MS SQL dialect supports joins out of the box since version `1.4.0`.
To enable this feature, you need to set the `experimental.joins` option to `true` in your auth configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  experimental: { joins: true }
});
```
<Callout type="warn">
  It's possible that you may need to run migrations after enabling this feature.
</Callout>

## Additional Information

MS SQL is supported under the hood via the [Kysely](https://kysely.dev/) adapter, any database supported by Kysely would also be supported. (<Link href="/docs/adapters/other-relational-databases">Read more here</Link>)

If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>.
---
title: MySQL
description: Integrate Better Auth with MySQL.
---

MySQL is a popular open-source relational database management system (RDBMS) that is widely used for building web applications and other types of software. It provides a flexible and scalable database solution that allows for efficient storage and retrieval of data.
Read more here: [MySQL](https://www.mysql.com/).

## Example Usage

Make sure you have MySQL installed and configured.
Then, you can connect it straight into Better Auth.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { createPool } from "mysql2/promise";

export const auth = betterAuth({
  database: createPool({
    host: "localhost",
    user: "root",
    password: "password",
    database: "database",
    timezone: "Z", // Important to ensure consistent timezone values
  }),
});
```

<Callout>
  For more information, read Kysely's documentation to the
  [MySQLDialect](https://kysely-org.github.io/kysely-apidoc/classes/MysqlDialect.html).
</Callout>

## Schema generation & migration

The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate
your database schema based on your Better Auth configuration and plugins.

<table>
  <thead>
    <tr className="border-b">
      <th>
        <p className="font-bold text-[16px] mb-1">MySQL Schema Generation</p>
      </th>
      <th>
        <p className="font-bold text-[16px] mb-1">MySQL Schema Migration</p>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr className="h-10">
      <td>&#9989; Supported</td>
      <td>&#9989; Supported</td>
    </tr>
  </tbody>
</table>

   <Tabs items={["migrate", "generate"]}>
      <Tab value="migrate">
      ```package-install
      npx auth@latest migrate
      ```
      </Tab>
      <Tab value="generate">
      ```package-install
      npx auth@latest generate
      ```
      </Tab>
    </Tabs>

## Joins (Experimental)

Database joins is useful when Better-Auth needs to fetch related data from multiple tables in a single query.
Endpoints like `/get-session`, `/get-full-organization` and many others benefit greatly from this feature,
seeing upwards of 2x to 3x performance improvements depending on database latency.

The Kysely MySQL dialect supports joins out of the box since version `1.4.0`.

To enable this feature, you need to set the `experimental.joins` option to `true` in your auth configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  experimental: { joins: true }
});
```
<Callout type="warn">
  It's possible that you may need to run migrations after enabling this feature.
</Callout>

## Additional Information

MySQL is supported under the hood via the [Kysely](https://kysely.dev/) adapter, any database supported by Kysely would also be supported. (<Link href="/docs/adapters/other-relational-databases">Read more here</Link>)

If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>.
---
title: PostgreSQL
description: Integrate Better Auth with PostgreSQL.
---

PostgreSQL is a powerful, open-source relational database management system known for its advanced features, extensibility, and support for complex queries and large datasets.
Read more [here](https://www.postgresql.org/).

## Example Usage

Make sure you have PostgreSQL installed and configured.
Then, you can connect it straight into Better Auth.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { Pool } from "pg";

export const auth = betterAuth({
  database: new Pool({
    connectionString: "postgres://user:password@localhost:5432/database",
  }),
});
```

<Callout>
  For more information, read Kysely's documentation to the
  [PostgresDialect](https://kysely-org.github.io/kysely-apidoc/classes/PostgresDialect.html).
</Callout>

## Schema generation & migration

The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate
your database schema based on your Better Auth configuration and plugins.

<table>
  <thead>
    <tr className="border-b">
      <th>
        <p className="font-bold text-[16px] mb-1">PostgreSQL Schema Generation</p>
      </th>
      <th>
        <p className="font-bold text-[16px] mb-1">PostgreSQL Schema Migration</p>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr className="h-10">
      <td>&#9989; Supported</td>
      <td>&#9989; Supported</td>
    </tr>
  </tbody>
</table>

   <Tabs items={["migrate", "generate"]}>
      <Tab value="migrate">
      ```package-install
      npx auth@latest migrate
      ```
      </Tab>
      <Tab value="generate">
      ```package-install
      npx auth@latest generate
      ```
      </Tab>
    </Tabs>

## Joins (Experimental)

Database joins is useful when Better-Auth needs to fetch related data from multiple tables in a single query.
Endpoints like `/get-session`, `/get-full-organization` and many others benefit greatly from this feature,
seeing upwards of 2x to 3x performance improvements depending on database latency.

The Kysely PostgreSQL dialect supports joins out of the box since version `1.4.0`.
To enable this feature, you need to set the `experimental.joins` option to `true` in your auth configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  experimental: { joins: true }
});
```
<Callout type="warn">
  It's possible that you may need to run migrations after enabling this feature.
</Callout>

## Use a non-default schema

In most cases, the default schema is `public`. To have Better Auth use a
non-default schema (e.g., `auth`) for its tables, you have several options:

### Option 1: Set search_path in connection string (Recommended)

Append the `options` parameter to your connection URI:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { Pool } from "pg";

export const auth = betterAuth({
  database: new Pool({
    connectionString: "postgres://user:password@localhost:5432/database?options=-c search_path=auth",
  }),
});
```

URL-encode if needed: `?options=-c%20search_path%3Dauth`.

### Option 2: Set search_path using Pool options

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { Pool } from "pg";

export const auth = betterAuth({
  database: new Pool({
    host: "localhost",
    port: 5432,
    user: "postgres",
    password: "password",
    database: "my-db",
    options: "-c search_path=auth",
  }),
});
```

### Option 3: Set default schema for database user

Set the PostgreSQL user's default schema:

```sql
ALTER USER your_user SET search_path TO auth;
```

After setting this, reconnect to apply the changes.

### Prerequisites

Before using a non-default schema, ensure:

1. **The schema exists:**
   ```sql
   CREATE SCHEMA IF NOT EXISTS auth;
   ```

2. **The user has appropriate permissions:**
   ```sql
   GRANT ALL PRIVILEGES ON SCHEMA auth TO your_user;
   GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA auth TO your_user;
   ALTER DEFAULT PRIVILEGES IN SCHEMA auth GRANT ALL ON TABLES TO your_user;
   ```

### How it works

The Better Auth CLI migration system automatically detects your configured `search_path`:

- When running `npx auth migrate`, it inspects only the tables in your configured schema
- Tables in other schemas (e.g., `public`) are ignored, preventing conflicts
- All new tables are created in your specified schema

### Troubleshooting

<Callout type="warning">
**Issue:** "relation does not exist" error during migration

**Solution:** This usually means the schema doesn't exist or the user lacks permissions. Create the schema and grant permissions as shown above.
</Callout>

<Callout type="info">
**Verifying your schema configuration:**

You can verify which schema Better Auth will use by checking the `search_path`:

```sql
SHOW search_path;
```

This should return your custom schema (e.g., `auth`) as the first value.
</Callout>

## Additional Information

PostgreSQL is supported under the hood via the [Kysely](https://kysely.dev/) adapter, any database supported by Kysely would also be supported. (<Link href="/docs/adapters/other-relational-databases">Read more here</Link>)

If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>.
---
title: Prisma
description: Integrate Better Auth with Prisma.
---

Prisma ORM is an open-source database toolkit that simplifies database access and management in applications by providing a type-safe query builder and an intuitive data modeling interface.

Before getting started, make sure you have Prisma installed and configured. For more information, see [Prisma Documentation](https://www.prisma.io/docs/)

## Example Usage

You can use the Prisma adapter to connect to your database as follows.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export const auth = betterAuth({
  database: prismaAdapter(prisma, {
    provider: "sqlite",
  }),
});
```

<Callout type="warning">
  Starting from Prisma 7, the `output` path field is required. If you have configured a custom output path in your `schema.prisma` file (e.g., `output = "../src/generated/prisma"`), make sure to import the Prisma client from that location instead of `@prisma/client`. For more information, see [here](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-location-of-prisma-client).
</Callout>

## Schema generation & migration

The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate
your database schema based on your Better Auth configuration and plugins.

<table>
  <thead>
    <tr className="border-b">
      <th>
        <p className="font-bold text-[16px] mb-1">Prisma Schema Generation</p>
      </th>
      <th>
        <p className="font-bold text-[16px] mb-1">Prisma Schema Migration</p>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr className="h-10">
      <td>&#9989; Supported</td>
      <td>&#10060; Not Supported</td>
    </tr>
  </tbody>
</table>

```package-install title="Schema Generation"
npx auth@latest generate
```

## Joins (Experimental)

Database joins is useful when Better-Auth needs to fetch related data from multiple tables in a single query.
Endpoints like `/get-session`, `/get-full-organization` and many others benefit greatly from this feature,
seeing upwards of 2x to 3x performance improvements depending on database latency.

The Prisma adapter supports joins out of the box since version `1.4.0`.
To enable this feature, you need to set the `experimental.joins` option to `true` in your auth configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  experimental: { joins: true }
});
```

<Callout type="warn">
  Please make sure that your Prisma schema has the necessary relations defined.
  If you do not see any relations in your Prisma schema, you can manually add them using the `@relation` directive
  or run our latest CLI version `npx auth@latest generate` to generate a new Prisma schema with the relations.
</Callout>

## Additional Information

- If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>.
- [How to use Prisma ORM with Better Auth and Next.js](https://www.prisma.io/docs/guides/betterauth-nextjs)
---
title: Create your first plugin
description: A step-by-step guide to creating your first Better Auth plugin.
---

In this guide, we’ll walk you through the steps of creating your first Better Auth plugin.


<Callout type="warn">
This guide assumes you have <Link href="/docs/installation">setup the basics</Link> of Better Auth and are ready to create your first plugin.
</Callout>

<Steps>
<Step>
## Plan your idea
Before beginning, you must know what plugin you intend to create.

In this guide, we’ll create a **birthday plugin** to keep track of user birth dates.
</Step>

<Step>
## Server plugin first
Better Auth plugins operate as a pair: a <Link href="/docs/concepts/plugins#create-a-server-plugin">server plugin</Link> and a <Link href="/docs/concepts/plugins#creating-a-client-plugin">client plugin</Link>.
The server plugin forms the foundation of your authentication system, while the client plugin provides convenient frontend APIs to interact with your server implementation.


<Callout>
You can read more about server/client plugins in our <Link href="/docs/concepts/plugins#creating-a-plugin">documentation</Link>.
</Callout>

### Creating the server plugin
Go ahead and find a suitable location to create your birthday plugin folder, with an `index.ts` file within.
<Files>
  <Folder name="birthday-plugin" defaultOpen>
    <File name="index.ts" />
  </Folder>
</Files>
In the `index.ts` file, we’ll export a function that represents our server plugin.
This will be what we will later add to our plugin list in the `auth.ts` file.

```ts title="index.ts"
import { createAuthClient } from "better-auth/client";
import type { BetterAuthPlugin } from "better-auth";

export const birthdayPlugin = () =>
  ({
    id: "birthdayPlugin",
  } satisfies BetterAuthPlugin);

```
Although this does nothing, you have technically just made yourself your first plugin, congratulations! 🎉

</Step>

<Step>
### Defining a schema
In order to save each user’s birthday data, we must create a schema on top of the `user` model.

By creating a schema here, this also allows <Link href="/docs/concepts/cli">Better Auth’s CLI</Link> to generate the schemas required to update your database.

<Callout type="info">
You can learn more about <Link href="/docs/concepts/plugins#schema">plugin schemas here</Link>.
</Callout>

```ts title="index.ts"
//...
export const birthdayPlugin = () =>
  ({
    id: "birthdayPlugin",
    schema: {// [!code highlight]
      user: {// [!code highlight]
        fields: {// [!code highlight]
          birthday: {// [!code highlight]
            type: "date", // string, number, boolean, date // [!code highlight]
            required: true, // if the field should be required on a new record. (default: false) // [!code highlight]
            unique: false, // if the field should be unique. (default: false) // [!code highlight]
          },// [!code highlight]
        },// [!code highlight]
      },// [!code highlight]
    },
  } satisfies BetterAuthPlugin);
```

</Step>

<Step>
### Authorization logic
For this example guide, we’ll set up authentication logic to check and ensure that the user who signs-up is older than 5.
But the same concept could be applied for something like verifying users agreeing to the TOS or anything alike.

To do this, we’ll utilize <Link href="/docs/concepts/plugins#hooks">Hooks</Link>, which allows us to run code `before` or `after` an action is performed.

```ts title="index.ts"
export const birthdayPlugin = () => ({
    //...
    // In our case, we want to write authorization logic,
    // meaning we want to intercept it `before` hand.
    hooks: {
      before: [
        {
          matcher: (context) => /* ... */,
          handler: createAuthMiddleware(async (ctx) => {
            //...
          }),
        },
      ],
    },
} satisfies BetterAuthPlugin)
```

In our case we want to match any requests going to the signup path:
```ts title="Before hook"
{
  matcher: (context) => context.path.startsWith("/sign-up/email"),
  //...
}
```

And for our logic, we’ll write the following code to check the if user’s birthday makes them above 5 years old.
```ts title="Imports"
import { APIError } from "better-auth/api";
import { createAuthMiddleware } from "better-auth/plugins";
```
```ts title="Before hook"
{
  //...
  handler: createAuthMiddleware(async (ctx) => {
    const { birthday } = ctx.body;
    if(!(birthday instanceof Date)) {
      throw new APIError("BAD_REQUEST", { message: "Birthday must be of type Date." });
    }

    const today = new Date();
    const fiveYearsAgo = new Date(today.setFullYear(today.getFullYear() - 5));

    if(birthday >= fiveYearsAgo) {
      throw new APIError("BAD_REQUEST", { message: "User must be above 5 years old." });
    }

    return { context: ctx };
  }),
}
```

**Authorized!** 🔒

We’ve now successfully written code to ensure authorization for users above 5!

</Step>

<Step>
## Client Plugin
We’re close to the finish line! 🏁

Now that we have created our server plugin, the next step is to develop our client plugin.
Since there isn’t much frontend APIs going on for this plugin, there isn’t much to do!

First, let’s create our `client.ts` file first:
<Files>
  <Folder name="birthday-plugin" defaultOpen>
    <File name="index.ts" />
    <File name="client.ts" />
  </Folder>
</Files>
Then, add the following code:
```ts title="client.ts"
import type { BetterAuthClientPlugin } from "better-auth/client";
import type { birthdayPlugin } from "./index"; // make sure to import the server plugin as a type // [!code highlight]

type BirthdayPlugin = typeof birthdayPlugin;

export const birthdayClientPlugin = () => {
  return {
    id: "birthdayPlugin",
    $InferServerPlugin: {} as ReturnType<BirthdayPlugin>,
  } satisfies BetterAuthClientPlugin;
};
```
What we’ve done is allow the client plugin to infer the types defined by our schema from the server plugin.

And that’s it!  This is all it takes for the birthday client plugin. 🎂

</Step>

<Step>
## Initiate your plugin!
Both the `client` and `server` plugins are now ready, the last step is to import them to both your `auth-client.ts` and your `server.ts` files respectively to initiate the plugin.

### Server initiation
```ts title="server.ts"
import { betterAuth } from "better-auth";
import { birthdayPlugin } from "./birthday-plugin";// [!code highlight]
 
export const auth = betterAuth({
    plugins: [
      birthdayPlugin(),// [!code highlight]
    ]
});
```

### Client initiation
```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { birthdayClientPlugin } from "./birthday-plugin/client";// [!code highlight]
 
const authClient = createAuthClient({
    plugins: [
      birthdayClientPlugin()// [!code highlight]
    ]
});
```

### Oh yeah, the schemas! 
Don’t forget to add your `birthday` field to your `user` table model! 

Or, use the `generate` <Link href="/docs/concepts/cli#generate">CLI command</Link>:
```bash
npx auth@latest generate
```

</Step>
</Steps>

## Wrapping Up

Congratulations! You’ve successfully created your first ever Better Auth plugin.
We highly recommend you visit our <Link href="/docs/concepts/plugins">plugins documentation</Link> to learn more information.

If you have a plugin you’d like to share with the community, feel free to let us know through 
our <Link href="https://discord.gg/better-auth">Discord server</Link>,
or through a <Link href="https://github.com/better-auth/better-auth/pulls">pull-request</Link>
and we may add it to the <Link href="/docs/plugins/community-plugins">community-plugins</Link> list!
---
title: SAML SSO with Okta
description: A guide to integrating SAML Single Sign-On (SSO) with Better Auth, featuring Okta
---

This guide walks you through setting up SAML Single Sign-On (SSO) with your Identity Provider (IdP), using Okta as an example. For advanced configuration details and the full API reference, check out the [SSO Plugin Documentation](/docs/plugins/sso).

## What is SAML?

SAML (Security Assertion Markup Language) is an XML-based standard for exchanging authentication and authorization data between an Identity Provider (IdP) (e.g., Okta, Azure AD, OneLogin) and a Service Provider (SP) (in this case, Better Auth).

In this setup:

- **IdP (Okta)**: Authenticates users and sends assertions about their identity.
- **SP (Better Auth)**: Validates assertions and logs the user in.up.

### Step 1: Create a SAML Application in Okta

1. Log in to your Okta Admin Console
2. Navigate to Applications > Applications
3. Click "Create App Integration"
4. Select "SAML 2.0" as the Sign-in method
5. Configure the following settings:

   - **Single Sign-on URL**: Your Better Auth callback endpoint (e.g., `http://localhost:3000/api/auth/sso/saml2/callback/sso`). Note: `sso` is your `providerId`
   - **Audience URI (SP Entity ID)**: Your Better Auth metadata URL (e.g., `http://localhost:3000/api/auth/sso/saml2/sp/metadata`)
   - **Name ID format**: Email Address or any of your choice.

6. Download the IdP metadata XML file and certificate

<Callout type="info">
**IdP-Initiated SSO**: If you want users to access your app from the Okta dashboard, make sure the **Single Sign-on URL** points to the callback endpoint (`/api/auth/sso/saml2/callback/{providerId}`). Better Auth automatically handles both SP-initiated and IdP-initiated flows.
</Callout>

### Step 2: Configure Better Auth

Here’s an example configuration for Okta in a dev environment:

```typescript
const ssoConfig = {
  defaultSSO: [{
    domain: "localhost:3000", // Your domain
    providerId: "sso",
    samlConfig: {
      // SP Configuration
      issuer: "http://localhost:3000/api/auth/sso/saml2/sp/metadata",
      entryPoint: "https://trial-1076874.okta.com/app/trial-1076874_samltest_1/exktofb0a62hqLAUL697/sso/saml",
      callbackUrl: "/dashboard", // Redirect after successful authentication
      
      // IdP Configuration
      idpMetadata: {
        entityID: "https://trial-1076874.okta.com/app/exktofb0a62hqLAUL697/sso/saml/metadata",
        singleSignOnService: [{
          Binding: "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect",
          Location: "https://trial-1076874.okta.com/app/trial-1076874_samltest_1/exktofb0a62hqLAUL697/sso/saml"
        }],
      },
      cert: `-----BEGIN CERTIFICATE-----
MIIDqjCCApKgAwIBAgIGAZhVGMeUMA0GCSqGSIb3DQEBCwUAMIGVMQswCQYDVQQGEwJVUzETMBEG
...
[Your Okta Certificate]
...
-----END CERTIFICATE-----`,
      
      // SP Metadata
      spMetadata: {
        metadata: `<md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata" 
          entityID="http://localhost:3000/api/sso/saml2/sp/metadata">
          ...
          [Your SP Metadata XML]
          ...
        </md:EntityDescriptor>`
      }
    }
  }]
}
```

### Step 3: Multiple Default Providers (Optional)

You can configure multiple SAML providers for different domains:

```typescript
const ssoConfig = {
  defaultSSO: [
    {
      domain: "company.com",
      providerId: "company-okta",
      samlConfig: {
        // Okta SAML configuration for company.com
      }
    },
    {
      domain: "partner.com", 
      providerId: "partner-adfs",
      samlConfig: {
        // ADFS SAML configuration for partner.com
      }
    },
    {
      domain: "contractor.org",
      providerId: "contractor-azure",
      samlConfig: {
        // Azure AD SAML configuration for contractor.org
      }
    }
  ]
}
```

<Callout type="info">
**Explicit**: Pass providerId directly when signing in.
**Domain fallback:** Matches based on the user’s email domain. e.g. user@company.com → matches `company-okta` provider.
</Callout>


### Step 4: Initiating Sign-In

You can start an SSO flow in three ways:

**1. Explicitly by `providerId` (recommended):**

```typescript
// Explicitly specify which provider to use
await authClient.signIn.sso({
  providerId: "company-okta",
  callbackURL: "/dashboard"
});
```

**2. By email domain matching:**

```typescript
// Automatically matches provider based on email domain
await authClient.signIn.sso({
  email: "user@company.com",
  callbackURL: "/dashboard"
});
```

**3. By specifying domain:**

```typescript
// Explicitly specify domain for matching
await authClient.signIn.sso({
  domain: "partner.com",
  callbackURL: "/dashboard"
});
```

**Important Notes**:
 - DummyIDP should ONLY be used for development and testing
 - Never use these certificates in production
 - The example uses `localhost:3000` - adjust URLs for your environment
 - For production, always use proper IdP providers like Okta, Azure AD, or OneLogin
 - The `callbackUrl` in your SAML config should point to your app's destination (e.g., `/dashboard`), not the callback route itself

### Step 5: Dynamically Registering SAML Providers

For dynamic registration, you should register SAML providers using the API. See the [SSO Plugin Documentation](/docs/plugins/sso#register-a-saml-provider) for detailed registration instructions.

Example registration:

```typescript
await authClient.sso.register({
  providerId: "okta-prod",
  issuer: "https://your-domain.com",
  domain: "your-domain.com",
  samlConfig: {
    // Your production SAML configuration
  }
});
```

## Additional Resources

- [SSO Plugin Documentation](/docs/plugins/sso)
- [Okta SAML Documentation](https://developer.okta.com/docs/concepts/saml/)
- [SAML 2.0 Specification](https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf)
---
title: Browser Extension Guide
description: A step-by-step guide to creating a browser extension with Better Auth.
---

In this guide, we'll walk you through the steps of creating a browser extension using <Link href="https://docs.plasmo.com/">Plasmo</Link> with Better Auth for authentication.

If you would like to view a completed example, you can check out the <Link href="https://github.com/better-auth/examples/tree/main/browser-extension-example">browser extension example</Link>.

<Callout type="warn">
  The Plasmo framework does not provide a backend for the browser extension.
  This guide assumes you have{" "}
  <Link href="/docs/integrations/hono">a backend setup</Link> of Better Auth and
  are ready to create a browser extension to connect to it.
</Callout>

<Steps>

    <Step>
        ## Setup & Installations

        Initialize a new Plasmo project with TailwindCSS and a src directory.

        ```bash
        pnpm create plasmo --with-tailwindcss --with-src
        ```

        Then, install the Better Auth package.

        ```bash
        pnpm add better-auth
        ```

        To start the Plasmo development server, run the following command.

        ```bash
        pnpm dev
        ```
    </Step>


    <Step>
        ## Configure tsconfig

        Configure the `tsconfig.json` file to include `strict` mode.

        For this demo, we have also changed the import alias from `~` to `@` and set it to the `src` directory.

        ```json title="tsconfig.json"
        {
            "compilerOptions": {
                "paths": {
                    "@/_": [
                        "./src/_"
                    ]
                },
                "strict": true,
                "baseUrl": "."
            }
        }
        ```
    </Step>


    <Step>
        ## Create the client auth instance

        Create a new file at `src/auth/auth-client.ts` and add the following code.

       <Files>
            <Folder name="src" defaultOpen>
                <Folder name="auth" defaultOpen>
                    <File name="auth-client.ts" />
                </Folder>
            </Folder>
       </Files>

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/react"

        export const authClient = createAuthClient({
            baseURL: "http://localhost:3000" /* Base URL of your Better Auth backend. */,
            plugins: [],
        });
        ```
    </Step>

    <Step>
        ## Configure the manifest

        We must ensure the extension knows the URL to the Better Auth backend.

        Head to your package.json file, and add the following code.

        ```json title="package.json"
        {
            //...
            "manifest": {
                "host_permissions": [
                    "https://URL_TO_YOUR_BACKEND" // localhost works too (e.g. http://localhost:3000)
                ]
            }
        }
        ```
    </Step>


    <Step>
        ## You're now ready!

        You have now set up Better Auth for your browser extension.

        Add your desired UI and create your dream extension!

        To learn more about the client Better Auth API, check out the <Link href="/docs/concepts/client">client documentation</Link>.


        Here's a quick example 😎

        ```tsx title="src/popup.tsx"
        import { authClient } from "./auth/auth-client"


        function IndexPopup() {
            const {data, isPending, error} = authClient.useSession();
            if(isPending){
                return <>Loading...</>
            }
            if(error){
                return <>Error: {error.message}</>
            }
            if(data){
                return <>Signed in as {data.user.name}</>
            }
        }

        export default IndexPopup;
        ```

    </Step>


    <Step>
        ## Bundle your extension

        To get a production build, run the following command.

        ```bash
        pnpm build
        ```

        Head over to <Link href="chrome://extensions" target="_blank">chrome://extensions</Link> and enable developer mode.

        <img src="https://docs.plasmo.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdeveloper_mode.76f090f7.png&w=1920&q=75" />

        Click on "Load Unpacked" and navigate to your extension's `build/chrome-mv3-dev` (or `build/chrome-mv3-prod`) directory.

        To see your popup, click on the puzzle piece icon on the Chrome toolbar, and click on your extension.

        Learn more about <Link href="https://docs.plasmo.com/framework#loading-the-extension-in-chrome">bundling your extension here.</Link>
    </Step>

    <Step>
        ## Configure the server auth instance

        First, we will need your extension URL.
        
        An extension URL formed like this: `chrome-extension://YOUR_EXTENSION_ID`.

        You can find your extension ID at <Link href="chrome://extensions" target="_blank">chrome://extensions</Link>.

        <img src="/extension-id.png" width={500} />

        Head to your server's auth file, and make sure that your extension's URL is added to the `trustedOrigins` list.


        ```ts title="server.ts"
        import { betterAuth } from "better-auth"
        import { auth } from "@/auth/auth"

        export const auth = betterAuth({
            trustedOrigins: ["chrome-extension://YOUR_EXTENSION_ID"],
        })
        ```

        If you're developing multiple extensions or need to support different browser extensions with different IDs, you can use wildcard patterns:

        ```ts title="server.ts"
        export const auth = betterAuth({
            trustedOrigins: [
                // Support a specific extension ID
                "chrome-extension://YOUR_EXTENSION_ID",
                
                // Or support multiple extensions with wildcard (less secure)
                "chrome-extension://*"
            ],
        })
        ```

        <Callout type="warn">
          Using wildcards for extension origins (`chrome-extension://*`) reduces security by trusting all extensions. 
          It's safer to explicitly list each extension ID you trust. Only use wildcards for development and testing.
        </Callout>
    </Step>

    <Step>
        ## That's it!

        Everything is set up! You can now start developing your extension. 🎉
    </Step>

</Steps>


## Wrapping Up

Congratulations! You've successfully created a browser extension using Better Auth and Plasmo.
We highly recommend you visit the <Link href="https://docs.plasmo.com/">Plasmo documentation</Link> to learn more about the framework.

If you would like to view a completed example, you can check out the <Link href="https://github.com/better-auth/examples/tree/main/browser-extension-example">browser extension example</Link>.

If you have any questions, feel free to open an issue on our <Link href="https://github.com/better-auth/better-auth/issues">GitHub repo</Link>, or join our <Link href="https://discord.gg/better-auth">Discord server</Link> for support.
---
title: Create a Database Adapter
description: Learn how to create a custom database adapter for Better-Auth
---

Learn how to create a custom database adapter for Better-Auth using `createAdapterFactory`.

Our `createAdapterFactory` function is designed to be very flexible, and we've done our best to make it easy to understand and use.
Our hope is to allow you to focus on writing database logic, and not have to worry about how the adapter is working with Better-Auth.

Anything from custom schema configurations, custom ID generation, safe JSON parsing, key mapping, joins, and more is handled by the `createAdapterFactory` function.
All you need to do is provide the database logic, and the `createAdapterFactory` function will handle the rest.

## Quick Start

<Steps>
<Step>
### Get things ready

1. Import `createAdapterFactory`.
2. Create `CustomAdapterConfig` interface that represents your adapter config options.
3. Create the adapter!

```ts
import { createAdapterFactory, type DBAdapterDebugLogOption } from "better-auth/adapters";

// Your custom adapter config options
interface CustomAdapterConfig {
  /**
   * Helps you debug issues with the adapter.
   */
  debugLogs?: DBAdapterDebugLogOption;
  /**
   * If the table names in the schema are plural.
   */
  usePlural?: boolean;
}

export const myAdapter = (config: CustomAdapterConfig = {}) =>
  createAdapterFactory({
    // ...
  });
```

</Step>

<Step>
### Configure the adapter

The `config` object is mostly used to provide information about the adapter to Better-Auth.
We try to minimize the amount of code you need to write in your adapter functions, and these `config` options are used to help us do that.

```ts
// ...
export const myAdapter = (config: CustomAdapterConfig = {}) =>
  createAdapterFactory({
    config: {
      adapterId: "custom-adapter", // A unique identifier for the adapter.
      adapterName: "Custom Adapter", // The name of the adapter.
      usePlural: config.usePlural ?? false, // Whether the table names in the schema are plural.
      debugLogs: config.debugLogs ?? false, // Whether to enable debug logs.
      supportsJSON: false, // Whether the database supports JSON. (Default: false)
      supportsDates: true, // Whether the database supports dates. (Default: true)
      supportsBooleans: true, // Whether the database supports booleans. (Default: true)
      supportsNumericIds: true, // Whether the database supports auto-incrementing numeric IDs. (Default: true)
    },
    // ...
  });
```
</Step>

<Step>
### Create the adapter

The `adapter` function is where you write the code that interacts with your database.

```ts
// ...
export const myAdapter = (config: CustomAdapterConfig = {}) =>
  createAdapterFactory({
    config: {
      // ...
    },
    adapter: ({}) => {
      return {
        create: async ({ data, model, select }) => {
          // ...
        },
        update: async ({ data, model, select }) => {
          // ...
        },
        updateMany: async ({ data, model, select }) => {
          // ...
        },
        delete: async ({ data, model, select }) => {
          // ...
        },
        // ...
      };
    },
  });
```

<Callout>
Learn more about the `adapter` here [here](/docs/concepts/database#adapters).
</Callout>
</Step>

</Steps>

## Adapter

The `adapter` function is where you write the code that interacts with your database.

If you haven't already, check out the `options` object in the [config section](#config), as it can be useful for your adapter.

Before we get into the adapter function, let's go over the parameters that are available to you.

- `options`: The Better Auth options.
- `schema`: The schema from the user's Better Auth instance.
- `debugLog`: The debug log function.
- `getFieldName`: Function to get the transformed field name for the database.
- `getModelName`: Function to get the transformed model name for the database.
- `getDefaultModelName`: Function to get the default model name from the schema.
- `getDefaultFieldName`: Function to get the default field name from the schema.
- `getFieldAttributes`: Function to get field attributes for a specific model and field.
- `transformInput`: Function to transform input data before saving to the database.
- `transformOutput`: Function to transform output data after retrieving from the database.
- `transformWhereClause`: Function to transform where clauses for database queries.

```ts title="Example"
adapter: ({
  options,
  schema,
  debugLog,
  getFieldName,
  getModelName,
  getDefaultModelName,
  getDefaultFieldName,
  getFieldAttributes,
  transformInput,
  transformOutput,
  transformWhereClause,
}) => {
  return {
    // ...
  };
};
```

### Adapter Methods

- All `model` values are already transformed into the correct model name for the database based on the end-user's schema configuration.
  - This also means that if you need access to the `schema` version of a given model, you can't use this exact `model` value, you'll need to use the `getDefaultModelName` function provided in the options to convert the `model` to the `schema` version.
- We will automatically fill in any missing fields you return based on the user's `schema` configuration.
- Any method that includes a `select` parameter, is only for the purpose of getting data from your database more efficiently. You do not need to worry about only returning what the `select` parameter states, as we will handle that for you.

### `create` method

The `create` method is used to create a new record in the database.

<Callout>
It's possible to pass `forceAllowId` as a parameter to the `create` method, which allows `id` to be provided in the `data` object.
We handle `forceAllowId` internally, so you don't need to worry about it.
</Callout>

parameters:

- `model`: The model/table name that new data will be inserted into.
- `data`: The data to insert into the database.
- `select`: An array of fields to return from the database.

<Callout>
  Make sure to return the data that is inserted into the database.
</Callout>

```ts title="Example"
create: async ({ model, data, select }) => {
  // Example of inserting data into the database.
  return await db.insert(model).values(data);
};
```

### `update` method

The `update` method is used to update a record in the database.

parameters:

- `model`: The model/table name that the record will be updated in.
- `where`: The `where` clause to update the record by.
- `update`: The data to update the record with.

<Callout>
  Make sure to return the data in the row which is updated. This includes any
  fields that were not updated.
</Callout>

```ts title="Example"
update: async ({ model, where, update }) => {
  // Example of updating data in the database.
  return await db.update(model).set(update).where(where);
};
```

### `updateMany` method

The `updateMany` method is used to update multiple records in the database.

parameters:

- `model`: The model/table name that the records will be updated in.
- `where`: The `where` clause to update the records by.
- `update`: The data to update the records with.

<Callout>Make sure to return the number of records that were updated.</Callout>

```ts title="Example"
updateMany: async ({ model, where, update }) => {
  // Example of updating multiple records in the database.
  return await db.update(model).set(update).where(where);
};
```

### `delete` method

The `delete` method is used to delete a record from the database.

parameters:

- `model`: The model/table name that the record will be deleted from.
- `where`: The `where` clause to delete the record by.

```ts title="Example"
delete: async ({ model, where }) => {
  // Example of deleting a record from the database.
  await db.delete(model).where(where);
}
```

### `deleteMany` method

The `deleteMany` method is used to delete multiple records from the database.

parameters:

- `model`: The model/table name that the records will be deleted from.
- `where`: The `where` clause to delete the records by.

<Callout>Make sure to return the number of records that were deleted.</Callout>

```ts title="Example"
deleteMany: async ({ model, where }) => {
  // Example of deleting multiple records from the database.
  return await db.delete(model).where(where);
};
```

### `findOne` method

The `findOne` method is used to find a single record in the database.

parameters:

- `model`: The model/table name that the record will be found in.
- `where`: The `where` clause to find the record by.
- `select`: The `select` clause to return.
- `join`: Optional join configuration to fetch related records in a single query.

<Callout>Make sure to return the data that is found in the database.</Callout>

```ts title="Example"
findOne: async ({ model, where, select, join }) => {
  // Example of finding a single record in the database.
  return await db.select().from(model).where(where).limit(1);
};
```

### `findMany` method

The `findMany` method is used to find multiple records in the database.

parameters:

- `model`: The model/table name that the records will be found in.
- `where`: The `where` clause to find the records by.
- `limit`: The limit of records to return.
- `sortBy`: The `sortBy` clause to sort the records by.
- `offset`: The offset of records to return.
- `join`: Optional join configuration to fetch related records in a single query.

<Callout>
  Make sure to return the array of data that is found in the database.
</Callout>

```ts title="Example"
findMany: async ({ model, where, limit, sortBy, offset, join }) => {
  // Example of finding multiple records in the database.
  return await db
    .select()
    .from(model)
    .where(where)
    .limit(limit)
    .offset(offset)
    .orderBy(sortBy);
};
```

### `count` method

The `count` method is used to count the number of records in the database.

parameters:

- `model`: The model/table name that the records will be counted in.
- `where`: The `where` clause to count the records by.

<Callout>Make sure to return the number of records that were counted.</Callout>

```ts title="Example"
count: async ({ model, where }) => {
  // Example of counting the number of records in the database.
  return await db.select().from(model).where(where).count();
};
```

### `options` (optional)

The `options` object is for any potential config that you got from your custom adapter options.

```ts title="Example"
const myAdapter = (config: CustomAdapterConfig) =>
  createAdapterFactory({
    config: {
      // ...
    },
    adapter: ({ options }) => {
      return {
        options: config,
      };
    },
  });
```

### `createSchema` (optional)

The `createSchema` method allows the [Better Auth CLI](/docs/concepts/cli) to [generate](/docs/concepts/cli/#generate) a schema for the database.

parameters:

- `tables`: The tables from the user's Better-Auth instance schema; which is expected to be generated into the schema file.
- `file`: The file the user may have passed in to the `generate` command as the expected schema file output path.

```ts title="Example"
createSchema: async ({ file, tables }) => {
  // ... Custom logic to create a schema for the database.
};
```

## Test your adapter

We've provided a test suite that you can use to test your adapter. It requires you to use `vitest`.

```ts title="my-adapter.test.ts"
import { expect, test, describe } from "vitest";
import { runAdapterTest } from "better-auth/adapters/test";
import { myAdapter } from "./my-adapter";

describe("My Adapter Tests", async () => {
  afterAll(async () => {
    // Run DB cleanup here...
  });
  const adapter = myAdapter({
    debugLogs: {
      // If your adapter config allows passing in debug logs, then pass this here.
      isRunningAdapterTests: true, // This is our super secret flag to let us know to only log debug logs if a test fails.
    },
  });

  runAdapterTest({
    getAdapter: async (betterAuthOptions = {}) => {
      return adapter(betterAuthOptions);
    },
  });
});
```

### Numeric ID tests

If your database supports numeric IDs, then you should run this test as well:

```ts title="my-adapter.number-id.test.ts"
import { expect, test, describe } from "vitest";
import { runNumberIdAdapterTest } from "better-auth/adapters/test";
import { myAdapter } from "./my-adapter";

describe("My Adapter Numeric ID Tests", async () => {
  afterAll(async () => {
    // Run DB cleanup here...
  });
  const adapter = myAdapter({
    debugLogs: {
      // If your adapter config allows passing in debug logs, then pass this here.
      isRunningAdapterTests: true, // This is our super secret flag to let us know to only log debug logs if a test fails.
    },
  });

  runNumberIdAdapterTest({
    getAdapter: async (betterAuthOptions = {}) => {
      return adapter(betterAuthOptions);
    },
  });
});
```

## Config

The `config` object is used to provide information about the adapter to Better-Auth.

We **highly recommend** going through and reading each provided option below, as it will help you understand how to properly configure your adapter.

### Required Config

### `adapterId`

A unique identifier for the adapter.

### `adapterName`

The name of the adapter.

### Optional Config

### `supportsNumericIds`

Whether the database supports numeric IDs. If this is set to `false` and the user's config has enabled `useNumberId`, then we will throw an error.

### `supportsJSON`

Whether the database supports JSON. If the database doesn't support JSON, we will use a `string` to save the JSON data.And when we retrieve the data, we will safely parse the `string` back into a JSON object.

### `supportsDates`

Whether the database supports dates. If the database doesn't support dates, we will use a `string` to save the date. (ISO string) When we retrieve the data, we will safely parse the `string` back into a `Date` object.

### `supportsBooleans`

Whether the database supports booleans. If the database doesn't support booleans, we will use a `0` or `1` to save the boolean value. When we retrieve the data, we will safely parse the `0` or `1` back into a boolean value.

### `usePlural`

Whether the table names in the schema are plural. This is often defined by the user, and passed down through your custom adapter options. If you do not intend to allow the user to customize the table names, you can ignore this option, or set this to `false`.

```ts title="Example"
const adapter = myAdapter({
  // This value then gets passed into the `usePlural`
  // option in the createAdapterFactory `config` object.
  usePlural: true,
});
```

### `transaction`

Whether the adapter supports transactions. If `false`, operations run sequentially; otherwise provide a function that executes a callback with a `TransactionAdapter`.

<Callout type="warn">
  If your database does not support transactions, the error handling and rollback
  will not be as robust. We recommend using a database that supports transactions
  for better data integrity.
</Callout>

### `debugLogs`

Used to enable debug logs for the adapter. You can pass in a boolean, or an object with the following keys: `create`, `update`, `updateMany`, `findOne`, `findMany`, `delete`, `deleteMany`, `count`.
If any of the keys are `true`, the debug logs will be enabled for that method.

```ts title="Example"
// Will log debug logs for all methods.
const adapter = myAdapter({
  debugLogs: true,
});
```

```ts title="Example"
// Will only log debug logs for the `create` and `update` methods.
const adapter = myAdapter({
  debugLogs: {
    create: true,
    update: true,
  },
});
```

### `disableIdGeneration`

Whether to disable ID generation. If this is set to `true`, then the user's `generateId` option will be ignored.

### `customIdGenerator`

If your database only supports a specific custom ID generation, then you can use this option to generate your own IDs.

### `mapKeysTransformInput`

If your database uses a different key name for a given situation, you can use this option to map the keys. This is useful for databases that expect a different key name for a given situation.
For example, MongoDB uses `_id` while in Better-Auth we use `id`.

Each key in the returned object represents the old key to replace.
The value represents the new key.

This can be a partial object that only transforms some keys.

```ts title="Example"
mapKeysTransformInput: {
  id: "_id", // We want to replace `id` to `_id` to save into MongoDB
},
```

### `mapKeysTransformOutput`

If your database uses a different key name for a given situation, you can use this option to map the keys. This is useful for databases that use a different key name for a given situation.
For example, MongoDB uses `_id` while in Better-Auth we use `id`.

Each key in the returned object represents the old key to replace.
The value represents the new key.

This can be a partial object that only transforms some keys.

```ts title="Example"
mapKeysTransformOutput: {
  _id: "id", // We want to replace `_id` (from MongoDB) to `id` (for Better-Auth)
},
```

### `customTransformInput`

If you need to transform the input data before it is saved to the database, you can use this option to transform the data.

<Callout type="warn">
  If you're using `supportsJSON`, `supportsDates`, or `supportsBooleans`, then
  the transformations will be applied before your `customTransformInput`
  function is called.
</Callout>
The `customTransformInput` function receives the following arguments:

- `data`: The data to transform.
- `field`: The field that is being transformed.
- `fieldAttributes`: The field attributes of the field that is being transformed.
- `action`: The action which was called from the adapter (`create` or `update`).
- `model`: The model that is being transformed.
- `schema`: The schema that is being transformed.
- `options`: Better Auth options.

The `customTransformInput` function runs at every key in the data object of a given action.

```ts title="Example"
customTransformInput: ({ field, data }) => {
  if (field === "id") {
    return "123"; // Force the ID to be "123"
  }

  return data;
};
```

### `customTransformOutput`

If you need to transform the output data before it is returned to the user, you can use this option to transform the data. The `customTransformOutput` function is used to transform the output data.
Similar to the `customTransformInput` function, it runs at every key in the data object of a given action, but it runs after the data is retrieved from the database.

```ts title="Example"
customTransformOutput: ({ field, data }) => {
  if (field === "name") {
    return "Bob"; // Force the name to be "Bob"
  }

  return data;
};
```

```ts
const some_data = await adapter.create({
  model: "user",
  data: {
    name: "John",
  },
});

// The name will be "Bob"
console.log(some_data.name);
```

### `disableTransformInput`

Whether to disable input transformation. This should only be used if you know what you're doing and are manually handling all transformations.

<Callout type="warn">
  Disabling input transformation can break important adapter functionality like ID generation, boolean/date/JSON conversion, and key mapping.
</Callout>

### `disableTransformOutput`

Whether to disable output transformation. This should only be used if you know what you're doing and are manually handling all transformations.

<Callout type="warn">
  Disabling output transformation can break important adapter functionality like boolean/date/JSON parsing and key mapping.
</Callout>

### `disableTransformJoin`

Whether to disable join transformation. This should only be used if you know what you're doing and are manually handling joins.

<Callout type="warn">
  Disabling join transformation can break join functionality.
</Callout>

### `supportsJoin`

Whether the adapter supports native joins. If set to `false` (the default), Better-Auth will handle joins by making multiple queries and combining the results. If set to `true`, the adapter is expected to handle joins natively (e.g., SQL JOIN operations).

```ts title="Example"
// For adapters that support native SQL joins
const adapter = myAdapter({
  supportsJoin: true,
});
```
 ---
title: Migrating from Auth0 to Better Auth
description: A step-by-step guide to transitioning from Auth0 to Better Auth.
---

In this guide, we'll walk through the steps to migrate a project from Auth0 to Better Auth — including email/password with proper hashing, social/external accounts, two-factor authentication, and more.

<Callout type="warn">
This migration will invalidate all active sessions. This guide doesn't currently show you how to migrate Organizations but it should be possible with additional steps and the [Organization](/docs/plugins/organization) Plugin.
</Callout>

## Before You Begin

Before starting the migration process, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started.

<Steps>
<Step>
### Connect to your database

You'll need to connect to your database to migrate the users and accounts. You can use any database you want, but for this example, we'll use PostgreSQL.

```package-install
npm install pg
```

And then you can use the following code to connect to your database.

```ts title="auth.ts"
import { Pool } from "pg";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
})
```
</Step>
<Step>
### Enable Email and Password (Optional)

Enable the email and password in your auth config and implement your own logic for sending verification emails, reset password emails, etc.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { // [!code highlight]
        enabled: true, // [!code highlight]
    }, // [!code highlight]
    emailVerification: {
      sendVerificationEmail: async({ user, url })=>{
        // implement your logic here to send email verification
      }
    },
})
```

See [Email and Password](/docs/authentication/email-password) for more configuration options.
</Step>
<Step>
### Setup Social Providers (Optional)

Add social providers you have enabled in your Auth0 project in your auth config.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
    },
    socialProviders: { // [!code highlight]
        google: { // [!code highlight]
            clientId: process.env.GOOGLE_CLIENT_ID, // [!code highlight]
            clientSecret: process.env.GOOGLE_CLIENT_SECRET, // [!code highlight]
        }, // [!code highlight]
        github: { // [!code highlight]
            clientId: process.env.GITHUB_CLIENT_ID, // [!code highlight]
            clientSecret: process.env.GITHUB_CLIENT_SECRET, // [!code highlight]
        } // [!code highlight]
    } // [!code highlight]
})
```
</Step>
<Step>
### Add Plugins (Optional)

You can add the following plugins to your auth config based on your needs.

[Admin](/docs/plugins/admin) Plugin will allow you to manage users, user impersonations and app level roles and permissions.

[Two Factor](/docs/plugins/2fa) Plugin will allow you to add two-factor authentication to your application.

[Username](/docs/plugins/username) Plugin will allow you to add username authentication to your application.

```ts title="auth.ts"
import { Pool } from "pg";
import { betterAuth } from "better-auth";
import { admin, twoFactor, username } from "better-auth/plugins";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
        password: {
            verify: (data) => {
                // this for an edgecase that you might run in to on verifying the password
            }
        }
    },
    socialProviders: {
        google: {
            clientId: process.env.GOOGLE_CLIENT_ID!,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
        },
        github: {
            clientId: process.env.GITHUB_CLIENT_ID!,
            clientSecret: process.env.GITHUB_CLIENT_SECRET!,
        }
    },
    plugins: [admin(), twoFactor(), username()], // [!code highlight]
})
```
</Step>
<Step>
### Generate Schema

If you're using a custom database adapter, generate the schema:

```sh
npx auth generate
```

or if you're using the default adapter, you can use the following command:

```sh
npx auth migrate
```
</Step>
<Step>
### Install Dependencies

Install the required dependencies for the migration:

```bash
npm install auth0
```
</Step>
<Step>
### Create the migration script

Create a new file called `migrate-auth0.ts` in the `scripts` folder and add the following code:

<Callout type="info">
Instead of using the Management API, you can use Auth0's bulk user export functionality and pass the exported JSON data directly to the `auth0Users` array. This is especially useful if you need to migrate password hashes and complete user data, which are not available through the Management API.

**Important Notes:**
- Password hashes export is only available for Auth0 Enterprise users
- Free plan users cannot export password hashes and will need to request a support ticket
- For detailed information about bulk user exports, see the [Auth0 Bulk User Export Documentation](https://auth0.com/docs/manage-users/user-migration/bulk-user-exports)
- For password hash export details, refer to [Exporting Password Hashes](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data#user-passwords)

Example:
```ts
// Replace this with your exported users JSON data
const auth0Users = [
  {
    "email": "helloworld@gmail.com",
    "email_verified": false,
    "name": "Hello world",
    // Note: password_hash is only available for Enterprise users
    "password_hash": "$2b$10$w4kfaZVjrcQ6ZOMiG.M8JeNvnVQkPKZV03pbDUHbxy9Ug0h/McDXi",
    // ... other user data
  }
];
```
</Callout>

```ts title="scripts/migrate-auth0.ts"
import { ManagementClient } from 'auth0';
import { generateRandomString, symmetricEncrypt } from "better-auth/crypto";
import { auth } from '@/lib/auth';

const auth0Client = new ManagementClient({
    domain: process.env.AUTH0_DOMAIN!,
    clientId: process.env.AUTH0_CLIENT_ID!,
    clientSecret: process.env.AUTH0_SECRET!,
});



function safeDateConversion(timestamp?: string | number): Date {
    if (!timestamp) return new Date();

    const numericTimestamp = typeof timestamp === 'string' ? Date.parse(timestamp) : timestamp;

    const milliseconds = numericTimestamp < 1000000000000 ? numericTimestamp * 1000 : numericTimestamp;

    const date = new Date(milliseconds);

    if (isNaN(date.getTime())) {
        console.warn(`Invalid timestamp: ${timestamp}, falling back to current date`);
        return new Date();
    }

    // Check for unreasonable dates (before 2000 or after 2100)
    const year = date.getFullYear();
    if (year < 2000 || year > 2100) {
        console.warn(`Suspicious date year: ${year}, falling back to current date`);
        return new Date();
    }

    return date;
}

// Helper function to generate backup codes for 2FA
async function generateBackupCodes(secret: string) {
    const key = secret;
    const backupCodes = Array.from({ length: 10 })
        .fill(null)
        .map(() => generateRandomString(10, "a-z", "0-9", "A-Z"))
        .map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);

    const encCodes = await symmetricEncrypt({
        data: JSON.stringify(backupCodes),
        key: key,
    });
    return encCodes;
}

function mapAuth0RoleToBetterAuthRole(auth0Roles: string[]) {
    if (typeof auth0Roles === 'string') return auth0Roles;
    if (Array.isArray(auth0Roles)) return auth0Roles.join(',');
}
// helper function to migrate password from auth0 to better auth for custom hashes and algs
async function migratePassword(auth0User: any) {
    if (auth0User.password_hash) {
        if (auth0User.password_hash.startsWith('$2a$') || auth0User.password_hash.startsWith('$2b$')) {
            return auth0User.password_hash;
        }
    }

    if (auth0User.custom_password_hash) {
        const customHash = auth0User.custom_password_hash;

        if (customHash.algorithm === 'bcrypt') {
            const hash = customHash.hash.value;
            if (hash.startsWith('$2a$') || hash.startsWith('$2b$')) {
                return hash;
            }
        }

        return JSON.stringify({
            algorithm: customHash.algorithm,
            hash: {
                value: customHash.hash.value,
                encoding: customHash.hash.encoding || 'utf8',
                ...(customHash.hash.digest && { digest: customHash.hash.digest }),
                ...(customHash.hash.key && {
                    key: {
                        value: customHash.hash.key.value,
                        encoding: customHash.hash.key.encoding || 'utf8'
                    }
                })
            },
            ...(customHash.salt && {
                salt: {
                    value: customHash.salt.value,
                    encoding: customHash.salt.encoding || 'utf8',
                    position: customHash.salt.position || 'prefix'
                }
            }),
            ...(customHash.password && {
                password: {
                    encoding: customHash.password.encoding || 'utf8'
                }
            }),
            ...(customHash.algorithm === 'scrypt' && {
                keylen: customHash.keylen,
                cost: customHash.cost || 16384,
                blockSize: customHash.blockSize || 8,
                parallelization: customHash.parallelization || 1
            })
        });
    }

    return null;
}

async function migrateMFAFactors(auth0User: any, userId: string | undefined, ctx: any) {
    if (!userId || !auth0User.mfa_factors || !Array.isArray(auth0User.mfa_factors)) {
        return;
    }

    for (const factor of auth0User.mfa_factors) {
        try {
            if (factor.totp && factor.totp.secret) {
                await ctx.adapter.create({
                    model: "twoFactor",
                    data: {
                        userId: userId,
                        secret: factor.totp.secret,
                        backupCodes: await generateBackupCodes(factor.totp.secret)
                    }
                });
            }
        } catch (error) {
            console.error(`Failed to migrate MFA factor for user ${userId}:`, error);
        }
    }
}

async function migrateOAuthAccounts(auth0User: any, userId: string | undefined, ctx: any) {
    if (!userId || !auth0User.identities || !Array.isArray(auth0User.identities)) {
        return;
    }

    for (const identity of auth0User.identities) {
        try {
            const providerId = identity.provider === 'auth0' ? "credential" : identity.provider.split("-")[0];
            await ctx.adapter.create({
                model: "account",
                data: {
                    id: `${auth0User.user_id}|${identity.provider}|${identity.user_id}`,
                    userId: userId,
                    password: await migratePassword(auth0User),
                    providerId: providerId || identity.provider,
                    accountId: identity.user_id,
                    accessToken: identity.access_token,
                    tokenType: identity.token_type,
                    refreshToken: identity.refresh_token,
                    accessTokenExpiresAt: identity.expires_in ? new Date(Date.now() + identity.expires_in * 1000) : undefined,
                    // if you are enterprise user, you can get the refresh tokens or all the tokensets - auth0Client.users.getAllTokensets 
                    refreshTokenExpiresAt: identity.refresh_token_expires_in ? new Date(Date.now() + identity.refresh_token_expires_in * 1000) : undefined,

                    scope: identity.scope,
                    idToken: identity.id_token,
                    createdAt: safeDateConversion(auth0User.created_at),
                    updatedAt: safeDateConversion(auth0User.updated_at)
                },
                forceAllowId: true
            }).catch((error: Error) => {
                console.error(`Failed to create OAuth account for user ${userId} with provider ${providerId}:`, error);
                return ctx.adapter.create({
                    // Try creating without optional fields if the first attempt failed
                    model: "account",
                    data: {
                        id: `${auth0User.user_id}|${identity.provider}|${identity.user_id}`,
                        userId: userId,
                        password: migratePassword(auth0User),
                        providerId: providerId,
                        accountId: identity.user_id,
                        accessToken: identity.access_token,
                        tokenType: identity.token_type,
                        refreshToken: identity.refresh_token,
                        accessTokenExpiresAt: identity.expires_in ? new Date(Date.now() + identity.expires_in * 1000) : undefined,
                        refreshTokenExpiresAt: identity.refresh_token_expires_in ? new Date(Date.now() + identity.refresh_token_expires_in * 1000) : undefined,
                        scope: identity.scope,
                        idToken: identity.id_token,
                        createdAt: safeDateConversion(auth0User.created_at),
                        updatedAt: safeDateConversion(auth0User.updated_at)
                    },
                    forceAllowId: true
                });
            });

            console.log(`Successfully migrated OAuth account for user ${userId} with provider ${providerId}`);
        } catch (error) {
            console.error(`Failed to migrate OAuth account for user ${userId}:`, error);
        }
    }
}

async function migrateOrganizations(ctx: any) {
    try {
        const organizations = await auth0Client.organizations.getAll();
        for (const org of organizations.data || []) {
            try {
                await ctx.adapter.create({
                    model: "organization",
                    data: {
                        id: org.id,
                        name: org.display_name || org.id,
                        slug: (org.display_name || org.id).toLowerCase().replace(/[^a-z0-9]/g, '-'),
                        logo: org.branding?.logo_url,
                        metadata: JSON.stringify(org.metadata || {}),
                        createdAt: safeDateConversion(org.created_at),
                    },
                    forceAllowId: true
                });
                const members = await auth0Client.organizations.getMembers({ id: org.id });
                for (const member of members.data || []) {
                    try {
                        const userRoles = await auth0Client.organizations.getMemberRoles({
                            id: org.id,
                            user_id: member.user_id
                        });
                        const role = mapAuth0RoleToBetterAuthRole(userRoles.data?.map(r => r.name) || []);
                        await ctx.adapter.create({
                            model: "member",
                            data: {
                                id: `${org.id}|${member.user_id}`,
                                organizationId: org.id,
                                userId: member.user_id,
                                role: role,
                                createdAt: new Date()
                            },
                            forceAllowId: true
                        });

                        console.log(`Successfully migrated member ${member.user_id} for organization ${org.display_name || org.id}`);
                    } catch (error) {
                        console.error(`Failed to migrate member ${member.user_id} for organization ${org.display_name || org.id}:`, error);
                    }
                }

                console.log(`Successfully migrated organization: ${org.display_name || org.id}`);
            } catch (error) {
                console.error(`Failed to migrate organization ${org.display_name || org.id}:`, error);
            }
        }
        console.log('Organization migration completed');
    } catch (error) {
        console.error('Failed to migrate organizations:', error);
    }
}

async function migrateFromAuth0() {
    try {
        const ctx = await auth.$context;
        const isAdminEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "admin");
        const isUsernameEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "username");
        const isOrganizationEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "organization");
        const perPage = 100;
        const auth0Users: any[] = [];
        let pageNumber = 0;

        while (true) {
            try {
                const params = {
                    per_page: perPage,
                    page: pageNumber,
                    include_totals: true,
                };
                const response = (await auth0Client.users.getAll(params)).data as any;
                const users = response.users || [];
                if (users.length === 0) break;
                auth0Users.push(...users);
                pageNumber++;

                if (users.length < perPage) break;
            } catch (error) {
                console.error('Error fetching users:', error);
                break;
            }
        }


        console.log(`Found ${auth0Users.length} users to migrate`);

        for (const auth0User of auth0Users) {
            try {
                // Determine if this is a password-based or OAuth user
                const isOAuthUser = auth0User.identities?.some((identity: any) => identity.provider !== 'auth0');
                // Base user data that's common for both types
                const baseUserData = {
                    id: auth0User.user_id,
                    email: auth0User.email,
                    emailVerified: auth0User.email_verified || false,
                    name: auth0User.name || auth0User.nickname,
                    image: auth0User.picture,
                    createdAt: safeDateConversion(auth0User.created_at),
                    updatedAt: safeDateConversion(auth0User.updated_at),
                    ...(isAdminEnabled ? {
                        banned: auth0User.blocked || false,
                        role: mapAuth0RoleToBetterAuthRole(auth0User.roles || []),
                    } : {}),

                    ...(isUsernameEnabled ? {
                        username: auth0User.username || auth0User.nickname,
                    } : {}),

                };

                const createdUser = await ctx.adapter.create({
                    model: "user",
                    data: {
                        ...baseUserData,
                    },
                    forceAllowId: true
                });

                if (!createdUser?.id) {
                    throw new Error('Failed to create user');
                }


                await migrateOAuthAccounts(auth0User, createdUser.id, ctx)
                console.log(`Successfully migrated user: ${auth0User.email}`);
            } catch (error) {
                console.error(`Failed to migrate user ${auth0User.email}:`, error);
            }
        }
        if (isOrganizationEnabled) {
            await migrateOrganizations(ctx);
        }
        // the reset of migration will be here.
        console.log('Migration completed successfully');
    } catch (error) {
        console.error('Migration failed:', error);
        throw error;
    }
}

migrateFromAuth0()
    .then(() => {
        console.log('Migration completed');
        process.exit(0);
    })
    .catch((error) => {
        console.error('Migration failed:', error);
        process.exit(1);
    }); 
```

Make sure to replace the Auth0 environment variables with your own values:
- `AUTH0_DOMAIN`
- `AUTH0_CLIENT_ID`
- `AUTH0_SECRET`
</Step>

<Step>
### Run the migration

Run the migration script:

```sh
bun run scripts/migrate-auth0.ts # or use your preferred runtime
```

<Callout type="warning">
Important considerations:
1. Test the migration in a development environment first
2. Monitor the migration process for any errors
3. Verify the migrated data in Better Auth before proceeding
4. Keep Auth0 installed and configured until the migration is complete
5. The script handles bcrypt password hashes by default. For custom password hashing algorithms, you'll need to modify the `migratePassword` function
</Callout>

</Step>

<Step>
 ### Change password hashing algorithm

 By default, Better Auth uses the `scrypt` algorithm to hash passwords. Since Auth0 uses `bcrypt`, you'll need to configure Better Auth to use bcrypt for password verification.

 First, install bcrypt:

 ```bash
 npm install bcrypt
 npm install -D @types/bcrypt
 ```

 Then update your auth configuration:

 ```ts title="auth.ts"
 import { betterAuth } from "better-auth";
 import bcrypt from "bcrypt";
 
 export const auth = betterAuth({
    emailAndPassword: {
        password: {
            hash: async (password) => {
                return await bcrypt.hash(password, 10);
            },
            verify: async ({ hash, password }) => {
                return await bcrypt.compare(password, hash);
            }
        }
    }
 })
 ```
</Step>
<Step>
### Verify the migration

After running the migration, verify that:
1. All users have been properly migrated
2. Social connections are working
3. Password-based authentication is working
4. Two-factor authentication settings are preserved (if enabled)
5. User roles and permissions are correctly mapped
</Step>
<Step>
### Update your components

Now that the data is migrated, update your components to use Better Auth. Here's an example for the sign-in component:

```tsx title="components/auth/sign-in.tsx"
import { authClient } from "better-auth/client";

export const SignIn = () => {
  const handleSignIn = async () => {
    const { data, error } = await authClient.signIn.email({
      email: "helloworld@gmail.com",
      password: "helloworld",
    });
    
    if (error) {
      console.error(error);
      return;
    }
    // Handle successful sign in
  };

  return (
    <form onSubmit={handleSignIn}>
      <button type="submit">Sign in</button>
    </form>
  );
};
```
</Step>
<Step>
### Update the middleware

Replace your Auth0 middleware with Better Auth's middleware:

```ts title="middleware.ts"
import { NextRequest, NextResponse } from "next/server";
import { getSessionCookie } from "better-auth/cookies";

export async function middleware(request: NextRequest) {
  const sessionCookie = getSessionCookie(request);
  const { pathname } = request.nextUrl;

  if (sessionCookie && ["/login", "/signup"].includes(pathname)) {
    return NextResponse.redirect(new URL("/dashboard", request.url));
  }

  if (!sessionCookie && pathname.startsWith("/dashboard")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/dashboard", "/login", "/signup"],
};
```
</Step>
<Step>
### Remove Auth0 Dependencies

Once you've verified everything is working correctly with Better Auth, remove Auth0:

```bash
npm remove @auth0/auth0-react @auth0/auth0-spa-js @auth0/nextjs-auth0
```
</Step>
</Steps>

## Additional Considerations

### Password Migration
The migration script handles bcrypt password hashes by default. If you're using custom password hashing algorithms in Auth0, you'll need to modify the `migratePassword` function in the migration script to handle your specific case.

### Role Mapping
The script includes a basic role mapping function (`mapAuth0RoleToBetterAuthRole`). Customize this function based on your Auth0 roles and Better Auth role requirements.

### Rate Limiting
The migration script includes pagination to handle large numbers of users. Adjust the `perPage` value based on your needs and Auth0's rate limits.

## Wrapping Up

Now! You've successfully migrated from Auth0 to Better Auth.

Better Auth offers greater flexibility and more features—be sure to explore the [documentation](/docs) to unlock its full potential. ---
title: Migrating from Auth.js to Better Auth
description: A step-by-step guide to transitioning from Auth.js to Better Auth.
---

## Introduction

In this guide, we'll walk through the steps to migrate a project from [Auth.js](https://authjs.dev/) (formerly [NextAuth.js](https://next-auth.js.org/)) to Better Auth. Since these projects have different design philosophies, the migration requires careful planning and work. If your current setup is working well, there's no urgent need to migrate. We continue to handle security patches and critical issues for Auth.js.

However, if you're starting a new project or facing challenges with your current setup, we strongly recommend using Better Auth. Our roadmap includes features previously exclusive to Auth.js, and we hope this will unite the ecosystem more strongly without causing fragmentation.

<Steps>
<Step>
## Create Better Auth Instance

Before starting the migration process, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started.

For example, if you use the GitHub OAuth provider, here is a comparison of the `auth.ts` file.

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
  
export const { handlers, signIn, signOut, auth } = NextAuth({
  providers: [GitHub],
})
```
</Tab>

<Tab value="Better Auth">
```ts
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  socialProviders: { 
    github: { 
      clientId: process.env.GITHUB_CLIENT_ID!, 
      clientSecret: process.env.GITHUB_CLIENT_SECRET!, 
    }, 
  }, 
})
```
</Tab>
</Tabs>

<Callout type="info">
Now Better Auth supports stateless session management without any database. If you were using a Database adapter in Auth.js, you can refer to the [Database models](#database-models) below to check the differences with Better Auth's core schema.
</Callout>
</Step>

<Step>
## Create Client Instance

This client instance includes a set of functions for interacting with the Better Auth server instance. For more information, see [here](/docs/concepts/client).

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/react"

export const authClient = createAuthClient()
```
</Step>

<Step>
## Update the Route Handler

Rename the `/app/api/auth/[...nextauth]` folder to `/app/api/auth/[...all]` to avoid confusion. Then, update the `route.ts` file as follows:

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
import { handlers } from "@/lib/auth"

export const { GET, POST } = handlers
```
</Tab>

<Tab value="Better Auth">
```ts
import { auth } from "@/lib/auth";
import { toNextJsHandler } from "better-auth/next-js";

export const { POST, GET } = toNextJsHandler(auth)
```
</Tab>
</Tabs>
</Step>

<Step>
## Session Management

In this section, we'll look at how to manage sessions in Better Auth compared to Auth.js. For more information, see [here](/docs/concepts/session-management).

### Client-side

#### Sign In

Here are the differences between Auth.js and Better Auth for signing in users. For example, with the GitHub OAuth provider:

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
"use client"

import { signIn } from "next-auth/react"

signIn("github")
```
</Tab>

<Tab value="Better Auth">
```ts
"use client"

import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.signIn.social({
  provider: "github",
})
```
</Tab>
</Tabs>

#### Sign Out

Here are the differences between Auth.js and Better Auth when signing out users.

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
"use client"

import { signOut } from "next-auth/react"

signOut()
```
</Tab>

<Tab value="Better Auth">
```ts
"use client"

import { authClient } from "@/lib/auth-client";

const { data, error } = await authClient.signOut()
```
</Tab>
</Tabs>

#### Get Session

Here are the differences between Auth.js and Better Auth for getting the current active session.

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
"use client"

import { useSession } from "next-auth/react"

const { data, status, update } = useSession()
```
</Tab>

<Tab value="Better Auth">
```ts
"use client"

import { authClient } from "@/lib/auth-client";

const { data, error, refetch, isPending, isRefetching } = authClient.useSession()
```
</Tab>
</Tabs>

### Server-side

#### Sign In

Here are the differences between Auth.js and Better Auth for signing in users. For example, with the GitHub OAuth provider:

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
import { signIn } from "@/lib/auth"

await signIn("github")
```
</Tab>

<Tab value="Better Auth">
```ts
import { auth } from "@/lib/auth";

const { redirect, url } = await auth.api.signInSocial({
  body: {
    provider: "github",
  },
})
```
</Tab>
</Tabs>

#### Sign Out

Here are the differences between Auth.js and Better Auth when signing out users.

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
import { signOut } from "@/lib/auth"

await signOut()
```
</Tab>

<Tab value="Better Auth">
```ts
import { auth } from "@/lib/auth";
import { headers } from "next/headers";

const { success } = await auth.api.signOut({
  headers: await headers(),
})
```
</Tab>
</Tabs>

#### Get Session

Here are the differences between Auth.js and Better Auth for getting the current active session.

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
```ts 
import { auth } from "@/lib/auth";

const session = await auth()
```
</Tab>

<Tab value="Better Auth">
```ts
import { auth } from "@/lib/auth";
import { headers } from "next/headers";

const session = await auth.api.getSession({
  headers: await headers(),
})
```
</Tab>
</Tabs>
</Step>

<Step>
## Protecting Resources

> Proxy(Middleware) is not intended for slow data fetching. While Proxy can be helpful for optimistic checks such as permission-based redirects, it should not be used as a full session management or authorization solution. - [Next.js docs](https://nextjs.org/docs/app/getting-started/proxy#use-cases)

Auth.js offers approaches using Proxy (Middleware), but we recommend handling auth checks on each page or route rather than in a Proxy or Layout. Here is a basic example of protecting resources with Better Auth.

<Tabs items={["Client-side", "Server-side"]}>
<Tab value="Client-side">
```ts title="app/dashboard/page.tsx"
"use client";

import { authClient } from "@/lib/auth-client";
import { redirect } from "next/navigation";

const DashboardPage = () => {
  const { data, error, isPending } = authClient.useSession();

  if (isPending) {
    return <div>Pending</div>;
  }
  if (!data || error) {
    redirect("/sign-in");
  }

  return (
    <div>
      <h1>Welcome {data.user.name}</h1>
    </div>
  );
};

export default DashboardPage;
```
</Tab>

<Tab value="Server-side">
```ts title="app/dashboard/page.tsx"
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { redirect } from "next/navigation";

const DashboardPage = async () => {
  const session = await auth.api.getSession({
    headers: await headers(),
  });

  if (!session) {
    redirect("/sign-in");
  }

  return (
    <div>
      <h1>Welcome {session.user.name}</h1>
    </div>
  );
};

export default DashboardPage;

```
</Tab>
</Tabs>
</Step>

<Step>
## Database models

Both Auth.js and Better Auth provide stateless (JWT) and database session strategies. If you were using the database session strategy in Auth.js and plan to continue using it in Better Auth, you will also need to migrate your database.

Just like Auth.js has database models, Better Auth also has a core schema. In this section, we'll compare the two and explore the differences between them.

### User -> User

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each user",
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "User's chosen display name",
      isOptional: true,
    },
    {
      name: "email",
      type: "string",
      description: "User's email address for communication and login",
      isOptional: true,
    },
    {
      name: "emailVerified",
      type: "Date",
      description: "When the user's email was verified",
      isOptional: true,
    },
    {
      name: "image",
      type: "string",
      description: "User's image url",
      isOptional: true,
    },
  ]}
/>
</Tab>
<Tab value="Better Auth">
<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each user",
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "User's chosen display name",
    },
    {
      name: "email",
      type: "string",
      description: "User's email address for communication and login",
    },
    {
      name: "emailVerified",
      type: "boolean",
      description: "Whether the user's email is verified",
    },
    {
      name: "image",
      type: "string",
      description: "User's image url",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the user account was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of the last update to the user's information",
    },
  ]}
/>
</Tab>
</Tabs>

### Session -> Session

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each session",
      isPrimaryKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "sessionToken",
      type: "string",
      description: "The unique session token",
    },
    {
      name: "expires",
      type: "Date",
      description: "The time when the session expires",
    },
  ]}
/>
</Tab>
<Tab value="Better Auth">
<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each session",
      isPrimaryKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "token",
      type: "string",
      description: "The unique session token",
      isUnique: true,
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "The time when the session expires",
    },
    {
      name: "ipAddress",
      type: "string",
      description: "The IP address of the device",
      isOptional: true,
    },
    {
      name: "userAgent",
      type: "string",
      description: "The user agent information of the device",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the session was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the session was updated",
    },
  ]}
/>
</Tab>
</Tabs>

### Account -> Account

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each account",
      isPrimaryKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "type",
      type: "string",
      description: "Type of the account (e.g. 'oauth', 'email', 'credentials')",
    },
    {
      name: "provider",
      type: "string",
      description: "Provider identifier",
    },
    {
      name: "providerAccountId",
      type: "string",
      description: "Account ID from the provider",
    },
    {
      name: "refresh_token",
      type: "string",
      description: "The refresh token of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "access_token",
      type: "string",
      description: "The access token of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "expires_at",
      type: "number",
      description: "The time when the access token expires",
      isOptional: true,
    },
    {
      name: "token_type",
      type: "string",
      description: "Type of the token",
      isOptional: true,
    },
    {
      name: "scope",
      type: "string",
      description: "The scope of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "id_token",
      type: "string",
      description: "The ID token returned from the provider",
      isOptional: true,
    },
    {
      name: "session_state",
      type: "string",
      description: "OAuth session state",
      isOptional: true,
    },
  ]}
/>
</Tab>
<Tab value="Better Auth">
<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each account",
      isPrimaryKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "accountId",
      type: "string",
      description:
        "The ID of the account as provided by the SSO or equal to userId for credential accounts",
    },
    {
      name: "providerId",
      type: "string",
      description: "The ID of the provider",
    },
    {
      name: "accessToken",
      type: "string",
      description: "The access token of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "refreshToken",
      type: "string",
      description: "The refresh token of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "accessTokenExpiresAt",
      type: "Date",
      description: "The time when the access token expires",
      isOptional: true,
    },
    {
      name: "refreshTokenExpiresAt",
      type: "Date",
      description: "The time when the refresh token expires",
      isOptional: true,
    },
    {
      name: "scope",
      type: "string",
      description: "The scope of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "idToken",
      type: "string",
      description: "The ID token returned from the provider",
      isOptional: true,
    },
    {
      name: "password",
      type: "string",
      description:
        "The password of the account. Mainly used for email and password authentication",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the account was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the account was updated",
    },
  ]}
/>
</Tab>
</Tabs>

### VerificationToken -> Verification

<Tabs items={["Auth.js", "Better Auth"]}>
<Tab value="Auth.js">
<DatabaseTable
  fields={[
    {
      name: "identifier",
      type: "string",
      description: "Identifier for the verification request",
      isPrimaryKey: true,
    },
    {
      name: "token",
      type: "string",
      description: "The verification token",
      isPrimaryKey: true,
    },
    {
      name: "expires",
      type: "Date",
      description: "The time when the verification token expires",
    },
  ]}
/>
</Tab>
<Tab value="Better Auth">
<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each verification",
      isPrimaryKey: true,
    },
    {
      name: "identifier",
      type: "string",
      description: "The identifier for the verification request",
    },
    {
      name: "value",
      type: "string",
      description: "The value to be verified",
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "The time when the verification request expires",
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the verification request was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the verification request was updated",
    },
  ]}
/>
</Tab>
</Tabs>

### Comparison

Table: <strong className='underline italic'>User</strong>
- `name`, `email`, and `emailVerified` are required in Better Auth, while optional in Auth.js
- `emailVerified` uses a boolean in Better Auth, while Auth.js uses a timestamp
- Better Auth includes `createdAt` and `updatedAt` timestamps

Table: <strong className='underline italic'>Session</strong>
- Better Auth uses `token` instead of `sessionToken`
- Better Auth uses `expiresAt` instead of `expires`
- Better Auth includes `ipAddress` and `userAgent` fields
- Better Auth includes `createdAt` and `updatedAt` timestamps

Table: <strong className='underline italic'>Account</strong>
- Better Auth uses camelCase naming (e.g. `refreshToken` vs `refresh_token`)
- Better Auth includes `accountId` to distinguish between the account ID and internal ID
- Better Auth uses `providerId` instead of `provider`
- Better Auth includes `accessTokenExpiresAt` and `refreshTokenExpiresAt` for token management
- Better Auth includes `password` field to support built-in credential authentication
- Better Auth does not have a `type` field as it's determined by the `providerId`
- Better Auth removes `token_type` and `session_state` fields
- Better Auth includes `createdAt` and `updatedAt` timestamps

Table: <strong className='underline italic'>VerificationToken -> Verification</strong>
- Better Auth uses `Verification` table instead of `VerificationToken`
- Better Auth uses a single `id` primary key instead of composite primary key
- Better Auth uses `value` instead of `token` to support various verification types
- Better Auth uses `expiresAt` instead of `expires`
- Better Auth includes `createdAt` and `updatedAt` timestamps

<Callout type="info">
If you were using Auth.js v4, note that v5 does not introduce any breaking changes to the database schema. Optional fields like `oauth_token_secret` and `oauth_token` can be removed if you are not using them. Rarely used fields like `refresh_token_expires_in` can also be removed.
</Callout>

### Customization

You may have extended the database models or implemented additional logic in Auth.js. Better Auth allows you to customize the core schema in a type-safe way. You can also define custom logic during the lifecycle of database operations. For more details, see [Concepts - Database](/docs/concepts/database). 
</Step>
</Steps>

## Wrapping Up

Now you're ready to migrate from Auth.js to Better Auth. For a complete implementation with multiple authentication methods, check out the [Next.js Demo App](https://github.com/better-auth/better-auth/tree/canary/demo/nextjs). Better Auth offers greater flexibility and more features, so be sure to explore the [documentation](/docs) to unlock its full potential.

If you need help with migration, join our [community](/community) or reach out to [contact@better-auth.com](mailto:contact@better-auth.com).---
title: Migrating from WorkOS to Better Auth
description: A step-by-step guide to transitioning from WorkOS to Better Auth.
---

In this guide, we’ll walk through how to migrate a project from WorkOS to Better Auth, covering how to move a basic WorkOS setup integrated with a Next.js app and the key considerations to keep in mind.

## Before we begin

Before getting started, let’s review which WorkOS authentication features are fully or partially supported in Better Auth. If a feature you use in WorkOS is available via a plugin, you’ll need to configure it in the next step.

<Accordions type="multiple">
<Accordion title="🟢 Supported">
<>
| from WorkOS | to Better Auth |
|---------|-------------|
| Single Sign-On | Use the [SSO Plugin](/docs/plugins/sso). |
| Email + Password | Built-in support. |
| Passkeys | Use the [Passkey Plugin](/docs/plugins/passkey). |
| Social Login | Built-in support with even more providers. |
| Multi-Factor Auth | Use the [Two Factor Plugin](/docs/plugins/2fa). |
| Magic Auth | Use the [Magic Link Plugin](/docs/plugins/magic-link). |
| CLI Auth | Use the [Device Authorization Plugin](/docs/plugins/device-authorization). |
| API Keys | Use the [API Key Plugin](/docs/plugins/api-key). |
| Custom Emails | Fully customizable. |
| Directory Provisioning | Use the [SCIM Plugin](/docs/plugins/scim). |
| Domain Verification | Use the [SSO Plugin](/docs/plugins/sso). |
| Email Verification | Built-in support. |
| Identity Linking | Built-in support. |
| Impersonation | Use the [Admin Plugin](/docs/plugins/admin). |
| JWT Templates | Use the [JWT Plugin](/docs/plugins/jwt). |
| Metadata External IDs | Can be freely added by [extending the core schema](/docs/concepts/database#extending-core-schema). |
| Roles and Permissions | Use the [Organization Plugin](/docs/plugins/organization). |
</>
</Accordion>

<Accordion title="🟡 Partially supported">
<>
| from WorkOS | to Better Auth |
|---------|-------------|
| JIT Provisioning | Partially supported via the [SSO Plugin](/docs/plugins/sso). |
| Invitations | No ready-to-use dashboard is provided, but can be implemented using the [Admin Plugin](/docs/plugins/admin) + [Organization Plugin](/docs/plugins/organization). |
| Organization Policies | Partially supported, but can be fully implemented using [SSO Plugin](/docs/plugins/sso) + [Organization Plugin](/docs/plugins/organization) hooks. |
</>
</Accordion>
</Accordions>

<Steps>
<Step>
## Create Better Auth Instance

First, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started.

### Database

Better Auth supports various databases. Set up your preferred database. In this guide, we’ll use PostgreSQL with the default database adapter.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { Pool } from "pg";

export const auth = betterAuth({
  database: new Pool({ // [!code highlight]
    connectionString: process.env.DATABASE_URL, // [!code highlight]
  }), // [!code highlight]
});
```

### Email & Password

Enable Email & Password authentication as shown below. Since WorkOS verifies each user’s email by default, this setup is similar to the default behavior. You can adjust it if needed. For more information, see [here](/docs/authentication/email-password).

```ts
import { betterAuth } from "better-auth";
import { Pool } from "pg";

export const auth = betterAuth({
  database: new Pool({
    connectionString: process.env.DATABASE_URL,
  }),
  emailAndPassword: { // [!code highlight]
    enabled: true, // [!code highlight]
    requireEmailVerification: true, // [!code highlight]
    minPasswordLength: 10, // [!code highlight]
    sendResetPassword: async ({ user, url, token }, request) => { // [!code highlight]
      // Implement your email sending logic // [!code highlight]
    }, // [!code highlight]
  }, // [!code highlight]
  emailVerification: { // [!code highlight]
    sendVerificationEmail: async ({ user, url, token }, request) => { // [!code highlight]
      // Implement your email sending logic // [!code highlight]
    }, // [!code highlight]
  }, // [!code highlight]
});
```

### Social Providers (optional)

Set up the social providers you used in WorkOS as follows. Better Auth supports a wider range of providers, so you can add more if needed. Since WorkOS ensures emails are unique, configure `account.accountLinking` in Better Auth to ensure the same behavior.

```ts
import { betterAuth } from "better-auth";
import { Pool } from "pg";

export const auth = betterAuth({
  // ... other options

  socialProviders: { // [!code highlight]
    github: { // [!code highlight]
      clientId: process.env.GITHUB_CLIENT_ID!, // [!code highlight]
      clientSecret: process.env.GITHUB_CLIENT_SECRET!, // [!code highlight]
    }, // [!code highlight]
    // ... other providers // [!code highlight]
  }, // [!code highlight]
  account: { // [!code highlight]
    accountLinking: { // [!code highlight]
      enabled: true, // [!code highlight]
      trustedProviders: ["email-password", "github"], // [!code highlight]
    }, // [!code highlight]
  }, // [!code highlight]
});
```

### Additional Fields

{/* cspell:disable-next-line */}
You probably used metadata in WorkOS. To preserve that metadata and the user id from WorkOS (e.g., user_01KBT4BMFF7ASGRDD0WZ6W63FF), extend the `user` schema as shown below. Better Auth provides a more flexible way to store user data. For more information, see [here](/docs/concepts/database#extending-core-schema).

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { Pool } from "pg";

export const auth = betterAuth({
  // ... other options
  
  user: { // [!code highlight]
    additionalFields: { // [!code highlight]
      metadata: { // [!code highlight]
        type: "json", // [!code highlight]
        required: false, // [!code highlight]
        defaultValue: null, // [!code highlight]
      }, // [!code highlight]
    }, // [!code highlight]
  }, // [!code highlight]
});
```

### Plugins

Refer to the [section](#before-we-begin) mapping WorkOS features to Better Auth. If a feature you used in WorkOS is available as a Better Auth plugin, add it to the plugin options. Better Auth provides a wider range of out-of-the-box features through plugins. For more information, see [here](/docs/concepts/plugins).

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { haveIBeenPwned } from "better-auth/plugins/haveibeenpwned";
import { Pool } from "pg";

export const auth = betterAuth({
  // ... other options
  
  plugins: [ // [!code highlight]
    haveIBeenPwned() // [!code highlight]
    // ... other plugins // [!code highlight]
  ], // [!code highlight]
});
```

<Callout type="info">
If you rely on advanced WorkOS features beyond basic email+password and social login, refer to the feature mapping above to configure the appropriate plugins.
</Callout>
</Step>

<Step>
## Generate Schema

Better Auth allows you to control your own database, and you can easily generate the appropriate schema for your auth instance using the CLI. For more information, see [here](/docs/concepts/cli).

### Default database adapter

Run the `migrate` command to create the schema for your Better Auth instance in the database.

```package-install
npx auth migrate
```

### Other database adapters

If you’re using a database adapter like Prisma or Drizzle, use the `generate` command to create the schema for your ORM. After that, run the migration with an external tool such as Drizzle Kit.

```package-install
npx auth generate
```
</Step>

<Step>
## Migration Script

### Create Migration Script

Create a migration script to import your user data from WorkOS into your database.

```ts title="scripts/migration.ts"
import { auth } from "@/lib/auth"; // Your auth instance path
import { WorkOS } from "@workos-inc/node";

//==============================================================================

/*
  Rate limiting configuration

  WorkOS Read APIs: 1,000 requests per 10 seconds
  Default setting: Use 80% of limit to avoid edge cases

  Reference: https://workos.com/docs/reference/rate-limits
*/
const TIME_WINDOW_MS = 10 * 1000; // Time window in ms (10 seconds)
const MAX_REQUESTS_PER_WINDOW = 800; // Maximum API calls per time window
const USERS_PER_REQUEST = 100; // How many users to fetch per API call

//==============================================================================

if (!process.env.WORKOS_API_KEY || !process.env.WORKOS_CLIENT_ID) {
  throw new Error(
    "Missing required environment variables WORKOS_API_KEY and/or WORKOS_CLIENT_ID",
  );
}
const workos = new WorkOS(process.env.WORKOS_API_KEY);

/**
 * Create a rate limiter to track and control request rate
 */
const createRateLimiter = (maxRequests: number, windowMs: number) => {
  let requestTimestamps: number[] = [];

  const waitIfNeeded = async (): Promise<void> => {
    const now = Date.now();

    // Remove timestamps outside the current window
    requestTimestamps = requestTimestamps.filter(
      (timestamp) => now - timestamp < windowMs,
    );

    // If we've hit the limit, calculate wait time
    if (requestTimestamps.length >= maxRequests) {
      const oldestTimestamp = requestTimestamps[0]!;
      const waitTime = windowMs - (now - oldestTimestamp) + 1000; // 1 sec buffer

      console.log(
        `⏳ Throttling (${requestTimestamps.length}/${maxRequests} calls used). Waiting ${Math.ceil(waitTime / 1000)}s...`,
      );
      await new Promise((resolve) => setTimeout(resolve, waitTime));

      // Clean up old timestamps after waiting
      const newNow = Date.now();
      requestTimestamps = requestTimestamps.filter(
        (timestamp) => newNow - timestamp < windowMs,
      );
    }

    // Record this request
    requestTimestamps.push(Date.now());
  };

  const getStats = (): {
    current: number;
    max: number;
    windowMinutes: number;
  } => {
    const now = Date.now();
    requestTimestamps = requestTimestamps.filter(
      (timestamp) => now - timestamp < windowMs,
    );

    return {
      current: requestTimestamps.length,
      max: maxRequests,
      windowMinutes: windowMs / (60 * 1000),
    };
  };

  return { waitIfNeeded, getStats };
};

/**
 * Safely converts various date formats to Date object.
 * Returns current date if conversion fails (safe for createdAt/updatedAt).
 */
const safeDateConversion = (date?: string | number | Date | null): Date => {
  if (date == null) return new Date();

  if (date instanceof Date) return new Date(date.getTime());

  if (typeof date === "number") {
    if (!Number.isFinite(date)) return new Date();
    return new Date(date);
  }

  if (typeof date === "string") {
    const trimmed = date.trim();
    if (trimmed === "") return new Date();
    const parsed = new Date(trimmed);
    if (isNaN(parsed.getTime())) return new Date();
    return parsed;
  }

  return new Date();
};

/**
 * Safely converts firstName and lastName to a full name string.
 * Returns "Username" if both names are empty.
 */
const safeNameConversion = (
  firstName?: string | null,
  lastName?: string | null,
): string => {
  const trimmedFirstName = firstName?.trim();
  const trimmedLastName = lastName?.trim();

  if (trimmedFirstName && trimmedLastName) {
    return `${trimmedFirstName} ${trimmedLastName}`;
  }

  if (trimmedFirstName) return trimmedFirstName;
  if (trimmedLastName) return trimmedLastName;

  return "Username";
};

async function migrateFromWorkOS() {
  const ctx = await auth.$context;
  const rateLimiter = createRateLimiter(
    MAX_REQUESTS_PER_WINDOW,
    TIME_WINDOW_MS,
  );

  let totalUsers = 0;
  let migratedUsers = 0;
  let skippedUsers = 0;
  let failedUsers = 0;

  let hasMoreUsers = true;
  let after: string | undefined;
  let batchCount = 0;

  console.log("");
  console.log("=".repeat(40));
  console.log("🚀 Starting migration");
  console.log("");
  console.log(`Settings:`);
  console.log(
    ` - Max API calls: ${MAX_REQUESTS_PER_WINDOW} per ${TIME_WINDOW_MS / 1000}s`,
  );
  console.log(` - Users per call: ${USERS_PER_REQUEST}`);
  console.log("=".repeat(40));
  console.log("");

  while (hasMoreUsers) {
    try {
      await rateLimiter.waitIfNeeded();

      const workosUserList = await workos.userManagement.listUsers({
        limit: USERS_PER_REQUEST,
        after,
      });

      batchCount++;
      console.log(
        `📦 Batch ${batchCount}: Fetched ${workosUserList.data.length} users from WorkOS`,
      );

      after = workosUserList.listMetadata.after || undefined;
      hasMoreUsers = !!after;
      totalUsers += workosUserList.data.length;

      for (const workosUser of workosUserList.data) {
        try {
          console.log(`\nProcessing user: ${workosUser.email}`);

          // Check if user already exists by email
          // WorkOS ensures all user emails are unique via an email verification process
          const existingUser = await ctx.adapter.findOne<
            typeof auth.$Infer.Session.user
          >({
            model: "user",
            where: [
              {
                field: "email",
                value: workosUser.email,
              },
            ],
          });

          if (existingUser) {
            console.log(
              `🟡 User already exists, skipping: ${workosUser.email}`,
            );
            skippedUsers++;
            continue;
          }

          // Create the user
          await ctx.adapter.create<typeof auth.$Infer.Session.user>({
            model: "user",
            data: {
              email: workosUser.email,
              emailVerified: workosUser.emailVerified,
              image: workosUser.profilePictureUrl,
              name: safeNameConversion(
                workosUser.firstName,
                workosUser.lastName,
              ),
              createdAt: safeDateConversion(workosUser.createdAt),
              updatedAt: safeDateConversion(workosUser.updatedAt),
              metadata: {
                workosId: workosUser.id,
                ...(workosUser.metadata || {}),
              },
            },
          });

          console.log(`🟢 Migrated user ${workosUser.email}`);
          migratedUsers++;
        } catch (error) {
          console.error(
            `🔴 Failed to migrate user ${workosUser.email}\n`,
            error,
          );
          failedUsers++;
        }
      }

      console.log("");
    } catch (error) {
      console.error("🚨 Error fetching batch:", error);
      throw error;
    }
  }

  console.log("");
  console.log("=".repeat(40));
  console.log("📝 Migration Summary");
  console.log(`Total users processed: ${totalUsers}`);
  console.log("");
  console.log(`🔴 Failed: ${failedUsers}`);
  console.log(`🟡 Skipped: ${skippedUsers}`);
  console.log(`🟢 Successfully migrated: ${migratedUsers}`);
  console.log("=".repeat(40));
}

async function main() {
  try {
    await migrateFromWorkOS();
    process.exit(0);
  } catch (error) {
    console.error("\nMigration failed:", error);
    process.exit(1);
  }
}
main();
```

<Callout type="info">
**Notes**

- When retrieving user data from WorkOS, you need to use their API, which is subject to rate limits. The example script includes a basic configuration, so adjust it as needed for your environment.
- This migration script covers the common cases of managing users with email+password and social login. For features like SSO or CLI Auth, which are provided as plugins in Better Auth, be sure to update the script based on the examples.
</Callout>


### Run Migration Script

```bash title="Terminal"
bun scripts/migration.ts # or use node, ts-node, etc.
```

🎉 Now that you’ve migrated your user data into your database, let’s look at how to update your application logic.
</Step>
<Step>
## Create Client Instance

This client instance includes a set of functions for interacting with the Better Auth server instance. For more information, see [here](/docs/concepts/client).

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/react";

export const authClient = createAuthClient({
    plugins: [
        // Add plugins that require a client, if needed
    ]
});
```
</Step>

<Step>
## Create API Route

In WorkOS, the auth API was provided as a managed service. With Better Auth, the auth API now lives directly within your application.

```ts title="/app/api/auth/[...all]/route.ts"
import { auth } from "@/lib/auth";
import { toNextJsHandler } from "better-auth/next-js";

export const { POST, GET } = toNextJsHandler(auth)
```
</Step>

<Step>
## Sign-in/Sign-up Page

In WorkOS, you probably fetched and used the URL like this.

```ts
const signInUrl = await getSignInUrl();
const signUpUrl = await getSignUpUrl();
```

In Better Auth, instead of fetching these values via an API, you can create the pages at your desired paths and use them directly.
</Step>

<Step>
## Protecting Resources

> Proxy (Middleware) is not intended for slow data fetching. While Proxy can be helpful for optimistic checks such as permission-based redirects, it should not be used as a full session management or authorization solution. - [Next.js docs](https://nextjs.org/docs/app/getting-started/proxy#use-cases)

### Middleware auth

WorkOS provides Proxy (Middleware) authentication. Better Auth doesn’t recommend protecting resources directly in middleware, so we don't provide dedicated helpers for that.

```ts title="proxy.ts / middleware.ts"
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

export default authkitMiddleware({
  middlewareAuth: {
    enabled: true,
    unauthenticatedPaths: ['/'],
  },
});

export const config = { matcher: ['/', '/account/:page*'] };
```

In Better Auth, for convenience rather than resource protection, the proxy (middleware) can be used as follows. This is supported in Next.js 15+ with the Node.js runtime.

```ts title="proxy.ts"
import { NextRequest, NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

export async function proxy(request: NextRequest) {
    const session = await auth.api.getSession({
        headers: await headers()
    })

    // This is the recommended approach to optimistically redirect users
    // We recommend handling auth checks in each page/route
    if(!session) {
        return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    return NextResponse.next();
}

export const config = {
  matcher: ["/dashboard"], // Specify the routes the middleware applies to
};
```

### Page based auth

In WorkOS, if resources were protected on each page, you can update the logic in Better Auth as follows.

#### Server-side

<Tabs items={["WorkOS", "Better Auth"]}>
<Tab value="WorkOS">
```ts title="app/dashboard/page.tsx"
import { withAuth } from "@workos-inc/authkit-nextjs";

export default async function DashboardPage() {
  const { user } = await withAuth({ ensureSignedIn: true });

  return (
    <div>
      <p>Welcome {user.firstName && `, ${user.lastName}`}</p>
    </div>
  );
}
```
</Tab>

<Tab value="Better Auth">
```ts title="app/dashboard/page.tsx"
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { redirect } from "next/navigation";

const DashboardPage = async () => {
  const session = await auth.api.getSession({
    headers: await headers(),
  });

  if (!session) {
    redirect("/sign-in");
  }

  return (
    <div>
      <p>Welcome {session.user.name}</p>
    </div>
  );
};

export default DashboardPage;
```
</Tab>
</Tabs>

#### Client-side

<Tabs items={["WorkOS", "Better Auth"]}>
<Tab value="WorkOS">
```ts title="app/dashboard/page.tsx"
"use client";

import { useAuth } from "@workos-inc/authkit-nextjs/components";

export default function HomePage() {
  const { user, loading } = useAuth({ ensureSignedIn: true });

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <p>Welcome {user.firstName && `, ${user.lastName}`}</p>
    </div>
  );
}

```
</Tab>

<Tab value="Better Auth">
```ts title="app/dashboard/page.tsx"
"use client";

import { authClient } from "@/lib/auth-client";
import { redirect } from "next/navigation";

const DashboardPage = () => {
  const { data, error, isPending } = authClient.useSession();

  if (isPending) {
    return <div>Pending...</div>;
  }
  if (!data || error) {
    redirect("/sign-in");
  }

  return (
    <div>
      <p>Welcome {data.user.name}</p>
    </div>
  );
};

export default DashboardPage;
```
</Tab>
</Tabs>

<Callout type="info">
If options like `ensureSignedIn` were convenient in WorkOS, you can create a reusable helper like `ensureSession()` in Better Auth.
</Callout>

</Step>

<Step>
## Remove WorkOS Dependencies

After verifying everything works, remove WorkOS dependencies:

```package-install
npm uninstall @workos-inc/node @workos-inc/authkit-nextjs
```

</Step>
</Steps>

## Considerations

<strong className='underline italic'>Password hashes</strong>

If you’ve been managing users with an email + password system, WorkOS does not provide an export of password hashes at this time. After migration, users will need to reset their passwords within your authentication system. Make sure to notify them of this change with sufficient lead time both before and after the migration.

<strong className='underline italic'>Data syncing</strong>

WorkOS is a managed service and keeps your data in sync with your server through APIs or Webhooks. With Better Auth, you fully own your authentication system and can manage data freely through the API. However, if you previously relied on Webhooks for synchronization, additional adjustments will be needed.

<strong className='underline italic'>Downtime</strong>

WorkOS exposes data through its API, but with limitations such as the inability to export password hashes. Because of these constraints, performing a migration with zero downtime is challenging. Plan the migration carefully, allow enough buffer time, and communicate the expected impact to your users.

<strong className='underline italic'>Active sessions</strong>

Existing active sessions will not be migrated. After the migration, users will need to sign in again, so be sure to notify them in advance.

## Wrapping Up

Congratulations! You've successfully migrated from WorkOS to Better Auth. Better Auth offers greater flexibility and more features, so be sure to explore the [documentation](/docs) to unlock its full potential.

If you need help with migration, join our [community](/community) or reach out for Enterprise support [here](/enterprise).---
title: Migrating from Supabase Auth to Better Auth
description: A step-by-step guide to transitioning from Supabase Auth to Better Auth.
---

In this guide, we'll walk through the steps to migrate a project from Supabase Auth to Better Auth. 

<Callout type="warn">
This migration will invalidate all active sessions. While this guide doesn't currently cover migrating two-factor (2FA) or Row Level Security (RLS) configurations, both should be possible with additional steps.
</Callout>

<Callout type="error">
**Back up your database before running any migration scripts.** This guide modifies production data. Create a full backup of both your Supabase database and target database before proceeding.
</Callout>


## Before You Begin

Before starting the migration process, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started.

<Steps>

<Step>
### Connect to your database

You'll need to connect to your database to migrate the users and accounts. Copy your `DATABASE_URL` from your Supabase project and use it to connect to your database. And for this example, we'll need to install `pg` to connect to the database.

```package-install
npm install pg
```
And then you can use the following code to connect to your database.

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { Pool } from "pg";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
})
```
</Step>

<Step>
### Enable Email and Password

Enable the email and password in your auth config.

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { Pool } from "pg";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { // [!code highlight]
        enabled: true, // [!code highlight]
    } // [!code highlight]
})
```

<Callout type="info">
If you want to require email verification, add the `emailVerification` config separately. See the [Email Verification docs](/docs/authentication/email-password#email-verification) for details.
</Callout>
</Step>

<Step>
### Setup Social Providers (Optional)

Add all the social providers used in Supabase to the auth config. Missing any may cause user data loss during migration.

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { Pool } from "pg";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
    },
    socialProviders: { // [!code highlight]
        github: { // [!code highlight]
            clientId: process.env.GITHUB_CLIENT_ID!, // [!code highlight]
            clientSecret: process.env.GITHUB_CLIENT_SECRET!, // [!code highlight]
        } // [!code highlight]
    } // [!code highlight]
})
```
</Step>

<Step>
### Add plugins based on your Supabase features

Add plugins that match the features you used in Supabase. Include only what you need:

- **[admin](/docs/plugins/admin)**: If you have users with `is_super_admin` or `banned_until` fields
- **[anonymous](/docs/plugins/anonymous)**: If you used anonymous authentication (`signInAnonymously`)
- **[phoneNumber](/docs/plugins/phone-number)**: If you have users who signed up with phone numbers

<Callout type="info">
Only include plugins for features you actually used in Supabase. The migration script will automatically detect which plugins are enabled and migrate data accordingly.
</Callout>

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { Pool } from "pg";
import { admin, anonymous, phoneNumber } from 'better-auth/plugins';

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
    },
    socialProviders: {
        github: {
            clientId: process.env.GITHUB_CLIENT_ID!,
            clientSecret: process.env.GITHUB_CLIENT_SECRET!,
        }
    },
    plugins: [admin(), anonymous(), phoneNumber()], // [!code highlight]
})
```
</Step>

<Step>
### Add the additional fields

To minimize data loss from Supabase Auth, the following additional fields are required. You can adjust them as needed after the migration is complete.

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { Pool } from "pg";
import { admin, anonymous, phoneNumber } from 'better-auth/plugins';

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
    },
    socialProviders: {
        github: {
            clientId: process.env.GITHUB_CLIENT_ID!,
            clientSecret: process.env.GITHUB_CLIENT_SECRET!,
        }
    },
    plugins: [admin(), anonymous(), phoneNumber()],
    user: { // [!code highlight]
        additionalFields: { // [!code highlight]
            userMetadata: { // [!code highlight]
                type: 'json', // [!code highlight]
                required: false, // [!code highlight]
                input: false, // [!code highlight]
            }, // [!code highlight]
            appMetadata: { // [!code highlight]
                type: 'json', // [!code highlight]
                required: false, // [!code highlight]
                input: false, // [!code highlight]
            }, // [!code highlight]
            invitedAt: { // [!code highlight]
                type: 'date', // [!code highlight]
                required: false, // [!code highlight]
                input: false, // [!code highlight]
            }, // [!code highlight]
            lastSignInAt: { // [!code highlight]
                type: 'date', // [!code highlight]
                required: false, // [!code highlight]
                input: false, // [!code highlight]
            }, // [!code highlight]
        }, // [!code highlight]
    }, // [!code highlight]
})
```
</Step>

<Step>
### Run the migration

Run the migration to create the necessary tables in your database.

```bash title="Terminal"
npx auth migrate
```

This will create the necessary tables in the `public` schema of your Better Auth instance.

Now that we have the necessary tables in our database, we can run the migration script to migrate the users and accounts from Supabase to Better Auth.

</Step>

<Step>
### Copy the migration script

First, set up the environment variables used by the script.

```dotenv title=".env"
FROM_DATABASE_URL= # Supabase database connection string (reads from auth.users)
TO_DATABASE_URL= # Target Postgres database connection string (writes to public.user)
```

<Callout type="info">
**Same database?** If you're migrating within the same Supabase Postgres database (from `auth` schema to `public` schema), both URLs can be the same `DATABASE_URL`. If you're migrating to a different database (e.g., PlanetScale, separate Postgres), use different URLs.
</Callout>

And then copy and paste the following code into the file.

```ts title="migration.ts"
import { generateId } from 'better-auth';
import { DBFieldAttribute } from 'better-auth/db';
import { Pool } from 'pg';
import { auth } from './auth'; // <- Your Better Auth Instance

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  /**
   * Number of users to process in each batch
   * Higher values = faster migration but more memory usage
   * Recommended: 5000-10000 for most cases
   */
  batchSize: 5000,
  /**
   * Resume from a specific user ID (cursor-based pagination)
   * Useful for resuming interrupted migrations
   * Set to null to start from the beginning
   */
  resumeFromId: null as string | null,
  /**
   * Temporary email domain for phone-only users
   * Phone-only users need an email for Better Auth
   * Format: {phone_number}@{tempEmailDomain}
   */
  tempEmailDomain: 'temp.better-auth.com',
};

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

type MigrationStatus = 'idle' | 'running' | 'paused' | 'completed' | 'failed';

type MigrationState = {
  status: MigrationStatus;
  totalUsers: number;
  processedUsers: number;
  successCount: number;
  failureCount: number;
  skipCount: number;
  currentBatch: number;
  totalBatches: number;
  startedAt: Date | null;
  completedAt: Date | null;
  lastProcessedId: string | null;
  errors: Array<{ userId: string; error: string }>;
};

type UserInsertData = {
  id: string;
  email: string | null;
  name: string;
  emailVerified: boolean;
  createdAt: string | null;
  updatedAt: string | null;
  image?: string;
  [key: string]: any;
};

type AccountInsertData = {
  id: string;
  userId: string;
  providerId: string;
  accountId: string;
  password: string | null;
  createdAt: string | null;
  updatedAt: string | null;
};

type SupabaseIdentityFromDB = {
  id: string;
  provider_id: string;
  user_id: string;
  identity_data: Record<string, any>;
  provider: string;
  last_sign_in_at: string | null;
  created_at: string | null;
  updated_at: string | null;
  email: string | null;
};

type SupabaseUserFromDB = {
  instance_id: string | null;
  id: string;
  aud: string | null;
  role: string | null;
  email: string | null;
  encrypted_password: string | null;
  email_confirmed_at: string | null;
  invited_at: string | null;
  confirmation_token: string | null;
  confirmation_sent_at: string | null;
  recovery_token: string | null;
  recovery_sent_at: string | null;
  email_change_token_new: string | null;
  email_change: string | null;
  email_change_sent_at: string | null;
  last_sign_in_at: string | null;
  raw_app_meta_data: Record<string, any> | null;
  raw_user_meta_data: Record<string, any> | null;
  is_super_admin: boolean | null;
  created_at: string | null;
  updated_at: string | null;
  phone: string | null;
  phone_confirmed_at: string | null;
  phone_change: string | null;
  phone_change_token: string | null;
  phone_change_sent_at: string | null;
  confirmed_at: string | null;
  email_change_token_current: string | null;
  email_change_confirm_status: number | null;
  banned_until: string | null;
  reauthentication_token: string | null;
  reauthentication_sent_at: string | null;
  is_sso_user: boolean;
  deleted_at: string | null;
  is_anonymous: boolean;
  identities: SupabaseIdentityFromDB[];
};

// ============================================================================
// MIGRATION STATE MANAGER
// ============================================================================

class MigrationStateManager {
  private state: MigrationState = {
    status: 'idle',
    totalUsers: 0,
    processedUsers: 0,
    successCount: 0,
    failureCount: 0,
    skipCount: 0,
    currentBatch: 0,
    totalBatches: 0,
    startedAt: null,
    completedAt: null,
    lastProcessedId: null,
    errors: [],
  };

  start(totalUsers: number, batchSize: number) {
    this.state = {
      status: 'running',
      totalUsers,
      processedUsers: 0,
      successCount: 0,
      failureCount: 0,
      skipCount: 0,
      currentBatch: 0,
      totalBatches: Math.ceil(totalUsers / batchSize),
      startedAt: new Date(),
      completedAt: null,
      lastProcessedId: null,
      errors: [],
    };
  }

  updateProgress(
    processed: number,
    success: number,
    failure: number,
    skip: number,
    lastId: string | null,
  ) {
    this.state.processedUsers += processed;
    this.state.successCount += success;
    this.state.failureCount += failure;
    this.state.skipCount += skip;
    this.state.currentBatch++;
    if (lastId) {
      this.state.lastProcessedId = lastId;
    }
  }

  addError(userId: string, error: string) {
    if (this.state.errors.length < 100) {
      this.state.errors.push({ userId, error });
    }
  }

  complete() {
    this.state.status = 'completed';
    this.state.completedAt = new Date();
  }

  fail() {
    this.state.status = 'failed';
    this.state.completedAt = new Date();
  }

  getState(): MigrationState {
    return { ...this.state };
  }

  getProgress(): number {
    if (this.state.totalUsers === 0) return 0;
    return Math.round((this.state.processedUsers / this.state.totalUsers) * 100);
  }

  getETA(): string | null {
    if (!this.state.startedAt || this.state.processedUsers === 0) {
      return null;
    }

    const elapsed = Date.now() - this.state.startedAt.getTime();
    const avgTimePerUser = elapsed / this.state.processedUsers;
    const remainingUsers = this.state.totalUsers - this.state.processedUsers;
    const remainingMs = avgTimePerUser * remainingUsers;

    const seconds = Math.floor(remainingMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
      return `${hours}h ${minutes % 60}m`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }
}

// ============================================================================
// DATABASE CONNECTIONS
// ============================================================================

const fromDB = new Pool({
  connectionString: process.env.FROM_DATABASE_URL,
});

const toDB = new Pool({
  connectionString: process.env.TO_DATABASE_URL,
});

// ============================================================================
// BETTER AUTH VALIDATION
// ============================================================================

/**
 * Validates that the imported Better Auth instance meets migration requirements
 */
async function validateAuthConfig() {
  const ctx = await auth.$context;
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check emailAndPassword (required)
  if (!ctx.options.emailAndPassword?.enabled) {
    errors.push('emailAndPassword.enabled must be true');
  }

  // Check optional plugins - warn if missing, migration will skip related data
  const optionalPlugins = ['admin', 'anonymous', 'phone-number'];
  const plugins = ctx.options.plugins || [];
  const pluginIds = plugins.map((p: any) => p.id);

  for (const plugin of optionalPlugins) {
    if (!pluginIds.includes(plugin)) {
      warnings.push(`Plugin '${plugin}' not found - related Supabase data will be skipped`);
    }
  }

  // Check required additional fields
  const additionalFields = ctx.options.user?.additionalFields || {};
  const requiredFields: Record<string, DBFieldAttribute> = {
    userMetadata: { type: 'json', required: false, input: false },
    appMetadata: { type: 'json', required: false, input: false },
    invitedAt: { type: 'date', required: false, input: false },
    lastSignInAt: { type: 'date', required: false, input: false },
  };

  for (const [fieldName, expectedConfig] of Object.entries(requiredFields)) {
    const fieldConfig = additionalFields[fieldName];

    if (!fieldConfig) {
      errors.push(`Missing required user.additionalFields: ${fieldName}`);
    } else {
      // Validate field configuration
      if (fieldConfig.type !== expectedConfig.type) {
        errors.push(
          `user.additionalFields.${fieldName} must have type: '${expectedConfig.type}' (got '${fieldConfig.type}')`,
        );
      }
      if (fieldConfig.required !== expectedConfig.required) {
        errors.push(
          `user.additionalFields.${fieldName} must have required: ${expectedConfig.required}`,
        );
      }
      if (fieldConfig.input !== expectedConfig.input) {
        errors.push(`user.additionalFields.${fieldName} must have input: ${expectedConfig.input}`);
      }
    }
  }

  // Show warnings (non-blocking)
  if (warnings.length > 0) {
    console.warn('\n⚠️  Migration Warnings:\n');
    warnings.forEach((warn) => console.warn(`   ${warn}`));
    console.warn('\n   Add plugins for features you used in Supabase to migrate that data.\n');
  }

  // Show errors (blocking)
  if (errors.length > 0) {
    console.error('\n🟧 Better Auth Configuration Errors:\n');
    errors.forEach((err) => console.error(`   ${err}`));
    console.error('\n🟧 Please update your Better Auth configuration to include:\n');
    console.error('   1. emailAndPassword: { enabled: true }');
    console.error(
      '   2. user.additionalFields: { userMetadata, appMetadata, invitedAt, lastSignInAt }\n',
    );
    process.exit(1);
  }

  return ctx;
}

// ============================================================================
// MIGRATION LOGIC
// ============================================================================

const stateManager = new MigrationStateManager();

let ctxCache: {
  hasAnonymousPlugin: boolean;
  hasAdminPlugin: boolean;
  hasPhoneNumberPlugin: boolean;
  supportedProviders: string[];
} | null = null;

async function processBatch(
  users: SupabaseUserFromDB[],
  ctx: any,
): Promise<{
  success: number;
  failure: number;
  skip: number;
  errors: Array<{ userId: string; error: string }>;
}> {
  const stats = {
    success: 0,
    failure: 0,
    skip: 0,
    errors: [] as Array<{ userId: string; error: string }>,
  };

  if (!ctxCache) {
    ctxCache = {
      hasAdminPlugin: ctx.options.plugins?.some((p: any) => p.id === 'admin') || false,
      hasAnonymousPlugin: ctx.options.plugins?.some((p: any) => p.id === 'anonymous') || false,
      hasPhoneNumberPlugin: ctx.options.plugins?.some((p: any) => p.id === 'phone-number') || false,
      supportedProviders: Object.keys(ctx.options.socialProviders || {}),
    };
  }

  const { hasAdminPlugin, hasAnonymousPlugin, hasPhoneNumberPlugin, supportedProviders } = ctxCache;

  const validUsersData: Array<{ user: SupabaseUserFromDB; userData: UserInsertData }> = [];

  for (const user of users) {
    if (!user.email && !user.phone) {
      stats.skip++;
      continue;
    }
    if (!user.email && !hasPhoneNumberPlugin) {
      stats.skip++;
      continue;
    }
    if (user.deleted_at) {
      stats.skip++;
      continue;
    }
    if (user.banned_until && !hasAdminPlugin) {
      stats.skip++;
      continue;
    }

    const getTempEmail = (phone: string) =>
      `${phone.replace(/[^0-9]/g, '')}@${CONFIG.tempEmailDomain}`;

    const getName = (): string => {
      if (user.raw_user_meta_data?.name) return user.raw_user_meta_data.name;
      if (user.raw_user_meta_data?.full_name) return user.raw_user_meta_data.full_name;
      if (user.raw_user_meta_data?.username) return user.raw_user_meta_data.username;
      if (user.raw_user_meta_data?.user_name) return user.raw_user_meta_data.user_name;

      const firstId = user.identities?.[0];
      if (firstId?.identity_data?.name) return firstId.identity_data.name;
      if (firstId?.identity_data?.full_name) return firstId.identity_data.full_name;
      if (firstId?.identity_data?.username) return firstId.identity_data.username;
      if (firstId?.identity_data?.preferred_username)
        return firstId.identity_data.preferred_username;

      if (user.email) return user.email.split('@')[0]!;
      if (user.phone) return user.phone;

      return 'Unknown';
    };

    const getImage = (): string | undefined => {
      if (user.raw_user_meta_data?.avatar_url) return user.raw_user_meta_data.avatar_url;
      if (user.raw_user_meta_data?.picture) return user.raw_user_meta_data.picture;
      const firstId = user.identities?.[0];
      if (firstId?.identity_data?.avatar_url) return firstId.identity_data.avatar_url;
      if (firstId?.identity_data?.picture) return firstId.identity_data.picture;
      return undefined;
    };

    const userData: UserInsertData = {
      id: user.id,
      email: user.email || (user.phone ? getTempEmail(user.phone) : null),
      emailVerified: !!user.email_confirmed_at,
      name: getName(),
      image: getImage(),
      createdAt: user.created_at,
      updatedAt: user.updated_at,
    };

    if (hasAnonymousPlugin) userData.isAnonymous = user.is_anonymous;
    if (hasPhoneNumberPlugin && user.phone) {
      userData.phoneNumber = user.phone;
      userData.phoneNumberVerified = !!user.phone_confirmed_at;
    }

    if (hasAdminPlugin) {
      userData.role = user.is_super_admin ? 'admin' : user.role || 'user';
      if (user.banned_until) {
        const banExpires = new Date(user.banned_until);
        if (banExpires > new Date()) {
          userData.banned = true;
          userData.banExpires = banExpires;
          userData.banReason = 'Migrated from Supabase (banned)';
        } else {
          userData.banned = false;
        }
      } else {
        userData.banned = false;
      }
    }

    if (user.raw_user_meta_data && Object.keys(user.raw_user_meta_data).length > 0) {
      userData.userMetadata = user.raw_user_meta_data;
    }
    if (user.raw_app_meta_data && Object.keys(user.raw_app_meta_data).length > 0) {
      userData.appMetadata = user.raw_app_meta_data;
    }
    if (user.invited_at) userData.invitedAt = user.invited_at;
    if (user.last_sign_in_at) userData.lastSignInAt = user.last_sign_in_at;

    validUsersData.push({ user, userData });
  }

  if (validUsersData.length === 0) {
    return stats;
  }

  try {
    await toDB.query('BEGIN');

    const allFields = new Set<string>();
    validUsersData.forEach(({ userData }) => {
      Object.keys(userData).forEach((key) => allFields.add(key));
    });
    const fields = Array.from(allFields);

    const maxParamsPerQuery = 65000;
    const fieldsPerUser = fields.length;
    const usersPerChunk = Math.floor(maxParamsPerQuery / fieldsPerUser);

    for (let i = 0; i < validUsersData.length; i += usersPerChunk) {
      const chunk = validUsersData.slice(i, i + usersPerChunk);

      const placeholders: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      for (const { userData } of chunk) {
        const userPlaceholders = fields.map((field) => {
          values.push(userData[field] ?? null);
          return `$${paramIndex++}`;
        });
        placeholders.push(`(${userPlaceholders.join(', ')})`);
      }

      await toDB.query(
        `
        INSERT INTO "user" (${fields.map((f) => `"${f}"`).join(', ')})
        VALUES ${placeholders.join(', ')}
        ON CONFLICT ("id") DO NOTHING
      `,
        values,
      );
    }

    const accountsData: AccountInsertData[] = [];

    for (const { user } of validUsersData) {
      for (const identity of user.identities ?? []) {
        if (identity.provider === 'email') {
          accountsData.push({
            id: generateId(),
            userId: user.id,
            providerId: 'credential',
            accountId: user.id,
            password: user.encrypted_password || null,
            createdAt: user.created_at,
            updatedAt: user.updated_at,
          });
        }

        if (supportedProviders.includes(identity.provider)) {
          accountsData.push({
            id: generateId(),
            userId: user.id,
            providerId: identity.provider,
            accountId: identity.identity_data?.sub || identity.provider_id,
            password: null,
            createdAt: identity.created_at ?? user.created_at,
            updatedAt: identity.updated_at ?? user.updated_at,
          });
        }
      }
    }

    if (accountsData.length > 0) {
      const maxParamsPerQuery = 65000;
      const fieldsPerAccount = 7;
      const accountsPerChunk = Math.floor(maxParamsPerQuery / fieldsPerAccount);

      for (let i = 0; i < accountsData.length; i += accountsPerChunk) {
        const chunk = accountsData.slice(i, i + accountsPerChunk);

        const accountPlaceholders: string[] = [];
        const accountValues: any[] = [];
        let paramIndex = 1;

        for (const acc of chunk) {
          accountPlaceholders.push(
            `($${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++})`,
          );
          accountValues.push(
            acc.id,
            acc.userId,
            acc.providerId,
            acc.accountId,
            acc.password,
            acc.createdAt,
            acc.updatedAt,
          );
        }

        await toDB.query(
          `
          INSERT INTO "account" ("id", "userId", "providerId", "accountId", "password", "createdAt", "updatedAt")
          VALUES ${accountPlaceholders.join(', ')}
          ON CONFLICT ("id") DO NOTHING
        `,
          accountValues,
        );
      }
    }

    await toDB.query('COMMIT');
    stats.success = validUsersData.length;
  } catch (error: any) {
    await toDB.query('ROLLBACK');
    console.error('[TRANSACTION] Batch failed, rolled back:', error.message);
    stats.failure = validUsersData.length;
    if (stats.errors.length < 100) {
      stats.errors.push({ userId: 'bulk', error: error.message });
    }
  }

  return stats;
}

async function migrateFromSupabase() {
  const { batchSize, resumeFromId } = CONFIG;

  console.log('[MIGRATION] Starting migration with config:', CONFIG);

  // Validate Better Auth configuration
  const ctx = await validateAuthConfig();

  try {
    const countResult = await fromDB.query<{ count: string }>(
      `
      SELECT COUNT(*) as count FROM auth.users
      ${resumeFromId ? 'WHERE id > $1' : ''}
    `,
      resumeFromId ? [resumeFromId] : [],
    );

    const totalUsers = parseInt(countResult.rows[0]?.count || '0', 10);

    console.log(`[MIGRATION] Starting migration for ${totalUsers.toLocaleString()} users`);
    console.log(`[MIGRATION] Batch size: ${batchSize}\n`);

    stateManager.start(totalUsers, batchSize);

    let lastProcessedId: string | null = resumeFromId;
    let hasMore = true;
    let batchNumber = 0;

    while (hasMore) {
      batchNumber++;
      const batchStart = Date.now();

      const result: { rows: SupabaseUserFromDB[] } = await fromDB.query<SupabaseUserFromDB>(
        `
        SELECT 
          u.*,
          COALESCE(
            json_agg(
              i.* ORDER BY i.id
            ) FILTER (WHERE i.id IS NOT NULL),
            '[]'::json
          ) as identities
        FROM auth.users u
        LEFT JOIN auth.identities i ON u.id = i.user_id
        ${lastProcessedId ? 'WHERE u.id > $1' : ''}
        GROUP BY u.id
        ORDER BY u.id ASC
        LIMIT $${lastProcessedId ? '2' : '1'}
      `,
        lastProcessedId ? [lastProcessedId, batchSize] : [batchSize],
      );

      const batch: SupabaseUserFromDB[] = result.rows;
      hasMore = batch.length === batchSize;

      if (batch.length === 0) break;

      console.log(
        `\nBatch ${batchNumber}/${Math.ceil(totalUsers / batchSize)} (${batch.length} users)`,
      );

      const stats = await processBatch(batch, ctx);

      lastProcessedId = batch[batch.length - 1]!.id;
      stateManager.updateProgress(
        batch.length,
        stats.success,
        stats.failure,
        stats.skip,
        lastProcessedId,
      );

      stats.errors.forEach((err) => stateManager.addError(err.userId, err.error));

      const batchTime = ((Date.now() - batchStart) / 1000).toFixed(2);
      const usersPerSec = (batch.length / parseFloat(batchTime)).toFixed(0);

      const state = stateManager.getState();
      console.log(`Success: ${stats.success} | Skip: ${stats.skip} | Failure: ${stats.failure}`);
      console.log(
        `Progress: ${stateManager.getProgress()}% (${state.processedUsers.toLocaleString()}/${state.totalUsers.toLocaleString()})`,
      );
      console.log(`Speed: ${usersPerSec} users/sec (${batchTime}s for this batch)`);

      const eta = stateManager.getETA();
      if (eta) {
        console.log(`ETA: ${eta}`);
      }
    }

    stateManager.complete();
    const finalState = stateManager.getState();

    console.log('\n🎉 Migration completed');
    console.log(`   - Success: ${finalState.successCount.toLocaleString()}`);
    console.log(`   - Skipped: ${finalState.skipCount.toLocaleString()}`);
    console.log(`   - Failed: ${finalState.failureCount.toLocaleString()}`);

    const totalTime =
      finalState.completedAt && finalState.startedAt
        ? ((finalState.completedAt.getTime() - finalState.startedAt.getTime()) / 1000 / 60).toFixed(
            1,
          )
        : '0';
    console.log(`   Total time: ${totalTime} minutes`);

    if (finalState.errors.length > 0) {
      console.log(`\nFirst ${Math.min(10, finalState.errors.length)} errors:`);
      finalState.errors.slice(0, 10).forEach((err) => {
        console.log(`- User ${err.userId}: ${err.error}`);
      });
    }

    return finalState;
  } catch (error) {
    stateManager.fail();
    console.error('\nMigration failed:', error);
    throw error;
  } finally {
    await fromDB.end();
    await toDB.end();
  }
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

async function main() {
  console.log('🚀 Supabase Auth → Better Auth Migration\n');

  if (!process.env.FROM_DATABASE_URL) {
    console.error('Error: FROM_DATABASE_URL environment variable is required');
    process.exit(1);
  }
  if (!process.env.TO_DATABASE_URL) {
    console.error('Error: TO_DATABASE_URL environment variable is required');
    process.exit(1);
  }

  try {
    await migrateFromSupabase();
    process.exit(0);
  } catch (error) {
    console.error('\nMigration failed:', error);
    process.exit(1);
  }
}
main();
```

You can configure the script using `CONFIG` inside the script.

- `batchSize`: Number of users to process in each batch. Default: 5000
- `resumeFromId`: Resume from a specific user ID (cursor-based pagination). Default: null
- `tempEmailDomain`: Temporary email domain for phone-only users. Default: "temp.better-auth.com"
</Step>

<Step>
### Run the migration script

<Callout type="info">
The migration script uses **keyset pagination** (cursor-based) which efficiently handles large datasets without loading everything into memory. For very large migrations (500k+ users), you may need to increase Node's memory limit with `NODE_OPTIONS="--max-old-space-size=8192"`.
</Callout>

Run the migration script to migrate the users and accounts from Supabase to Better Auth.

```bash title="Terminal"
npx tsx migration.ts
```

You can also use other TypeScript runners like `bun migration.ts`, `ts-node migration.ts`, or compile to JS first.
</Step>
<Step>
 ### Change password hashing algorithm

 By default, Better Auth uses the `scrypt` algorithm to hash passwords. Since Supabase uses `bcrypt`, you'll need to configure Better Auth to use bcrypt for password verification.

 First, install bcrypt:

 ```package-install
 npm install bcrypt
 ```

 ```bash title="Terminal"
 npm install -D @types/bcrypt
 ```

 Then add the password configuration to your existing auth config:

 ```ts title="auth.ts"
 import { betterAuth } from "better-auth";
 import { Pool } from "pg";
 import { admin, anonymous, phoneNumber } from 'better-auth/plugins';
 import bcrypt from "bcrypt"; // [!code highlight]
 
 export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: {
        enabled: true,
        password: { // [!code highlight]
            hash: async (password) => { // [!code highlight]
                return await bcrypt.hash(password, 10); // [!code highlight]
            }, // [!code highlight]
            verify: async ({ hash, password }) => { // [!code highlight]
                return await bcrypt.compare(password, hash); // [!code highlight]
            } // [!code highlight]
        } // [!code highlight]
    },
    socialProviders: {
        // ... your social providers
    },
    plugins: [admin(), anonymous(), phoneNumber()],
    user: {
        additionalFields: {
            // ... your additional fields
        },
    },
 })
 ```
</Step>
<Step>
### Update your code

Update your codebase from Supabase auth calls to Better Auth API.

Here's a list of the Supabase auth API calls and their Better Auth counterparts.

- `supabase.auth.signUp` -> `authClient.signUp.email`
- `supabase.auth.signInWithPassword` -> `authClient.signIn.email`
- `supabase.auth.signInWithOAuth` -> `authClient.signIn.social`
- `supabase.auth.signInAnonymously` -> `authClient.signIn.anonymous`
- `supabase.auth.signOut` -> `authClient.signOut`
- `supabase.auth.getSession` -> `authClient.getSession` -  you can also use `authClient.useSession` for reactive state

Learn more:
- [Basic Usage](/docs/basic-usage): Learn how to use the auth client to sign up, sign in, and sign out.
- [Email and Password](/docs/authentication/email-password): Learn how to add email and password authentication to your project.
- [Anonymous](/docs/plugins/anonymous): Learn how to add anonymous authentication to your project.
- [Admin](/docs/plugins/admin): Learn how to add admin authentication to your project.
- [Email OTP](/docs/plugins/email-otp): Learn how to add email OTP authentication to your project.
- [Hooks](/docs/concepts/hooks): Learn how to use the hooks to listen for events.
- [Next.js](/docs/integrations/next): Learn how to use the auth client in a Next.js project.
</Step>
</Steps>

## Migrating Enterprise SSO

<Callout type="info">
**Skip this section** if you're not using Supabase's Enterprise SSO feature. This section is only for users who have SAML SSO providers configured in Supabase.
</Callout>

If you're using Supabase's Enterprise SSO (SAML), follow these additional steps to migrate your SSO providers and users.

<Callout type="warn">
SSO migration requires updating your Identity Provider (IdP) configuration with new callback URLs. Plan for a brief cutover window as existing SSO sessions will be invalidated.
</Callout>

<Steps>

<Step>
### Install the SSO plugin

Install the Better Auth SSO package:

```package-install
npm install @better-auth/sso
```

Add the SSO plugin to your auth configuration:

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { Pool } from "pg";
import { admin, anonymous, phoneNumber } from 'better-auth/plugins';
import { sso } from '@better-auth/sso'; // [!code highlight]

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
    },
    plugins: [
        admin(), 
        anonymous(), 
        phoneNumber(),
        sso(), // [!code highlight]
    ],
})
```
</Step>

<Step>
### Run the SSO database migration

Run the migration to create the `ssoProvider` table:

```bash title="Terminal"
npx auth migrate
```
</Step>

<Step>
### Export your Supabase SSO providers

List and export your existing SSO providers from Supabase using the CLI:

```bash title="Terminal"
# List all SSO providers
supabase sso list --project-ref <your-project-ref>

# Export each provider's details to a JSON file
supabase sso show <provider-id> --project-ref <your-project-ref> -o json > sso-provider.json
```

A typical Supabase SSO provider export looks like this:

```json title="sso-provider.json"
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "saml": {
    "entity_id": "https://idp.example.com/saml",
    "metadata_url": "https://idp.example.com/saml/metadata",
    "attribute_mapping": {
      "keys": {
        "email": { "name": "mail" },
        "first_name": { "name": "givenName" },
        "last_name": { "name": "surname" }
      }
    }
  },
  "domains": [
    { "id": "domain-uuid", "domain": "company.com" }
  ]
}
```

<Callout type="info">
If you have multiple SSO providers, export each one separately. You'll need all of them for the migration script.
</Callout>
</Step>

<Step>
### Add SSO types to the migration script

Add these type definitions to your migration script:

```ts title="migration.ts"
// ============================================================================
// SSO MIGRATION TYPES
// ============================================================================

type SupabaseSSOProvider = {
  id: string;
  saml: {
    entity_id: string;
    metadata_url?: string;
    metadata_xml?: string;
    attribute_mapping?: {
      keys: Record<string, { name: string }>;
    };
    name_id_format?: string;
  };
  domains: Array<{ id: string; domain: string }>;
};

type SSOProviderInsertData = {
  id: string;
  providerId: string;
  issuer: string;
  domain: string;
  oidcConfig: null;
  samlConfig: string;
  organizationId: string | null;
  createdAt: string;
  updatedAt: string;
};
```
</Step>

<Step>
### Add the SSO provider migration function

Add this function to migrate your SSO providers:

```ts title="migration.ts"
// ============================================================================
// SSO PROVIDER MIGRATION
// ============================================================================

/**
 * Migrates Supabase SSO providers to Better Auth format
 * 
 * @param providers - Array of exported Supabase SSO providers
 * @param betterAuthUrl - Your Better Auth base URL (e.g., https://app.example.com)
 */
async function migrateSSOProviders(
  providers: SupabaseSSOProvider[], 
  betterAuthUrl: string
) {
  console.log(`\n[SSO] Migrating ${providers.length} SSO provider(s)...\n`);

  for (const provider of providers) {
    // Create a unique provider ID that references the original Supabase ID
    const providerId = `sso-${provider.id}`;
    
    // Combine all domains into a comma-separated string
    const domains = provider.domains.map(d => d.domain).join(',');
    
    // Transform Supabase attribute mapping to Better Auth format
    const mapping = provider.saml.attribute_mapping?.keys || {};
    
    const samlConfig = {
      issuer: provider.saml.entity_id,
      // These will be auto-populated from metadata
      entryPoint: '',
      cert: '',
      // Callback URL for SAML responses
      callbackUrl: `${betterAuthUrl}/api/auth/sso/saml2/callback/${providerId}`,
      // IdP metadata - Better Auth will fetch and parse this
      idpMetadata: provider.saml.metadata_url 
        ? { metadataUrl: provider.saml.metadata_url }
        : { metadata: provider.saml.metadata_xml },
      // SP metadata configuration
      spMetadata: {
        entityID: `${betterAuthUrl}/api/auth/sso/saml2/sp/metadata`,
      },
      // Name ID format from Supabase config
      identifierFormat: provider.saml.name_id_format || 
        'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
      // Map Supabase attribute names to Better Auth fields
      mapping: {
        id: 'nameID',
        email: mapping.email?.name || 'email',
        name: mapping.name?.name || 'displayName',
        firstName: mapping.first_name?.name || 'givenName',
        lastName: mapping.last_name?.name || 'surname',
      },
    };

    const ssoProviderData: SSOProviderInsertData = {
      id: generateId(),
      providerId,
      issuer: provider.saml.entity_id,
      domain: domains,
      oidcConfig: null,
      samlConfig: JSON.stringify(samlConfig),
      organizationId: null, // Set this if linking to a Better Auth organization
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    try {
      await toDB.query(`
        INSERT INTO "ssoProvider" (
          "id", "providerId", "issuer", "domain", 
          "oidcConfig", "samlConfig", "organizationId",
          "createdAt", "updatedAt"
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        ON CONFLICT ("providerId") DO UPDATE SET
          "issuer" = EXCLUDED."issuer",
          "domain" = EXCLUDED."domain",
          "samlConfig" = EXCLUDED."samlConfig",
          "updatedAt" = EXCLUDED."updatedAt"
      `, [
        ssoProviderData.id,
        ssoProviderData.providerId,
        ssoProviderData.issuer,
        ssoProviderData.domain,
        ssoProviderData.oidcConfig,
        ssoProviderData.samlConfig,
        ssoProviderData.organizationId,
        ssoProviderData.createdAt,
        ssoProviderData.updatedAt,
      ]);

      console.log(`[SSO] ✓ Migrated provider: ${providerId}`);
      console.log(`      Domains: ${domains}`);
      console.log(`      Issuer: ${provider.saml.entity_id}\n`);
    } catch (error: any) {
      console.error(`[SSO] ✗ Failed to migrate provider ${providerId}:`, error.message);
    }
  }

  console.log('[SSO] Provider migration complete.\n');
}
```
</Step>

<Step>
### Update user migration to link SSO accounts

In the `processBatch` function, add handling for SSO identities. Find the section that processes identities and add:

```ts title="migration.ts"
// Inside the identity processing loop in processBatch()
for (const identity of user.identities ?? []) {
  // ... existing email and social provider handling ...

  // Handle SSO identities // [!code highlight]
  if (identity.provider.startsWith('sso:')) { // [!code highlight]
    const supabaseProviderId = identity.provider.replace('sso:', ''); // [!code highlight]
    
    accountsData.push({ // [!code highlight]
      id: generateId(), // [!code highlight]
      userId: user.id, // [!code highlight]
      providerId: `sso-${supabaseProviderId}`, // Matches the migrated provider ID // [!code highlight]
      accountId: identity.identity_data?.sub || identity.provider_id, // [!code highlight]
      password: null, // [!code highlight]
      createdAt: identity.created_at ?? user.created_at, // [!code highlight]
      updatedAt: identity.updated_at ?? user.updated_at, // [!code highlight]
    }); // [!code highlight]
  } // [!code highlight]
}
```

This ensures that users who previously signed in via SSO will have their accounts linked to the migrated SSO provider.
</Step>

<Step>
### Run the SSO migration

Create a separate script or add to your main migration to run the SSO provider migration:

```ts title="run-sso-migration.ts"
import { readFileSync } from 'fs';

// Load your exported Supabase SSO providers
const providers: SupabaseSSOProvider[] = [
  JSON.parse(readFileSync('./sso-provider-1.json', 'utf-8')),
  // Add more providers if you have multiple
];

// Your Better Auth application URL
const BETTER_AUTH_URL = process.env.BETTER_AUTH_URL || 'https://app.example.com';

async function main() {
  // First, migrate users (including SSO user accounts)
  await migrateFromSupabase();
  
  // Then, migrate SSO providers
  await migrateSSOProviders(providers, BETTER_AUTH_URL);
}

main();
```

Run the migration:

```bash title="Terminal"
npx tsx run-sso-migration.ts
```
</Step>

<Step>
### Update your Identity Provider

After migrating, you need to update your IdP (Okta, Azure AD, Google Workspace, etc.) with the new Better Auth endpoints.

**Update these settings in your IdP:**

| Setting | Old Value (Supabase) | New Value (Better Auth) |
|---------|----------------------|-------------------------|
| ACS URL / Reply URL | `https://<project>.supabase.co/auth/v1/sso/saml/acs` | `https://yourapp.com/api/auth/sso/saml2/callback/<providerId>` |
| Entity ID / Audience | `https://<project>.supabase.co/auth/v1/sso/saml/metadata` | `https://yourapp.com/api/auth/sso/saml2/sp/metadata?providerId=<providerId>` |

Replace `<providerId>` with your migrated provider ID (e.g., `sso-550e8400-e29b-41d4-a716-446655440000`).

<Callout type="info">
You can retrieve the SP metadata for your provider at:
`GET https://yourapp.com/api/auth/sso/saml2/sp/metadata?providerId=<providerId>`

Share this URL with your IdP administrator if they need the full metadata XML.
</Callout>
</Step>

<Step>
### Update your client code

Replace Supabase SSO authentication calls with Better Auth:

```ts title="Before (Supabase)"
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

// Sign in with SSO
await supabase.auth.signInWithSSO({ 
  domain: 'company.com' 
});
```

```ts title="After (Better Auth)"
import { createAuthClient } from 'better-auth/client';
import { ssoClient } from '@better-auth/sso/client'; // [!code highlight]

const authClient = createAuthClient({
  plugins: [ssoClient()], // [!code highlight]
});

// Sign in with SSO by domain // [!code highlight]
await authClient.signIn.sso({  // [!code highlight]
  domain: 'company.com', // [!code highlight]
  callbackURL: '/dashboard', // [!code highlight]
}); // [!code highlight]
```

You can also initiate SSO by email (the domain is extracted automatically):

```ts title="auth-client.ts"
// Sign in by email - domain is extracted from email
await authClient.signIn.sso({ 
  email: 'user@company.com',
  callbackURL: '/dashboard',
});

// Or sign in by provider ID directly
await authClient.signIn.sso({ 
  providerId: 'sso-550e8400-e29b-41d4-a716-446655440000',
  callbackURL: '/dashboard',
});
```
</Step>

<Step>
### Test the SSO flow

Before going live, test the complete SSO flow:

1. **Test SP-initiated SSO**: Start from your app's login page, enter an SSO-enabled email domain
2. **Verify user attributes**: Check that name, email, and other attributes are mapped correctly
3. **Test existing users**: Ensure users who previously logged in via SSO can still access their accounts
4. **Test new users**: Verify that new SSO users are created correctly

```ts title="test-sso.ts"
// Quick test - check if SSO provider is configured correctly
const response = await fetch(
  'https://yourapp.com/api/auth/sso/saml2/sp/metadata?providerId=sso-your-provider-id'
);
const metadata = await response.text();
console.log('SP Metadata:', metadata);
```
</Step>

</Steps>

### SSO Migration Checklist

Use this checklist to ensure a complete SSO migration:

```
- [ ] SSO plugin installed and configured
- [ ] Database migration run (`ssoProvider` table created)
- [ ] Supabase SSO providers exported
- [ ] Providers migrated to Better Auth database
- [ ] User accounts linked to SSO providers
- [ ] IdP settings updated (ACS URL, Entity ID)
- [ ] Client code updated to use Better Auth SSO
- [ ] SP-initiated SSO flow tested
- [ ] Existing SSO users can log in
- [ ] New SSO users can be created
```

### Troubleshooting SSO

<Callout type="warn">
**SAML Signature Errors**: If you see signature validation errors, ensure your IdP's certificate is current. Some IdPs rotate certificates periodically—check the metadata URL for the latest certificate.
</Callout>

<Callout type="info">
**Attribute Mapping Issues**: If user attributes aren't populating correctly, inspect the SAML assertion from your IdP using browser developer tools. Update the `mapping` field in your `samlConfig` to match the exact attribute names your IdP sends.
</Callout>

<Callout type="info">
**Multiple Domains**: If you have multiple domains for a single SSO provider, separate them with commas in the `domain` field: `"company.com,company.org"`.
</Callout>

Learn more about SSO configuration in the [SSO Plugin Documentation](/docs/plugins/sso).

### Auth Protection

To protect routes with proxy(middleware), refer to the [Next.js Auth Protection Guide](/docs/integrations/next#auth-protection) or your framework's documentation.

## Wrapping Up

Congratulations! You've successfully migrated from Supabase Auth to Better Auth.

Better Auth offers greater flexibility and more features—be sure to explore the [documentation](/docs) to unlock its full potential.
---
title: Migrating from Clerk to Better Auth
description: A step-by-step guide to transitioning from Clerk to Better Auth.
---

In this guide, we'll walk through the steps to migrate a project from Clerk to Better Auth — including email/password with proper hashing, social/external accounts, phone number, two-factor data, and more.

<Callout type="warn">
This migration will invalidate all active sessions. This guide doesn't currently show you how to migrate Organization but it should be possible with additional steps and the [Organization](/docs/plugins/organization) Plugin.
</Callout>

## Before You Begin

Before starting the migration process, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started. And go to 

<Steps>
<Step>
### Connect to your database

You'll need to connect to your database to migrate the users and accounts. You can use any database you want, but for this example, we'll use PostgreSQL.

```package-install
npm install pg
```

And then you can use the following code to connect to your database.

```ts title="auth.ts"
import { Pool } from "pg";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
})
```
</Step>
<Step>
### Enable Email and Password (Optional)

Enable the email and password in your auth config and implement your own logic for sending verification emails, reset password emails, etc.

<Callout type="info">
**Important for Clerk Migrations**: Clerk uses bcrypt to hash passwords, while Better Auth uses `scrypt` by default. To ensure migrated users can sign in with their existing passwords, you'll need to configure Better Auth to use bcrypt for password verification.
</Callout>

First, install bcrypt:

```package-install
pnpm add bcrypt
pnpm add -D @types/bcrypt
```

Then configure Better Auth to use bcrypt:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import bcrypt from "bcrypt";

export const auth = betterAuth({
    emailAndPassword: { 
        enabled: true,
        password: { // [!code highlight]
            hash: async (password) => { // [!code highlight]
                return await bcrypt.hash(password, 10); // [!code highlight]
            }, // [!code highlight]
            verify: async ({ hash, password }) => { // [!code highlight]
                return await bcrypt.compare(password, hash); // [!code highlight]
            }, // [!code highlight]
        }, // [!code highlight]
    }, // [!code highlight]
})
```

See [Email and Password](/docs/authentication/email-password) for more configuration options.
</Step>
<Step>
### Setup Social Providers (Optional)

Add social providers you have enabled in your Clerk project in your auth config.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
    },
    socialProviders: { // [!code highlight]
        github: { // [!code highlight]
            clientId: process.env.GITHUB_CLIENT_ID, // [!code highlight]
            clientSecret: process.env.GITHUB_CLIENT_SECRET, // [!code highlight]
        } // [!code highlight]
    } // [!code highlight]
})
```
</Step>
<Step>
### Add Plugins (Optional)

You can add the following plugins to your auth config based on your needs.

[Admin](/docs/plugins/admin) Plugin will allow you to manage users, user impersonations and app level roles and permissions.

[Two Factor](/docs/plugins/2fa) Plugin will allow you to add two-factor authentication to your application.

[Phone Number](/docs/plugins/phone-number) Plugin will allow you to add phone number authentication to your application.

[Username](/docs/plugins/username) Plugin will allow you to add username authentication to your application.

```ts title="auth.ts"
import { Pool } from "pg";
import { betterAuth } from "better-auth";
import { admin, twoFactor, phoneNumber, username } from "better-auth/plugins";
import bcrypt from "bcrypt";

export const auth = betterAuth({
    database: new Pool({ 
        connectionString: process.env.DATABASE_URL 
    }),
    emailAndPassword: { 
        enabled: true,
        password: {
            hash: async (password) => {
                return await bcrypt.hash(password, 10);
            },
            verify: async ({ hash, password }) => {
                return await bcrypt.compare(password, hash);
            },
        },
    },
    socialProviders: {
        github: {
            clientId: process.env.GITHUB_CLIENT_ID!,
            clientSecret: process.env.GITHUB_CLIENT_SECRET!,
        }
    },
    plugins: [admin(), twoFactor(), phoneNumber(), username()], // [!code highlight]
})
```
</Step>
  <Step>
  ### Generate Schema

  If you're using a custom database adapter, generate the schema:

  ```sh
  npx auth generate
  ```

  or if you're using the default adapter, you can use the following command:

  ```sh
  npx auth migrate
  ```
  </Step>
  <Step>
  ### Export Clerk Users
  Go to the Clerk dashboard and export the users. Check how to do it [here](https://clerk.com/docs/deployments/exporting-users#export-your-users-data-from-the-clerk-dashboard). It will download a CSV file with the users data. You need to save it as `exported_users.csv` and put it in the root of your project.
  </Step>
  <Step>
  ### Create the migration script

  Create a new file called `migrate-clerk.ts` in the `scripts` folder and add the following code:

  ```ts title="scripts/migrate-clerk.ts"
import { generateRandomString, symmetricEncrypt } from "better-auth/crypto";

import { auth } from "@/lib/auth"; // import your auth instance

function getCSVData(csv: string) {
    const lines = csv.split('\n').filter(line => line.trim());
    const headers = lines[0]?.split(',').map(header => header.trim()) || [];
    const jsonData = lines.slice(1).map(line => {
        const values = line.split(',').map(value => value.trim());
        return headers.reduce((obj, header, index) => {
            obj[header] = values[index] || '';
            return obj;
        }, {} as Record<string, string>);
    });

    return jsonData as Array<{
        id: string;
        first_name: string;
        last_name: string;
        username: string;
        primary_email_address: string;
        primary_phone_number: string;
        verified_email_addresses: string;
        unverified_email_addresses: string;
        verified_phone_numbers: string;
        unverified_phone_numbers: string;
        totp_secret: string;
        password_digest: string;
        password_hasher: string;
    }>;
}

const exportedUserCSV = await Bun.file("exported_users.csv").text(); // this is the file you downloaded from Clerk

async function getClerkUsers(totalUsers: number) {
    const clerkUsers: {
        id: string;
        first_name: string;
        last_name: string;
        username: string;
        image_url: string;
        password_enabled: boolean;
        two_factor_enabled: boolean;
        totp_enabled: boolean;
        backup_code_enabled: boolean;
        banned: boolean;
        locked: boolean;
        lockout_expires_in_seconds: number;
        created_at: number;
        updated_at: number;
        external_accounts: {
            id: string;
            provider: string;
            identification_id: string;
            provider_user_id: string;
            approved_scopes: string;
            email_address: string;
            first_name: string;
            last_name: string;
            image_url: string;
            created_at: number;
            updated_at: number;
        }[]
    }[] = [];
    for (let i = 0; i < totalUsers; i += 500) {
        const response = await fetch(`https://api.clerk.com/v1/users?offset=${i}&limit=${500}`, {
            headers: {
                'Authorization': `Bearer ${process.env.CLERK_SECRET_KEY}`
            }
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch users: ${response.statusText}`);
        }
        const clerkUsersData = await response.json();
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        clerkUsers.push(...clerkUsersData as any);
    }
    return clerkUsers;
}


export async function generateBackupCodes(
    secret: string,
) {
    const key = secret;
    const backupCodes = Array.from({ length: 10 })
        .fill(null)
        .map(() => generateRandomString(10, "a-z", "0-9", "A-Z"))
        .map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);
    const encCodes = await symmetricEncrypt({
        data: JSON.stringify(backupCodes),
        key: key,
    });
    return encCodes
}

// Helper function to safely convert timestamp to Date
function safeDateConversion(timestamp?: number): Date {
    if (!timestamp) return new Date();

    const date = new Date(timestamp);

    // Check if the date is valid
    if (isNaN(date.getTime())) {
        console.warn(`Invalid timestamp: ${timestamp}, falling back to current date`);
        return new Date();
    }

    // Check for unreasonable dates (before 2000 or after 2100)
    const year = date.getFullYear();
    if (year < 2000 || year > 2100) {
        console.warn(`Suspicious date year: ${year}, falling back to current date`);
        return new Date();
    }

    return date;
}

async function migrateFromClerk() {
    const jsonData = getCSVData(exportedUserCSV);
    const clerkUsers = await getClerkUsers(jsonData.length);
    const ctx = await auth.$context
    const isAdminEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "admin");
    const isTwoFactorEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "two-factor");
    const isUsernameEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "username");
    const isPhoneNumberEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "phone-number");
    for (const user of jsonData) {
        const { id, first_name, last_name, username, primary_email_address, primary_phone_number, verified_email_addresses, unverified_email_addresses, verified_phone_numbers, unverified_phone_numbers, totp_secret, password_digest, password_hasher } = user;
        const clerkUser = clerkUsers.find(clerkUser => clerkUser?.id === id);

        // create user
        const createdUser = await ctx.adapter.create<{
            id: string;
        }>({
            model: "user",
            data: {
                id,
                email: primary_email_address,
                emailVerified: verified_email_addresses.length > 0,
                name: `${first_name} ${last_name}`,
                image: clerkUser?.image_url,
                createdAt: safeDateConversion(clerkUser?.created_at),
                updatedAt: safeDateConversion(clerkUser?.updated_at),
                // # Two Factor (if you enabled two factor plugin)
                ...(isTwoFactorEnabled ? {
                    twoFactorEnabled: clerkUser?.two_factor_enabled
                } : {}),
                // # Admin (if you enabled admin plugin)
                ...(isAdminEnabled ? {
                    banned: clerkUser?.banned,
                    banExpires: clerkUser?.lockout_expires_in_seconds
                       ? new Date(Date.now() + clerkUser.lockout_expires_in_seconds * 1000)
                       : undefined,
                    role: "user"
                } : {}),
                // # Username (if you enabled username plugin)
                ...(isUsernameEnabled ? {
                    username: username,
                } : {}),
                // # Phone Number (if you enabled phone number plugin)  
                ...(isPhoneNumberEnabled ? {
                    phoneNumber: primary_phone_number,
                    phoneNumberVerified: verified_phone_numbers.length > 0,
                } : {}),
            },
            forceAllowId: true
        }).catch(async e => {
            return await ctx.adapter.findOne<{
                id: string;
            }>({
                model: "user",
                where: [{
                    field: "id",
                    value: id
                }]
            })
        })
        // create external account
        const externalAccounts = clerkUser?.external_accounts;
        if (externalAccounts) {
            for (const externalAccount of externalAccounts) {
                const { id, provider, identification_id, provider_user_id, approved_scopes, email_address, first_name, last_name, image_url, created_at, updated_at } = externalAccount;
                if (externalAccount.provider === "credential") {
                    await ctx.adapter.create({
                        model: "account",
                        data: {
                            id,
                            providerId: provider,
                            accountId: externalAccount.provider_user_id,
                            scope: approved_scopes,
                            userId: createdUser?.id,
                            createdAt: safeDateConversion(created_at),
                            updatedAt: safeDateConversion(updated_at),
                            password: password_digest,
                        }
                    })
                } else {
                    await ctx.adapter.create({
                        model: "account",
                        data: {
                            id,
                            providerId: provider.replace("oauth_", ""),
                            accountId: externalAccount.provider_user_id,
                            scope: approved_scopes,
                            userId: createdUser?.id,
                            createdAt: safeDateConversion(created_at),
                            updatedAt: safeDateConversion(updated_at),
                        },
                        forceAllowId: true
                    })
                }
            }
        }

        //two factor
        if (isTwoFactorEnabled) {
            await ctx.adapter.create({
                model: "twoFactor",
                data: {
                    userId: createdUser?.id,
                    secret: totp_secret,
                    backupCodes: await generateBackupCodes(totp_secret)
                }
            })
        }
    }
}

migrateFromClerk()
    .then(() => {
        console.log('Migration completed');
        process.exit(0);
    })
    .catch((error) => {
        console.error('Migration failed:', error);
        process.exit(1);
    });
  ```
  Make sure to replace the `process.env.CLERK_SECRET_KEY` with your own Clerk secret key. Feel free to customize the script to your needs.
 </Step>
  
<Step>
  ### Run the migration

  Run the migration:

  ```sh
  bun run script/migrate-clerk.ts # you can use any thing you like to run the script
  ```

  <Callout type="warning">
  Make sure to:
  1. Test the migration in a development environment first
  2. Monitor the migration process for any errors
  3. Verify the migrated data in Better Auth before proceeding
  4. Keep Clerk installed and configured until the migration is complete
  </Callout>

  </Step>
  <Step>
  ### Verify the migration

  After running the migration, verify that all users have been properly migrated by checking the database.
  </Step>
  <Step>
  ### Update your components

  Now that the data is migrated, you can start updating your components to use Better Auth. Here's an example for the sign-in component:

  ```tsx title="components/auth/sign-in.tsx"
  import { authClient } from "better-auth/client";

  export const SignIn = () => {
    const handleSignIn = async () => {
      const { data, error } = await authClient.signIn.email({
        email: "user@example.com",
        password: "password",
      });
      
      if (error) {
        console.error(error);
        return;
      }
      // Handle successful sign in
    };

    return (
      <form onSubmit={handleSignIn}>
        <button type="submit">Sign in</button>
      </form>
    );
  };
  ```
  </Step>
<Step>
  ### Update the middleware

  Replace your Clerk middleware with Better Auth's middleware:

  ```ts title="middleware.ts"

  import { NextRequest, NextResponse } from "next/server";
  import { getSessionCookie } from "better-auth/cookies";
  export async function middleware(request: NextRequest) {
    const sessionCookie = getSessionCookie(request);
    const { pathname } = request.nextUrl;
    if (sessionCookie && ["/login", "/signup"].includes(pathname)) {
      return NextResponse.redirect(new URL("/dashboard", request.url));
    }
    if (!sessionCookie && pathname.startsWith("/dashboard")) {
      return NextResponse.redirect(new URL("/login", request.url));
    }
    return NextResponse.next();
  }

  export const config = {
    matcher: ["/dashboard", "/login", "/signup"],
  };
  ```
  </Step>
  <Step>
  ### Remove Clerk Dependencies

  Once you've verified that everything is working correctly with Better Auth, you can remove Clerk:

  ```bash title="Remove Clerk"
  pnpm remove @clerk/nextjs @clerk/themes @clerk/types
  ```
    </Step>
</Steps>

## Additional Resources

[Goodbye Clerk, Hello Better Auth – Full Migration Guide!](https://www.youtube.com/watch?v=Za_QihbDSuk)

## Wrapping Up

Congratulations! You've successfully migrated from Clerk to Better Auth.

Better Auth offers greater flexibility and more features—be sure to explore the [documentation](/docs) to unlock its full potential.
---
title: Optimizing for Performance
description: A guide to optimizing your Better Auth application for performance.
---

In this guide, we’ll go over some of the ways you can optimize your application for a more performant Better Auth app.

## Caching

Caching is a powerful technique that can significantly improve the performance of your Better Auth application by reducing the number of database queries and speeding up response times.

### Cookie Cache

Calling your database every time `useSession` or `getSession` is invoked isn’t ideal, especially if sessions don’t change frequently. Cookie caching handles this by storing session data in a short-lived, signed cookie similar to how JWT access tokens are used with refresh tokens.

To turn on cookie caching, just set `session.cookieCache` in your auth config:

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  session: {
    cookieCache: {
      enabled: true,
      maxAge: 5 * 60, // Cache duration in seconds
    },
  },
});
```

Read more about [cookie caching](/docs/concepts/session-management#cookie-cache).

### Framework Caching

Here are examples of how you can do caching in different frameworks and environments:

<Tabs items={["Next", "react-router", "SolidStart", "TanStack Query"]}>
  <Tab value="Next">
    Since Next v15, we can use the `"use cache"` directive to cache the response of a server function.

    ```ts
    export async function getUsers() {
        'use cache' // [!code highlight]
        const { users } = await auth.api.listUsers();
        return users
    }
    ```

    Learn more about NextJS use cache directive <Link href="https://nextjs.org/docs/app/api-reference/directives/use-cache">here</Link>.

  </Tab>
    <Tab value="react-router">
    In React Router v7, you use HTTP `Cache-Control` headers in the loader function to cache responses. You must also export a headers function to send these headers. Here's an example:

    ```ts
    import { data } from 'react-router';
    import type { Route } from './+types/your-route-name';
    
    export const loader = async ({ request }: Route.LoaderArgs) => {
      const { users } = await auth.api.listUsers();
      
      return data(users, {
        headers: {
          'Cache-Control': 'max-age=3600', // Cache for 1 hour
        },
      });
    };
    
    export function headers({ loaderHeaders }: Route.HeadersArgs) {
      return loaderHeaders;
    }
    ```



  </Tab>

  <Tab value="SolidStart">
    In SolidStart, you can use the `query` function to cache data. Here’s an example:

    ```tsx
    const getUsers = query(
        async () => (await auth.api.listUsers()).users,
        "getUsers"
    );
    ```

    Learn more about SolidStart `query` function <Link href="https://docs.solidjs.com/solid-router/reference/data-apis/query">here</Link>.

  </Tab>
  <Tab value="TanStack Query">
    With TanStack Query you can use the `useQuery` hook to cache data. Here’s an example:

    ```ts
    import { useQuery } from '@tanstack/react-query';

    const fetchUsers = async () => {
        const { users } = await auth.api.listUsers();
        return users;
    };

    export default function Users() {
        const { data: users, isLoading } = useQuery('users', fetchUsers, {
            staleTime: 1000 * 60 * 15, // Cache for 15 minutes
        });

        if (isLoading) return <div>Loading...</div>;

        return (
            <ul>
                {users.map(user => (
                    <li key={user.id}>{user.name}</li>
                ))}
            </ul>
        );
    }
    ```

    Learn more about TanStack Query <Link href="https://tanstack.com/query">here</Link>.

  </Tab>
</Tabs>

## SSR Optimizations

If you're using a framework that supports server-side rendering, it's usually best to pre-fetch the user session on the server and use it as a fallback on the client.

```ts
const session = await auth.api.getSession({
  headers: await headers(),
});
//then pass the session to the client
```

## Database optimizations

Optimizing database performance is essential to get the best out of Better Auth.

#### Recommended fields to index

| Table         | Fields                     | Plugin       |
| ------------- | -------------------------- | ------------ |
| users         | `email`                    |              |
| accounts      | `userId`                   |              |
| sessions      | `userId`, `token`          |              |
| verifications | `identifier`               |              |
| invitations   | `email`, `organizationId`  | organization |
| members       | `userId`, `organizationId` | organization |
| organizations | `slug`                     | organization |
| passkey       | `userId`                   | passkey      |
| twoFactor     | `secret`                   | twoFactor    |

<Callout>
  We intend to add indexing support in our schema generation tool in the future.
</Callout>

## Bundle Size Optimization

If you're using custom adapters (like Prisma, Drizzle, or MongoDB), you can reduce your bundle size by using `better-auth/minimal` instead of `better-auth`. This version excludes Kysely, which is only needed when using direct database connections.

### Usage

Simply import from `better-auth/minimal` instead of `better-auth`:

<Tabs items={["Prisma", "Drizzle", "MongoDB"]}>
  <Tab value="Prisma">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth/minimal"; // [!code highlight]
    import { prismaAdapter } from "better-auth/adapters/prisma";
    import { PrismaClient } from "@prisma/client";

    const prisma = new PrismaClient();

    export const auth = betterAuth({
      database: prismaAdapter(prisma, {
        provider: "postgresql", // or "mysql", "sqlite"
      }),
    });
    ```
  </Tab>

  <Tab value="Drizzle">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth/minimal"; // [!code highlight]
    import { drizzleAdapter } from "better-auth/adapters/drizzle";
    import { db } from "./database";

    export const auth = betterAuth({
      database: drizzleAdapter(db, {
        provider: "pg", // or "mysql", "sqlite"
      }),
    });
    ```
  </Tab>

  <Tab value="MongoDB">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth/minimal"; // [!code highlight]
    import { mongodbAdapter } from "better-auth/adapters/mongodb";
    import { MongoClient } from "mongodb";

    const client = new MongoClient(process.env.DATABASE_URL!);
    const db = client.db();

    export const auth = betterAuth({
      database: mongodbAdapter(db),
    });
    ```
  </Tab>
</Tabs>

<Callout type="warning">
  **Limitations:**
  - Direct database connections are not supported (you must use an adapter)
  - Built-in migrations are not supported. Use external migration tools (or use `better-auth` if you need built-in migration support)
</Callout>
---
title: Next.js Example
description: Better Auth Next.js example.
---

This is an example of how to use Better Auth with Next.

**Implements the following features:**
Email & Password . Social Sign-in . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management . Organization, Members and Roles

See [Demo](https://demo.better-auth.com)

<ForkButton url="better-auth/better-auth/tree/main/demo/nextjs"  />

<iframe src="https://stackblitz.com/github/better-auth/better-auth/tree/main/demo/nextjs?codemirror=1&fontsize=14&hidenavigation=1&runonclick=1&hidedevtools=1"
   style={{
      width: "100%",
      height: "500px",
      border: 0,
      borderRadius: "4px",
      overflow: "hidden"
   }}
   title="Better Auth Next.js Example"
   allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
   sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   >
</iframe>


## How to run

1. Clone the code sandbox (or the repo) and open it in your code editor
2. Move .env.example to .env and provide necessary variables
3. Run the following commands
   ```bash
   pnpm install
   pnpm dev
   ```
4. Open the browser and navigate to `http://localhost:3000`

### SSO Login Example

For this example, we utilize DummyIDP. Initiate the login from the [DummyIDP login](https://dummyidp.com/apps/app_01k16v4vb5yytywqjjvv2b3435/login), click "Proceed", and from here it will direct you to user's dashboard.
 
### SCIM Sync Example

For this example, we utilize DummyIDP. Head out to the [IDP dashboard](https://dummyidp.com/apps/app_01k16v4vb5yytywqjjvv2b3435) and try to add, update or remove users, then go to the admin page or directly to your database and watch the synchronization work.---
title: Nuxt Example
description: Better Auth Nuxt example.
---

This is an example of how to use Better Auth with Nuxt.

**Implements the following features:**
Email & Password . Social Sign-in with Google

<ForkButton url="better-auth/examples/tree/main/nuxt-example"  />


<iframe src="https://stackblitz.com/github/better-auth/examples/tree/main/nuxt-example?codemirror=1&fontsize=14&hidenavigation=1&runonclick=1&hidedevtools=1"
   style={{
      width: "100%",
      height: "500px",
      border: 0,
      borderRadius: "4px",
      overflow: "hidden"
   }}
   title="Better Auth Nuxt Example"
   allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
   sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   >
</iframe>


## How to run

1. Clone the code sandbox (or the repo) and open it in your code editor
2. Move .env.example to .env and provide necessary variables
3. Run the following commands
   ```bash
   pnpm install
   pnpm dev
   ```
4. Open the browser and navigate to `http://localhost:3000`
---
title: Astro Example
description: Better Auth Astro example.
---

This is an example of how to use Better Auth with Astro. It uses Solid for building the components.


**Implements the following features:**
Email & Password . Social Sign-in with Google . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management

<ForkButton url="better-auth/examples/tree/main/astro-example"  />

<iframe src="https://stackblitz.com/github/better-auth/examples/tree/main/astro-example?codemirror=1&fontsize=14&hidenavigation=1&runonclick=1&hidedevtools=1"
   style={{
      width: "100%",
      height: "500px",
      border: 0,
      borderRadius: "4px",
      overflow: "hidden"
   }}
   title="Better Auth Astro+Solid Example"
   allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
   sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   >
</iframe>


## How to run

1. Clone the code sandbox (or the repo) and open it in your code editor
2. Provide .env file with the following variables
   ```txt
   GOOGLE_CLIENT_ID=
   GOOGLE_CLIENT_SECRET=
   BETTER_AUTH_SECRET=
   ```
   //if you don't have these, you can get them from the google developer console. If you don't want to use google sign-in, you can remove the google config from the `auth.ts` file.

3. Run the following commands
   ```bash
   pnpm install
   pnpm run dev
   ```
4. Open the browser and navigate to `http://localhost:3000`
---
title: SvelteKit Example
description: Better Auth SvelteKit example.
---

This is an example of how to use Better Auth with SvelteKit.

**Implements the following features:**
Email & Password . <u>Social Sign-in with Google</u> . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management

<ForkButton url="better-auth/examples/tree/main/svelte-kit-example"  />

<iframe src="https://stackblitz.com/github/better-auth/examples/tree/main/svelte-kit-example?codemirror=1&fontsize=14&hidenavigation=1&runonclick=1&hidedevtools=1"
   style={{
      width: "100%",
      height: "500px",
      border: 0,
      borderRadius: "4px",
      overflow: "hidden"
   }}
   title="Better Auth SvelteKit Example"
   allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
   sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   >
</iframe>

## How to run

1. Clone the code sandbox (or the repo) and open it in your code editor
2. Move .env.example to .env and provide necessary variables
3. Run the following commands
   ```bash
   pnpm install
   pnpm dev
   ```
4. Open the browser and navigate to `http://localhost:3000`
---
title: React Router v7 Example
description: Better Auth React Router v7 example.
---

This is an example of how to use Better Auth with React Router v7.


**Implements the following features:**
Email & Password . Social Sign-in with Google . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management

<ForkButton url="better-auth/examples/tree/main/react-router-example"  />

<iframe src="https://stackblitz.com/github/better-auth/examples/tree/main/react-router-example?codemirror=1&fontsize=14&hidedevtools=1&hidenavigation=1&runonclick=1"
   style={{
      width: "100%",
      height: "500px",
      border: 0,
      borderRadius: "4px",
      overflow: "hidden"
   }}
   title="Better Auth React Router v7 Example"
   allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
   sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   >
</iframe>


## How to run

1. Clone the code sandbox (or the repo) and open it in your code editor
2. Provide .env file with by copying the `.env.example` file and adding the variables
3. Run the following commands
   ```bash
   pnpm install
   pnpm run dev
   ```
4. Open the browser and navigate to `http://localhost:3000`
---
title: CLI
description: Built-in CLI for managing your project.
---

Better Auth comes with a built-in CLI to help you manage the database schemas, initialize your project, generate a secret key for your application, and gather diagnostic information about your setup.

## Generate

The `generate` command creates the schema required by Better Auth. If you're using a database adapter like Prisma or Drizzle, this command will generate the right schema for your ORM. If you're using the built-in Kysely adapter, it will generate an SQL file you can run directly on your database.

```package-install title="Terminal"
npx auth@latest generate
```

### Options

- `--output` - Where to save the generated schema. For Prisma, it will be saved in prisma/schema.prisma. For Drizzle, it goes to schema.ts in your project root. For Kysely, it's an SQL file saved as schema.sql in your project root.
- `--config` - The path to your Better Auth config file. By default, the CLI will search for an auth.ts file in **./**, **./utils**, **./lib**, or any of these directories under the `src` directory.
- `--yes` - Skip the confirmation prompt and generate the schema directly.


## Migrate

The migrate command applies the Better Auth schema directly to your database. This is available if you're using the built-in Kysely adapter. For other adapters, you'll need to apply the schema using your ORM's migration tool.

```package-install title="Terminal"
npx auth@latest migrate
```

### Options

- `--config` - The path to your Better Auth config file. By default, the CLI will search for an auth.ts file in **./**, **./utils**, **./lib**, or any of these directories under the `src` directory.
- `--yes` - Skip the confirmation prompt and apply the schema directly.

<Callout type="info">
**Using PostgreSQL with a non-default schema?**

The migrate command automatically detects your configured `search_path` and creates tables in the correct schema. See the [PostgreSQL adapter documentation](/docs/adapters/postgresql#use-a-non-default-schema) for configuration details.
</Callout>

## Init

The `init` command allows you to initialize Better Auth in your project.

```package-install title="Terminal"
npx auth@latest init
```

### Options

- `--name` - The name of your application. (defaults to the `name` property in your `package.json`).
- `--framework` - The framework your codebase is using. Currently, the only supported framework is `Next.js`.
- `--plugins` - The plugins you want to use. You can specify multiple plugins by separating them with a comma.
- `--database` - The database you want to use. Currently, the only supported database is `SQLite`.
- `--package-manager` - The package manager you want to use. Currently, the only supported package managers are `npm`, `pnpm`, `yarn`, `bun` (defaults to the manager you used to initialize the CLI).

## Info

The `info` command provides diagnostic information about your Better Auth setup and environment. Useful for debugging and sharing when seeking support.

```package-install title="Terminal"
npx auth@latest info
```

### Output

The command displays:
- **System**: OS, CPU, memory, Node.js version
- **Package Manager**: Detected manager and version
- **Better Auth**: Version and configuration (sensitive data auto-redacted)
- **Frameworks**: Detected frameworks (Next.js, React, Vue, etc.)
- **Databases**: Database clients and ORMs (Prisma, Drizzle, etc.)

### Options

- `--config` - Path to your Better Auth config file
- `--json` - Output as JSON for sharing or programmatic use

### Examples

```bash
# Basic usage
npx auth@latest info

# Custom config path
npx auth@latest info --config ./config/auth.ts

# JSON output
npx auth@latest info --json > auth-info.json
```

Sensitive data like secrets, API keys, and database URLs are automatically replaced with `[REDACTED]` for safe sharing.

## Secret

The CLI also provides a way to generate a secret key for your Better Auth instance.

```package-install title="Terminal"
npx auth@latest secret
```

## Common Issues

**Error: Cannot find module X**

If you see this error, it means the CLI can't resolve imported modules in your Better Auth config file. We are working on a fix for many of these issues, but in the meantime, you can try the following:

- Remove any import aliases in your config file and use relative paths instead. After running the CLI, you can revert to using aliases.---
title: Plugins
description: Learn how to use plugins with Better Auth.
---

Plugins are a key part of Better Auth, they let you extend the base functionalities. You can use them to add new authentication methods, features, or customize behaviors.

Better Auth comes with many built-in plugins ready to use. Check the plugins section for details. You can also create your own plugins.

## Using a Plugin

Plugins can be a server-side plugin, a client-side plugin, or both.

To add a plugin on the server, include it in the `plugins` array in your auth configuration. The plugin will initialize with the provided options.

```ts title="server.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    plugins: [
        // Add your plugins here
    ]
});
```

Client plugins are added when creating the client. Most plugins require both server and client plugins to work correctly.
The Better Auth auth client on the frontend uses the `createAuthClient` function provided by `better-auth/client`.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";

const authClient = createAuthClient({
    plugins: [
        // Add your client plugins here
    ]
});
```

We recommend keeping the auth-client and your normal auth instance in separate files.
<Files>
  <Folder name="auth" defaultOpen>
    <File name="server.ts" />
    <File name="auth-client.ts" />
  </Folder>
</Files>

## Creating a Plugin

To get started, you'll need a server plugin.
Server plugins are the backbone of all plugins, and client plugins are there to provide an interface with frontend APIs to easily work with your server plugins.

<Callout type="info">
    If your server plugins have endpoints that need to be called from the client, you'll also need to create a client plugin.
</Callout>

### What can a plugin do?

* Create custom `endpoint`s to perform any action you want.
* Extend database tables with custom `schemas`.
* Use a `middleware` to target a group of routes using its route matcher, and run only when those routes are called through a request.
* Use `hooks` to target a specific route or request. And if you want to run the hook even if the endpoint is called directly.
* Use `onRequest` or `onResponse` if you want to do something that affects all requests or responses.
* Create a custom `rate-limit` rule.

## Create a Server plugin

To create a server plugin, you need to pass an object that satisfies the `BetterAuthPlugin` interface.

The only required property is `id`, which is a unique identifier for the plugin.
Both server and client plugins can use the same `id`.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";

export const myPlugin = () => {
    return {
        id: "my-plugin",
    } satisfies BetterAuthPlugin
}
```
<Callout>
    You don't have to make the plugin a function, but it's recommended to do so. This way, you can pass options to the plugin and it's consistent with the built-in plugins.
</Callout>

### Endpoints

To add endpoints to the server, you can pass `endpoints` which requires an object with the key being any `string` and the value being an `AuthEndpoint`.

To create an Auth Endpoint you'll need to import `createAuthEndpoint` from `better-auth`.

Better Auth uses wraps around another library called <Link href="https://github.com/bekacru/better-call"> Better Call </Link> to create endpoints. Better call is a simple ts web framework made by the same team behind Better Auth.

```ts title="plugin.ts"
import { createAuthEndpoint } from "better-auth/api";
import type { BetterAuthPlugin } from "better-auth";

const myPlugin = () => {
    return {
        id: "my-plugin",
        endpoints: {
            getHelloWorld: createAuthEndpoint("/my-plugin/hello-world", {
                method: "GET",
            }, async(ctx) => {
                return ctx.json({
                    message: "Hello World"
                })
            })
        }
    } satisfies BetterAuthPlugin
}
```

Create Auth endpoints wraps around `createEndpoint` from Better Call. Inside the `ctx` object, it'll provide another object called `context` that give you access better-auth specific contexts including `options`, `db`, `baseURL` and more.

**Context Object**

- `appName`: The name of the application. Defaults to "Better Auth".
- `options`: The options passed to the Better Auth instance.
- `tables`:  Core tables definition. It is an object which has the table name as the key and the schema definition as the value.
- `baseURL`: the baseURL of the auth server. This includes the path. For example, if the server is running on `http://localhost:3000`, the baseURL will be `http://localhost:3000/api/auth` by default unless changed by the user.
- `session`: The session configuration. Includes `updateAge` and `expiresIn` values.
- `secret`: The secret key used for various purposes. This is defined by the user.
- `authCookie`: The default cookie configuration for core auth cookies.
- `logger`: The logger instance used by Better Auth.
- `db`: The Kysely instance used by Better Auth to interact with the database.
- `adapter`: This is the same as db but it give you `orm` like functions to interact with the database. (we recommend using this over `db` unless you need raw sql queries or for performance reasons)
- `internalAdapter`: These are internal db calls that are used by Better Auth. For example, you can use these calls to create a session instead of using `adapter` directly. `internalAdapter.createSession(userId)`
- `createAuthCookie`: This is a helper function that lets you get a cookie `name` and `options` for either to `set` or `get` cookies. It implements things like `__Secure-` prefix for cookies based on whether the connection is secure (HTTPS) or the application is running in production mode.
- `trustedOrigins`: This is the list of trusted origins that you specified via `options.trustedOrigins`.
- `isTrustedOrigin`: This is a helper function that allows you to quickly check whether a given url or path is trusted based on the trusted origins configuration.

For other properties, you can check the <Link href="https://github.com/bekacru/better-call">Better Call</Link> documentation and the <Link href="https://github.com/better-auth/better-auth/blob/canary/packages/better-auth/src/context/create-context.ts">source code </Link>.


**Rules for Endpoints**

- Makes sure you use kebab-case for the endpoint path
- Make sure to only use `POST` or `GET` methods for the endpoints.
- Any function that modifies a data should be a `POST` method.
- Any function that fetches data should be a `GET` method.
- Make sure to use the `createAuthEndpoint` function to create API endpoints.
- Make sure your paths are unique to avoid conflicts with other plugins. If you're using a common path, add the plugin name as a prefix to the path. (`/my-plugin/hello-world` instead of `/hello-world`.)

### Schema

You can define a database schema for your plugin by passing a `schema` object. The schema object should have the table name as the key and the schema definition as the value.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";

const myPlugin = () => {
    return {
        id: "my-plugin",
        schema: {
            myTable: {
                fields: {
                    name: {
                        type: "string"
                    }
                },
                modelName: "myTable" // optional if you want to use a different name than the key
            }
        }
    } satisfies BetterAuthPlugin
}
```

**Fields**

By default better-auth will create an `id` field for each table. You can add additional fields to the table by adding them to the `fields` object.

The key is the column name and the value is the column definition. The column definition can have the following properties:

`type`: The type of the field. It can be `string`, `number`, `boolean`, `date`.

`required`:  if the field should be required on a new record. (default: `true`)

`unique`: if the field should be unique. (default: `false`)

`references`: if the field is a reference to another table. (optional) It takes an object with the following properties:
    - `model`: The table name to reference.
    - `field`: The field name to reference.
    - `onDelete`: The action to take when the referenced record is deleted. (default: `cascade`)

**Other Schema Properties**

`disableMigration`: if the table should not be migrated. (default: `false`)

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";

const myPlugin = (opts: PluginOptions) => {
    return {
        id: "my-plugin",
        schema: {
            rateLimit: {
                fields: {
                    key: {
                        type: "string",
                    },
                },
                disableMigration: opts.storage.provider !== "database", // [!code highlight]
            },
        },
    } satisfies BetterAuthPlugin
}
```

if you add additional fields to a `user` or `session` table, the types will be inferred automatically on `getSession` and `signUpEmail` calls.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";

const myPlugin = () => {
    return {
        id: "my-plugin",
        schema: {
            user: {
                fields: {
                    age: {
                        type: "number",
                    },
                },
            },
        },
    } satisfies BetterAuthPlugin
}
```

This will add an `age` field to the `user` table and all `user` returning endpoints will include the `age` field and it'll be inferred properly by typescript.

<Callout type="warn">
Don't store sensitive information in the `user` or `session` table. Create a new table if you need to store sensitive information.
</Callout>

### Hooks

Hooks are used to run code before or after an action is performed, either from a client or directly on the server. You can add hooks to the server by passing a `hooks` object, which should contain `before` and `after` properties.

```ts title="plugin.ts"
import { createAuthMiddleware } from "better-auth/plugins";

const myPlugin = () => {
    return {
        id: "my-plugin",
        hooks: {
            before: [{
                    matcher: (context) => {
                        return context.headers.get("x-my-header") === "my-value"
                    },
                    handler: createAuthMiddleware(async (ctx) => {
                        // do something before the request
                        return  {
                            context: ctx // if you want to modify the context
                        }
                    })
                }],
            after: [{
                matcher: (context) => {
                    return context.path === "/sign-up/email"
                },
                handler: createAuthMiddleware(async (ctx) => {
                    return ctx.json({
                        message: "Hello World"
                    }) // if you want to modify the response
                })
            }]
        }
    } satisfies BetterAuthPlugin
}
```

### Middleware

You can add middleware to the server by passing a `middlewares` array. This array should contain middleware objects, each with a `path` and a `middleware` property. Unlike hooks, middleware only runs on `api` requests from a client. If the endpoint is invoked directly, the middleware will not run.

The `path` can be either a string or a path matcher, using the same path-matching system as `better-call`.

If you throw an `APIError` from the middleware or return a `Response` object, the request will be stopped, and the response will be sent to the client.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";
import { createAuthMiddleware } from "better-auth/api";

const myPlugin = () => {
    return {
        id: "my-plugin",
        middlewares: [
            {
                path: "/my-plugin/hello-world",
                middleware: createAuthMiddleware(async(ctx) => {
                    // do something
                })
            }
        ]
    } satisfies BetterAuthPlugin
}
```


### On Request & On Response

Additional to middlewares, you can also hook into right before a request is made and right after a response is returned. This is mostly useful if you want to do something that affects all requests or responses.

#### On Request

The `onRequest` function is called right before the request is made. It takes two parameters: the `request` and the `context` object.

Here’s how it works:

- **Continue as Normal**: If you don't return anything, the request will proceed as usual.
- **Interrupt the Request**: To stop the request and send a response, return an object with a `response` property that contains a `Response` object.
- **Modify the Request**: You can also return a modified `request` object to change the request before it's sent.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";

const myPlugin = () => {
    return  {
        id: "my-plugin",
        onRequest: async (request, context) => {
            // do something
        },
    } satisfies BetterAuthPlugin
}
```

#### On Response

The `onResponse` function is executed immediately after a response is returned. It takes two parameters: the `response` and the `context` object.

Here’s how to use it:

- **Modify the Response**: You can return a modified response object to change the response before it is sent to the client.
- **Continue Normally**: If you don't return anything, the response will be sent as is.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";

const myPlugin = () => {
    return {
        id: "my-plugin",
        onResponse: async (response, context) => {
            // do something
        },
    } satisfies BetterAuthPlugin
}
```

### Rate Limit

You can define custom rate limit rules for your plugin by passing a `rateLimit` array. The rate limit array should contain an array of rate limit objects.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";

const myPlugin = () => {
    return {
        id: "my-plugin",
        rateLimit: [
            {
                pathMatcher: (path) => {
                    return path === "/my-plugin/hello-world"
                },
                limit: 10,
                window: 60,
            }
        ]
    } satisfies BetterAuthPlugin
}
```

### Trusted origins

If you're building custom plugins or endpoints, you can use the `isTrustedOrigin()` method available on the auth context to validate URLs against your trusted origins configuration.
This ensures your custom endpoints respect the same security settings as Better Auth's built-in endpoints.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";
import { createAuthEndpoint, APIError } from "better-auth/api";
import * as z from "zod"

const myPlugin = () => {
    return {
        id: "my-plugin",
        trustedOrigins: [
            "http://trusted.com"
        ],
        endpoints: {
            getTrustedHelloWorld: createAuthEndpoint("/my-plugin/hello-world", {
                method: "GET",
                query: z.object({
                    url: z.string()
                }),
            }, async (ctx) => {
                // The allowRelativePaths option can be used to either allow or disallow relative paths
                if (!ctx.context.isTrustedOrigin(ctx.query.url, { allowRelativePaths: false })) {
                    throw new APIError("FORBIDDEN", {
                        message: "origin is not trusted."
                    });
                }

                return ctx.json({
                    message: "Hello World"
                })
            })
        }
    } satisfies BetterAuthPlugin
}
```

See the [trusted origins and security](/docs/reference/security#trusted-origins) docs for more info.

### Server-plugin helper functions

Some additional helper functions for creating server plugins.

#### `getSessionFromCtx`

Allows you to get the client's session data by passing the auth middleware's `context`.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";
import { createAuthMiddleware } from "better-auth/plugins";
import { getSessionFromCtx } from "better-auth/api";

const myPlugin = {
    id: "my-plugin",
    hooks: {
        before: [{
                matcher: (context) => {
                    return context.headers.get("x-my-header") === "my-value"
                },
                handler: createAuthMiddleware(async (ctx) => {
                    const session = await getSessionFromCtx(ctx);
                    // do something with the client's session.

                    return  {
                        context: ctx
                    }
                })
            }],
    }
} satisfies BetterAuthPlugin
```

#### `sessionMiddleware`

A middleware that checks if the client has a valid session. If the client has a valid session, it'll add the session data to the context object.

```ts title="plugin.ts"
import type { BetterAuthPlugin } from "better-auth";
import { createAuthEndpoint, sessionMiddleware } from "better-auth/api";

const myPlugin = () => {
    return {
        id: "my-plugin",
        endpoints: {
            getHelloWorld: createAuthEndpoint("/my-plugin/hello-world", {
                method: "GET",
                use: [sessionMiddleware], // [!code highlight]
            }, async (ctx) => {
                const session = ctx.context.session;
                return ctx.json({
                    message: "Hello World"
                })
            })
        }
    } satisfies BetterAuthPlugin
}
```


## Creating a client plugin

If your endpoints need to be called from the client, you'll also need to create a client plugin. Better Auth clients can infer the endpoints from the server plugins. You can also add additional client-side logic.

```ts title="client-plugin.ts"
import type { BetterAuthClientPlugin } from "better-auth/client";

export const myPluginClient = () => {
    return {
        id: "my-plugin",
    } satisfies BetterAuthClientPlugin
}
```

### Endpoint Interface

Endpoints are inferred from the server plugin by adding a `$InferServerPlugin` key to the client plugin.

The client infers the `path` as an object and converts kebab-case to camelCase. For example, `/my-plugin/hello-world` becomes `myPlugin.helloWorld`.

```ts title="client-plugin.ts"
import type { BetterAuthClientPlugin } from "better-auth/client";
import type { myPlugin } from "./plugin";

const myPluginClient = () => {
    return  {
        id: "my-plugin",
        $InferServerPlugin: {} as ReturnType<typeof myPlugin>,
    } satisfies BetterAuthClientPlugin
}
```

### Get actions

If you need to add additional methods or whatnot to the client, you can use the `getActions` function. This function is called with the `fetch` function from the client.

Better Auth uses <Link href="https://better-fetch.vercel.app"> Better fetch </Link> to make requests. Better Fetch is a simple fetch wrapper made by the same author of Better Auth.

```ts title="client-plugin.ts"
import type { BetterAuthClientPlugin } from "better-auth/client";
import type { myPlugin } from "./plugin";
import type { BetterFetchOption } from "@better-fetch/fetch";

const myPluginClient = {
    id: "my-plugin",
    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,
    getActions: ($fetch) => {
        return {
            myCustomAction: async (data: {
                foo: string,
            }, fetchOptions?: BetterFetchOption) => {
                const res = $fetch("/custom/action", {
                    method: "POST",
                    body: {
                        foo: data.foo
                    },
                    ...fetchOptions
                })
                return res
            }
        }
    }
} satisfies BetterAuthClientPlugin
```

<Callout>
As a general guideline, ensure that each function accepts only one argument, with an optional second argument for fetchOptions to allow users to pass additional options to the fetch call. The function should return an object containing data and error keys.

If your use case involves actions beyond API calls, feel free to deviate from this rule.
</Callout>

### Get Atoms

This is only useful if you want to provide `hooks` like `useSession`.

Get atoms is called with the `fetch` function from better fetch, and it should return an object with the atoms. The atoms should be created using <Link href="https://github.com/nanostores/nanostores">nanostores</Link>. The atoms will be resolved by each framework's `useStore` hook provided by nanostores.

```ts title="client-plugin.ts"
import { atom } from "nanostores";
import type { BetterAuthClientPlugin } from "better-auth/client";

const myPluginClient = {
    id: "my-plugin",
    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,
    getAtoms: ($fetch) => {
        const myAtom = atom<null>()
        return {
            myAtom
        }
    }
} satisfies BetterAuthClientPlugin
```

See built-in plugins for examples of how to use atoms properly.

### Path methods

By default, inferred paths use the `GET` method if they don't require a body and `POST` if they do. You can override this by passing a `pathMethods` object. The key should be the path, and the value should be the method ("POST" | "GET").

```ts title="client-plugin.ts"
import type { BetterAuthClientPlugin } from "better-auth/client";
import type { myPlugin } from "./plugin";

const myPluginClient = {
    id: "my-plugin",
    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,
    pathMethods: {
        "/my-plugin/hello-world": "POST"
    }
} satisfies BetterAuthClientPlugin
```

### Fetch plugins

If you need to use better fetch plugins, you can pass them to the `fetchPlugins` array. You can read more about better fetch plugins in the <Link href="https://better-fetch.vercel.app/docs/plugins">better fetch documentation</Link>.

### Atom Listeners

This is only useful if you want to provide `hooks` like `useSession` and you want to listen to atoms and re-evaluate them when they change.

You can see how this is used in the built-in plugins.
---
title: OAuth
description: How Better Auth handles OAuth
---

Better Auth comes with built-in support for OAuth 2.0 and OpenID Connect. This allows you to authenticate users via popular OAuth providers like Google, Facebook, GitHub, and more.

If your desired provider isn't directly supported, you can use the [Generic OAuth Plugin](/docs/plugins/generic-oauth) for custom integrations.

## Configuring Social Providers

To enable a social provider, you need to provide `clientId` and `clientSecret` for the provider.

Here's an example of how to configure Google as a provider:

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
    },
  },
});
```

## Usage

### Sign In

To sign in with a social provider, you can use the `signIn.social` function with the `authClient` or `auth.api` for server-side usage.

```ts
// client-side usage
await authClient.signIn.social({
  provider: "google", // or any other provider id
})
```

```ts
// server-side usage
await auth.api.signInSocial({
  body: {
    provider: "google", // or any other provider id
  },
});
```

### Link account

To link an account to a social provider, you can use the `linkAccount` function with the `authClient` or `auth.api` for server-side usage.

```ts
await authClient.linkSocial({
  provider: "google", // or any other provider id
})
```

server-side usage:

```ts
await auth.api.linkSocialAccount({
  body: {
    provider: "google", // or any other provider id
  },
  headers: await headers() // headers containing the user's session token
});
```

### Get Access Token

To get the access token for a social provider, you can use the `getAccessToken` function with the `authClient` or `auth.api` for server-side usage. When you use this endpoint, if the access token is expired, it will be refreshed.

```ts
const { accessToken } = await authClient.getAccessToken({
  providerId: "google", // or any other provider id
  accountId: "accountId", // optional, if you want to get the access token for a specific account
})
```

server-side usage:

```ts
await auth.api.getAccessToken({
  body: {
    providerId: "google", // or any other provider id
    accountId: "accountId", // optional, if you want to get the access token for a specific account
    userId: "userId", // optional, if you don't provide headers with authenticated token
  },
  headers: await headers() // headers containing the user's session token
});
```

### Get Account Info Provided by the provider

To get provider specific account info you can use the `accountInfo` function with the `authClient` or `auth.api` for server-side usage.

```ts
const info = await authClient.accountInfo({
  accountId: "accountId", // here you pass in the provider given account id, the provider is automatically detected from the account id
})
```

server-side usage:

```ts
await auth.api.accountInfo({
  query: { accountId: "accountId" },
  headers: await headers() // headers containing the user's session token
});
```

### Requesting Additional Scopes

Sometimes your application may need additional OAuth scopes after the user has already signed up (e.g., for accessing GitHub repositories or Google Drive). Users may not want to grant extensive permissions initially, preferring to start with minimal permissions and grant additional access as needed.

You can request additional scopes by using the `linkSocial` method with the same provider. This will trigger a new OAuth flow that requests the additional scopes while maintaining the existing account connection.

```ts
const requestAdditionalScopes = async () => {
    await authClient.linkSocial({
        provider: "google",
        scopes: ["https://www.googleapis.com/auth/drive.file"],
    });
};
```

<Callout>
Make sure you're running Better Auth version 1.2.7 or later. Earlier versions (like 1.2.2) may show a "Social account already linked" error when trying to link with an existing provider for additional scopes.
</Callout>

### Passing Additional Data Through OAuth Flow

Better Auth allows you to pass additional data through the OAuth flow without storing it in the database. This is useful for scenarios like tracking referral codes, analytics sources, or other temporary data that should be processed during authentication but not persisted.

When initiating OAuth sign-in or account linking, pass the additional data:

```ts
// Client-side: Sign in with additional data
await authClient.signIn.social({
  provider: "google",
  additionalData: {
    referralCode: "ABC123",
    source: "landing-page",
  },
});

// Client-side: Link account with additional data
await authClient.linkSocial({
  provider: "google",
  additionalData: {
    referralCode: "ABC123",
  },
});

// Server-side: Sign in with additional data
await auth.api.signInSocial({
  body: {
    provider: "google",
    additionalData: {
      referralCode: "ABC123",
      source: "admin-panel",
    },
  },
});
```

#### Accessing Additional Data in Hooks

The additional data is available in your hooks during the OAuth callback through the `getOAuthState`.

<Callout>
This usually works for `/callback/:id` paths and the generic OAuth plugin callback path (`/oauth2/callback/:providerId`).
</Callout>

Example using a before hook:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { getOAuthState } from "better-auth/api";

export const auth = betterAuth({
  // Other configurations...
  hooks: {
    after: [
      {
        matcher: () => true,
        handler: async (ctx) => {
          // Additional data is only available during OAuth callback
          if (ctx.path === "/callback/:id") {
            const additionalData = await getOAuthState<{
              referralCode?: string;
              source?: string;
            }>();

            if (additionalData) {
              // IMPORTANT: Validate and sanitize the data before using it
              // This data comes from the client and should not be trusted

              // Example: Validate and process referral code
              if (additionalData.referralCode) {
                const isValidFormat = /^[A-Z0-9]{6}$/.test(additionalData.referralCode);
                if (isValidFormat) {
                  // Verify the referral code exists in your database
                  const referral = await db.referrals.findByCode(additionalData.referralCode);
                  if (referral) {
                    // Safe to use the verified referral
                    await db.referrals.incrementUsage(referral.id);
                  }
                }
              }

              // Track analytics (low-risk usage)
              if (additionalData.source) {
                await analytics.track("oauth_signin", {
                  source: additionalData.source,
                  userId: ctx.context.session?.user.id,
                });
              }
            }
          }
        },
      },
    ],
  },
});
```

Example using a database hook:

```ts title="auth.ts"
 // You can also access additional data in database hooks
  databaseHooks: {
    user: {
      create: {
        before: async (user, ctx) => {
          if (ctx.path === "/callback/:id") {
            const additionalData = await getOAuthState<{ referredFrom?: string }>();
            if (additionalData?.referredFrom) {
              return {
                data: {
                  referredFrom: additionalData.referredFrom,
                },
              };
            }
          }
        },
      },
    },
  },
```

<Callout>
By default OAuth state includes the following data:
- `callbackURL` - the callback URL for the OAuth flow
- `codeVerifier` - the code verifier for the OAuth flow
- `errorURL` - the error URL for the OAuth flow
- `newUserURL` - the new user URL for the OAuth flow
- `link` - the link for the OAuth flow (email and user id)
- `requestSignUp` - whether to request sign up for the OAuth flow
- `expiresAt` - the expiration time of the OAuth state
- `[key: string]`: any additional data you pass in the OAuth flow
</Callout>

## Provider Options

### scope

The scope of the access request. For example, `email` or `profile`.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      scope: ["email", "profile"],
    },
  },
});
```

### redirectURI

Custom redirect URI for the provider. By default, it uses `/api/auth/callback/${providerName}`

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      redirectURI: "https://your-app.com/auth/callback",
    },
  },
});
```

### disableSignUp

Disables sign-up for new users.

### disableIdTokenSignIn

Disables the use of the ID token for sign-in. By default, it's enabled for some providers like Google and Apple.

### verifyIdToken

A custom function to verify the ID token.

### overrideUserInfoOnSignIn

A boolean value that determines whether to override the user information in the database when signing in. By default, it is set to `false`, meaning that the user information will not be overridden during sign-in. If you want to update the user information every time they sign in, set this to `true`.

### mapProfileToUser

A custom function to map the user profile returned from the provider to the user object in your database.

Useful, if you have additional fields in your user object you want to populate from the provider's profile. Or if you want to change how by default the user object is mapped.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      mapProfileToUser: (profile) => {
        return {
          firstName: profile.given_name,
          lastName: profile.family_name,
        };
      },
    },
  },
});
```

### refreshAccessToken

A custom function to refresh the token. This feature is only supported for built-in social providers (Google, Facebook, GitHub, etc.) and is not currently supported for custom OAuth providers configured through the Generic OAuth Plugin. For built-in providers, you can provide a custom function to refresh the token if needed.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      refreshAccessToken: async (token) => {
        return {
          accessToken: "new-access-token",
          refreshToken: "new-refresh-token",
        };
      },
    },
  },
});
```

### clientKey

The client key of your application. This is used by TikTok Social Provider instead of `clientId`.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    tiktok: {
      clientKey: "YOUR_TIKTOK_CLIENT_KEY",
      clientSecret: "YOUR_TIKTOK_CLIENT_SECRET",
    },
  },
});
```

### getUserInfo

A custom function to get user info from the provider. This allows you to override the default user info retrieval process.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      getUserInfo: async (token) => {
        // Custom implementation to get user info
        const response = await fetch("https://www.googleapis.com/oauth2/v2/userinfo", {
          headers: {
            Authorization: `Bearer ${token.accessToken}`,
          },
        });
        const profile = await response.json();
        return {
          user: {
            id: profile.id,
            name: profile.name,
            email: profile.email,
            image: profile.picture,
            emailVerified: profile.verified_email,
          },
          data: profile,
        };
      },
    },
  },
});
```

### disableImplicitSignUp

Disables implicit sign up for new users. When set to true for the provider, sign-in needs to be called with `requestSignUp` as true to create new users.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      disableImplicitSignUp: true,
    },
  },
});
```

### prompt

The prompt to use for the authorization code request. This controls the authentication flow behavior.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      prompt: "select_account", // or "consent", "login", "none", "select_account+consent"
    },
  },
});
```

### responseMode

The response mode to use for the authorization code request. This determines how the authorization response is returned.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      responseMode: "query", // or "form_post"
    },
  },
});
```

### disableDefaultScope

Removes the default scopes of the provider. By default, providers include certain scopes like `email` and `profile`. Set this to `true` to remove these default scopes and use only the scopes you specify.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  // Other configurations...
  socialProviders: {
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      disableDefaultScope: true,
      scope: ["https://www.googleapis.com/auth/userinfo.email"], // Only this scope will be used
    },
  },
});
```

### Other Provider Configurations

Each provider may have additional options, check the specific provider documentation for more details.
---
title: Database
description: Learn how to use a database with Better Auth.
---

## Adapters

Better Auth connects to a database to store data. The database will be used to store data such as users, sessions, and more. Plugins can also define their own database tables to store data.

You can pass a database connection to Better Auth by passing a supported database instance in the database options. You can learn more about supported database adapters in the [Other relational databases](/docs/adapters/other-relational-databases) documentation.

<Callout type="info">
Better Auth also works without any database. For more details, see [Stateless Session Management](/docs/concepts/session-management#stateless-session-management).
</Callout>

## CLI

Better Auth comes with a CLI tool to manage database migrations and generate schema.

### Running Migrations

The cli checks your database and prompts you to add missing tables or update existing ones with new columns. This is only supported for the built-in Kysely adapter. For other adapters, you can use the `generate` command to create the schema and handle the migration through your ORM.

```package-install
npx auth@latest migrate
```

<Callout type="info">
For PostgreSQL users: The migrate command supports non-default schemas. It automatically detects your `search_path` configuration and creates tables in the correct schema. See [PostgreSQL adapter](/docs/adapters/postgresql#use-a-non-default-schema) for details.
</Callout>

### Generating Schema

Better Auth also provides a `generate` command to generate the schema required by Better Auth. The `generate` command creates the schema required by Better Auth. If you're using a database adapter like Prisma or Drizzle, this command will generate the right schema for your ORM. If you're using the built-in Kysely adapter, it will generate an SQL file you can run directly on your database.

```package-install
npx auth@latest generate
```

See the [CLI](/docs/concepts/cli) documentation for more information on the CLI.

<Callout>
  If you prefer adding tables manually, you can do that as well. The core schema
  required by Better Auth is described below and you can find additional schema
  required by plugins in the plugin documentation.
</Callout>

### Programmatic Migrations

In some environments (like Cloudflare Workers, serverless functions, or custom deployment setups), running the CLI may not be possible or practical. In these cases, you can run migrations programmatically from within your application code.

Better Auth provides a `getMigrations` function that you can use to generate and run migrations programmatically. This is particularly useful when:

- You're deploying to edge environments (Cloudflare Workers, Deno Deploy, etc.)
- Your environment variables are only available at runtime (not at build time)
- You need to run migrations as part of your application startup or through a custom endpoint

#### Using `getMigrations`

The `getMigrations` function is available from `better-auth/db/migration` and works with the built-in Kysely adapter (SQLite, PostgreSQL, MySQL, MSSQL).

```typescript
import { getMigrations } from "better-auth/db/migration";

const { toBeCreated, toBeAdded, runMigrations, compileMigrations } = await getMigrations(authConfig);

// Check what migrations are needed
console.log("Tables to create:", toBeCreated);
console.log("Fields to add:", toBeAdded);

// Run migrations
await runMigrations();

// Or get the SQL to run manually
const sql = await compileMigrations();
console.log(sql);
```

#### Example: Cloudflare Workers Migration Endpoint

For Cloudflare Workers using D1 (SQLite), you can create a migration endpoint that runs when your worker starts or through a manual trigger:

```typescript title="src/index.ts"
import { Hono } from "hono";
import { auth } from "./auth"; // your auth instance
import { getMigrations } from "better-auth/db/migration";

const app = new Hono<{ Bindings: Env }>();

// Migration endpoint - call this once to set up your database
app.post("/migrate", async (c) => {
  const env = c.env;

  // Create auth config with runtime environment
  const authConfig = {
    database: env.DB, // D1 database binding
    // ... rest of your auth config
  };

  try {
    const { toBeCreated, toBeAdded, runMigrations } = await getMigrations(authConfig);

    if (toBeCreated.length === 0 && toBeAdded.length === 0) {
      return c.json({ message: "No migrations needed" });
    }

    await runMigrations();

    return c.json({
      message: "Migrations completed successfully",
      created: toBeCreated.map(t => t.table),
      added: toBeAdded.map(t => t.table)
    });
  } catch (error) {
    return c.json({ error: error instanceof Error ? error.message : String(error) }, 500);
  }
});

// Your normal auth endpoints
app.on(["POST", "GET"], "/api/auth/*", (c) => {
  return auth.handler(c.req.raw);
});

export default app;
```

<Callout type="warn">
**Important Limitations**

Programmatic migrations currently work **only** with:
- Built-in database adapters (SQLite/D1, PostgreSQL, MySQL, MSSQL) using the Kysely adapter
- Does **not** work with Prisma or Drizzle ORM adapters

For Prisma or Drizzle in Cloudflare Workers, see the [Cloudflare Workers](#cloudflare-workers-with-prisma-drizzle) section below.
</Callout>

#### Cloudflare Workers with Prisma/Drizzle

If you're using Prisma or Drizzle with Cloudflare Workers, you have a few options:

1. **Use `cloudflare:workers` import** (Recommended for newer Cloudflare projects):

   Cloudflare now supports importing environment variables from `cloudflare:workers`, which allows you to access `env` at the top level:

   ```typescript title="auth.ts"
   import { env } from "cloudflare:workers";
   import { drizzle } from "drizzle-orm/d1";

   export const auth = betterAuth({
     database: drizzle(env.DB),
     // ... rest of config
   });
   ```

   With this approach, you can run the standard CLI commands:
   
   <Tabs items={["migrate", "generate"]}>
      <Tab value="migrate">
      ```package-install
      npx auth@latest migrate
      ```
      </Tab>
      <Tab value="generate">
      ```package-install
      npx auth@latest generate
      ```
      </Tab>
    </Tabs>

2. **Use `process.env` with compatibility flag**:

   Add the `nodejs_compat_populate_process_env` compatibility flag to your `wrangler.toml`:

   ```toml title="wrangler.toml"
   compatibility_flags = ["nodejs_compat_populate_process_env"]
   ```

   Then use `process.env` in your auth config:

   ```typescript title="auth.ts"
   import { drizzle } from "drizzle-orm/d1";

   export const auth = betterAuth({
     database: drizzle(process.env.DB as any),
     // ... rest of config
   });
   ```

   After setting this up, run the CLI commands as normal:

   ```package-install
   npx auth@latest generate
   ```

3. **Generate schema locally and push manually**:

   Run the generate command locally with a mock configuration, then use your ORM's push/migrate commands to apply the schema.

<Callout type="info">
See the [Hono integration documentation](/docs/integrations/hono#cloudflare-workers) for a complete example of using Better Auth with Cloudflare Workers.
</Callout>

## Secondary Storage

Secondary storage in Better Auth allows you to use key-value stores for managing session data, rate limiting counters, etc. This can be useful when you want to offload the storage of intensive records to a high performance storage or even RAM.

### Implementation

To use secondary storage, implement the `SecondaryStorage` interface:

```typescript
interface SecondaryStorage {
  get: (key: string) => Promise<unknown>;
  set: (key: string, value: string, ttl?: number) => Promise<void>;
  delete: (key: string) => Promise<void>;
}
```

Then, provide your implementation to the `betterAuth` function:

```typescript title="auth.ts"
import { betterAuth } from "better-auth";

betterAuth({
  // ... other options
  secondaryStorage: {
    // Your implementation here
  },
});
```

### Redis Storage

Better Auth provides an official Redis storage package that uses [ioredis](https://github.com/redis/ioredis):

```bash
npm install @better-auth/redis-storage ioredis
# or
pnpm add @better-auth/redis-storage ioredis
```

**Usage:**

```typescript
import { betterAuth } from "better-auth";
import { Redis } from "ioredis";
import { redisStorage } from "@better-auth/redis-storage";

const redis = new Redis({
	host: "localhost",
	port: 6379,
});

export const auth = betterAuth({
	// ... other options
	secondaryStorage: redisStorage({
		client: redis,
		kxeyPrefix: "better-auth:", // optional, defaults to "better-auth:"
	}),
});
```

The Redis storage supports all ioredis connection modes including standalone, cluster, and sentinel configurations.

**Manual Implementation:**

If you prefer to implement your own Redis secondary storage, here's a basic example:

```typescript title="auth.ts"
import { createClient } from "redis";
import { betterAuth } from "better-auth";

const redis = createClient();
await redis.connect();

export const auth = betterAuth({
	// ... other options
	secondaryStorage: {
		get: async (key) => {
			return await redis.get(key);
		},
		set: async (key, value, ttl) => {
			if (ttl) await redis.set(key, value, { EX: ttl });
			else await redis.set(key, value);
		},
		delete: async (key) => {
			await redis.del(key);
		}
	}
});
```

This implementation allows Better Auth to use Redis for storing session data and rate limiting counters. You can also add prefixes to the keys names.

## Core Schema

Better Auth requires the following tables to be present in the database. The types are in `typescript` format. You can use corresponding types in your database.

### User

Table Name: `user`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each user",
      isPrimaryKey: true,
    },
    {
      name: "name",
      type: "string",
      description: "User's chosen display name",
    },
    {
      name: "email",
      type: "string",
      description: "User's email address for communication and login",
    },
    {
      name: "emailVerified",
      type: "boolean",
      description: "Whether the user's email is verified",
    },
    {
      name: "image",
      type: "string",
      description: "User's image url",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the user account was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of the last update to the user's information",
    },
  ]}
/>

### Session

Table Name: `session`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each session",
      isPrimaryKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "token",
      type: "string",
      description: "The unique session token",
      isUnique: true,
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "The time when the session expires",
    },
    {
      name: "ipAddress",
      type: "string",
      description: "The IP address of the device",
      isOptional: true,
    },
    {
      name: "userAgent",
      type: "string",
      description: "The user agent information of the device",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the session was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the session was updated",
    },
  ]}
/>

### Account

Table Name: `account`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each account",
      isPrimaryKey: true,
    },
    {
      name: "userId",
      type: "string",
      description: "The ID of the user",
      isForeignKey: true,
    },
    {
      name: "accountId",
      type: "string",
      description:
        "The ID of the account as provided by the SSO or equal to userId for credential accounts",
    },
    {
      name: "providerId",
      type: "string",
      description: "The ID of the provider",
    },
    {
      name: "accessToken",
      type: "string",
      description: "The access token of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "refreshToken",
      type: "string",
      description: "The refresh token of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "accessTokenExpiresAt",
      type: "Date",
      description: "The time when the access token expires",
      isOptional: true,
    },
    {
      name: "refreshTokenExpiresAt",
      type: "Date",
      description: "The time when the refresh token expires",
      isOptional: true,
    },
    {
      name: "scope",
      type: "string",
      description: "The scope of the account. Returned by the provider",
      isOptional: true,
    },
    {
      name: "idToken",
      type: "string",
      description: "The ID token returned from the provider",
      isOptional: true,
    },
    {
      name: "password",
      type: "string",
      description:
        "The password of the account. Mainly used for email and password authentication",
      isOptional: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the account was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the account was updated",
    },
  ]}
/>

### Verification

Table Name: `verification`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for each verification",
      isPrimaryKey: true,
    },
    {
      name: "identifier",
      type: "string",
      description: "The identifier for the verification request",
    },
    {
      name: "value",
      type: "string",
      description: "The value to be verified",
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "The time when the verification request expires",
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the verification request was created",
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the verification request was updated",
    },
  ]}
/>

## Custom Tables

Better Auth allows you to customize the table names and column names for the core schema. You can also extend the core schema by adding additional fields to the user and session tables.

### Custom Table Names

You can customize the table names and column names for the core schema by using the `modelName` and `fields` properties in your auth config:

```ts title="auth.ts"
export const auth = betterAuth({
  user: {
    modelName: "users",
    fields: {
      name: "full_name",
      email: "email_address",
    },
  },
  session: {
    modelName: "user_sessions",
    fields: {
      userId: "user_id",
    },
  },
});
```

<Callout>
  Type inference in your code will still use the original field names (e.g.,
  `user.name`, not `user.full_name`).
</Callout>

To customize table names and column name for plugins, you can use the `schema` property in the plugin config:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { twoFactor } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    twoFactor({
      schema: {
        user: {
          fields: {
            twoFactorEnabled: "two_factor_enabled",
            secret: "two_factor_secret",
          },
        },
      },
    }),
  ],
});
```

### Extending Core Schema

Better Auth provides a type-safe way to extend the `user` and `session` schemas. You can add custom fields to your auth config, and the CLI will automatically update the database schema. These additional fields will be properly inferred in functions like `useSession`, `signUp.email`, and other endpoints that work with user or session objects.

To add custom fields, use the `additionalFields` property in the `user` or `session` object of your auth config. The `additionalFields` object uses field names as keys, with each value being a `FieldAttributes` object containing:

- `type`: The data type of the field (e.g., "string", "number", "boolean").
- `required`: A boolean indicating if the field is mandatory.
- `defaultValue`: The default value for the field (note: this only applies in the JavaScript layer; in the database, the field will be optional).
- `input`: This determines whether a value can be provided when creating a new record (default: `true`). If there are additional fields, like `role`, that should not be provided by the user during signup, you can set this to `false`.

Here's an example of how to extend the user schema with additional fields:

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  user: {
    additionalFields: {
      role: {
        type: ["user", "admin"],
        required: false,
        defaultValue: "user",
        input: false, // don't allow user to set role
      },
      lang: {
        type: "string",
        required: false,
        defaultValue: "en",
      },
    },
  },
});
```

Now you can access the additional fields in your application logic.

```ts
//on signup
const res = await auth.api.signUpEmail({
	body: {
		email: 'test@example.com',
		password: 'password',
		name: 'John Doe',
		lang: 'fr',
	},
});

//user object
res.user.role; // > "admin"
res.user.lang; // > "fr"
```

<Callout>
  See the
  [TypeScript](/docs/concepts/typescript#inferring-additional-fields-on-client)
  documentation for more information on how to infer additional fields on the
  client side.
</Callout>

If you're using social / OAuth providers, you may want to provide `mapProfileToUser` to map the profile data to the user object. So, you can populate additional fields from the provider's profile.

**Example: Mapping Profile to User For `firstName` and `lastName`**

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  socialProviders: {
    github: {
      clientId: "YOUR_GITHUB_CLIENT_ID",
      clientSecret: "YOUR_GITHUB_CLIENT_SECRET",
      mapProfileToUser: (profile) => {
        return {
          firstName: profile.name.split(" ")[0],
          lastName: profile.name.split(" ")[1],
        };
      },
    },
    google: {
      clientId: "YOUR_GOOGLE_CLIENT_ID",
      clientSecret: "YOUR_GOOGLE_CLIENT_SECRET",
      mapProfileToUser: (profile) => {
        return {
          firstName: profile.given_name,
          lastName: profile.family_name,
        };
      },
    },
  },
});
```

### ID Generation

Better Auth by default will generate unique IDs for users, sessions, and other entities.
You can customize ID generation behavior using the `advanced.database.generateId` option.

#### Option 1: Let Database Generate IDs

Setting `generateId` to `false` allows your database handle all ID generation: (outside of `generateId` being `serial` and some cases of `generateId` being `uuid`)

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { db } from "./db";

export const auth = betterAuth({
  database: db,
  advanced: {
    database: {
      generateId: false, // "serial" for auto-incrementing numeric IDs
    },
  },
});
```

#### Option 2: Custom ID Generation Function

Use a function to generate IDs. You can return `false` or `undefined` from the function to let the database generate the ID for specific models:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { db } from "./db";

export const auth = betterAuth({
  database: db,
  advanced: {
    database: {
      generateId: (options) => {
        // Let database auto-generate for specific models
        if (options.model === "user" || options.model === "users") {
          return false; // Let database generate ID
        }
        // Generate UUIDs for other tables
        return crypto.randomUUID();
      },
    },
  },
});
```

<Callout type="info">
  **Important**: Returning `false` or `undefined` from the `generateId` function lets the database handle ID generation for that specific model. Setting `generateId: false` (without a function) disables ID generation for **all** tables.
</Callout>

#### Option 3: Consistent Custom ID Generator

Generate the same type of ID for all tables:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { db } from "./db";

export const auth = betterAuth({
  database: db,
  advanced: {
    database: {
      generateId: () => crypto.randomUUID(),
    },
  },
});
```

### Numeric IDs

If you prefer auto-incrementing numeric IDs, you can set the `advanced.database.generateId` option to `"serial"`.
Doing this will disable Better-Auth from generating IDs for any table, and will assume your
database will generate the numeric ID automatically.

When enabled, the Better-Auth CLI will generate or migrate the schema with the `id` field as a numeric type for your database
with auto-incrementing attributes associated with it.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { db } from "./db";

export const auth = betterAuth({
  database: db,
  advanced: {
    database: {
      generateId: "serial",
    },
  },
});
```

<Callout type="info">
  Better-Auth will continue to infer the type of the `id` field as a `string` for the database, but will
  automatically convert it to a numeric type when fetching or inserting data from the database.

  It's likely when grabbing `id` values returned from Better-Auth that you'll receive a string version of a number,
  this is normal. It's also expected that all id values passed to Better-Auth (eg via an endpoint body) is expected to be a string.
</Callout>

### UUIDs

If you prefer UUIDs for the `id` field, you can set the `advanced.database.generateId` option to `"uuid"`.
By default, Better-Auth will generate UUIDs for the `id` field for all tables, except adapters that use `PostgreSQL` where we allow the
database to generate the UUID automatically.

By enabling this option, the Better-Auth CLI will generate or migrate the schema with the `id` field as a UUID type for your database.
If the `uuid` type is not supported, we will generate a normal `string` type for the `id` field.

### Mixed ID Types

If you need different ID types across tables (e.g., integer IDs for users, UUID strings for sessions/accounts/verification), use a `generateId` callback function.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { db } from "./db";

export const auth = betterAuth({
  database: db,
  user: {
    modelName: "users", // PostgreSQL: id serial primary key
  },
  session: {
    modelName: "session", // PostgreSQL: id text primary key
  },
  advanced: {
    database: {
      // Do NOT set useNumberId - it's global and affects all tables
      generateId: (options) => {
        if (options.model === "user" || options.model === "users") {
          return false; // Let PostgreSQL serial generate it
        }
        return crypto.randomUUID(); // UUIDs for session, account, verification
      },
    },
  },
});
```

This configuration allows you to:
- Use database auto-increment (serial, auto_increment, etc.) for the users table
- Generate UUIDs for all other tables (session, account, verification)
- Maintain compatibility with existing schemas that use different ID types

<Callout type="info">
  **Use Case**: This is particularly useful when migrating from other authentication providers (like Clerk) where you have existing users with integer IDs but want UUID strings for new tables.
</Callout>

### Database Hooks

Database hooks allow you to define custom logic that can be executed during the lifecycle of core database operations in Better Auth. You can create hooks for the following models: **user**, **session**, and **account**.

<Callout type="warn">
  Additional fields are supported, however full type inference for these fields isn't yet supported.
  Improved type support is planned.
</Callout>

There are two types of hooks you can define:

#### 1. Before Hook

- **Purpose**: This hook is called before the respective entity (user, session, or account) is created, updated, or deleted.
- **Behavior**: If the hook returns `false`, the operation will be aborted. And If it returns a data object, it'll replace the original payload.

#### 2. After Hook

- **Purpose**: This hook is called after the respective entity is created or updated.
- **Behavior**: You can perform additional actions or modifications after the entity has been successfully created or updated.

**Example Usage**

```typescript title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  databaseHooks: {
    user: {
      create: {
        before: async (user, ctx) => {
          // Modify the user object before it is created
          return {
            data: {
              // Ensure to return Better-Auth named fields, not the original field names in your database.
              ...user,
              firstName: user.name.split(" ")[0],
              lastName: user.name.split(" ")[1],
            },
          };
        },
        after: async (user) => {
          //perform additional actions, like creating a stripe customer
        },
      },
      delete: {
        before: async (user, ctx) => {
          console.log(`User ${user.email} is being deleted`);
          if (user.email.includes("admin")) {
            return false; // Abort deletion
          }

          return true; // Allow deletion
        },
        after: async (user) => {
          console.log(`User ${user.email} has been deleted`);
        },
      },
    },
    session: {
      delete: {
        before: async (session, ctx) => {
          console.log(`Session ${session.token} is being deleted`);
          if (session.userId === "admin-user-id") {
            return false; // Abort deletion
          }
          return true; // Allow deletion
        },
        after: async (session) => {
          console.log(`Session ${session.token} has been deleted`);
        },
      },
    },
  },
});
```


#### Throwing Errors

If you want to stop the database hook from proceeding, you can throw errors using the `APIError` class imported from `better-auth/api`.

```typescript title="auth.ts"
import { betterAuth } from "better-auth";
import { APIError } from "better-auth/api";

export const auth = betterAuth({
  databaseHooks: {
    user: {
      create: {
        before: async (user, ctx) => {
          if (user.isAgreedToTerms === false) {
            // Your special condition.
            // Send the API error.
            throw new APIError("BAD_REQUEST", {
              message: "User must agree to the TOS before signing up.",
            });
          }
          return {
            data: user,
          };
        },
      },
    },
  },
});
```

#### Using the Context Object

The context object (`ctx`), passed as the second argument to the hook, contains useful information. For `update` hooks, this includes the current `session`, which you can use to access the logged-in user's details.

```typescript title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  databaseHooks: {
    user: {
      update: {
        before: async (data, ctx) => {
          // You can access the session from the context object.
          if (ctx.context.session) {
            console.log("User update initiated by:", ctx.context.session.userId);
          }
          return { data };
        },
      },
    },
  },
});
```

Much like standard hooks, database hooks also provide a `ctx` object that offers a variety of useful properties. Learn more in the [Hooks Documentation](/docs/concepts/hooks#ctx).

## Plugins Schema

Plugins can define their own tables in the database to store additional data. They can also add columns to the core tables to store additional data. For example, the two factor authentication plugin adds the following columns to the `user` table:

- `twoFactorEnabled`: Whether two factor authentication is enabled for the user.
- `twoFactorSecret`: The secret key used to generate TOTP codes.
- `twoFactorBackupCodes`: Encrypted backup codes for account recovery.

To add new tables and columns to your database, you have two options:

`CLI`: Use the migrate or generate command. These commands will scan your database and guide you through adding any missing tables or columns.
`Manual Method`: Follow the instructions in the plugin documentation to manually add tables and columns.

Both methods ensure your database schema stays up to date with your plugins' requirements.


## Experimental Joins

Since Better-Auth version `1.4` we've introduced experimental database joins support.
This allows Better-Auth to perform multiple database queries in a single request, reducing the number of database roundtrips.
Over 50 endpoints support joins, and we're constantly adding more.

Under the hood, our adapter system supports joins natively, meaning even if you don't enable experimental joins,
it will still fallback to making multiple database queries and combining the results.

To enable joins, update your auth config with the following:

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  experimental: { joins: true }
});
```

The Better-Auth `1.4` CLI will generate DrizzleORM and PrismaORM relationships for you so if you do not have those already
be sure to update your schema by running our migrate or generate CLI commands to be up-to-date with the latest required schema.

It's very important to read the documentation regarding experimental joins for your given adapter:

- [DrizzleORM](/docs/adapters/drizzle#joins-experimental)
- [PrismaORM](/docs/adapters/prisma#joins-experimental)
- [SQLite](/docs/adapters/sqlite#joins-experimental)
- [MySQL](/docs/adapters/mysql#joins-experimental)
- [PostgreSQL](/docs/adapters/postgresql#joins-experimental)
- [MSSQL](/docs/adapters/mssql#joins-experimental)
- [MongoDB](/docs/adapters/mongo#joins-experimental)
---
title: Cookies
description: Learn how cookies are used in Better Auth.
---

Cookies are used to store data such as session tokens, session data, OAuth state, and more. All cookies are signed using the `secret` key provided in the auth options or the `BETTER_AUTH_SECRET` environment variable.

### Cookie Prefix

By default, Better Auth cookies follow the format `${prefix}.${cookie_name}`. The default prefix is "better-auth". You can change the prefix by setting `cookiePrefix` in the `advanced` object of the auth options.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    advanced: {
        cookiePrefix: "my-app"
    }
})
```

### Custom Cookies

All cookies are `httpOnly` and `secure` when the server is running in production mode.

If you want to set custom cookie names and attributes, you can do so by setting `cookieOptions` in the `advanced` object of the auth options.

By default, Better Auth uses the following cookies:

- `session_token` to store the session token
- `session_data` to store the session data if cookie cache is enabled
- `dont_remember` to store the flag when `rememberMe` is disabled

Plugins may also use cookies to store data. For example, the Two Factor Authentication plugin uses the `two_factor` cookie to store the two-factor authentication state.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    advanced: {
        cookies: {
            session_token: {
                name: "custom_session_token",
                attributes: {
                    // Set custom cookie attributes
                }
            },
        }
    }
})
```

### Cross Subdomain Cookies

Sometimes you may need to share cookies across subdomains. 
For example, if you authenticate on `auth.example.com`, you may also want to access the same session on `app.example.com`.

<Callout type="warn">
The `domain` attribute controls which domains can access the cookie. Setting it to your root domain (e.g. `example.com`) makes the cookie accessible across all subdomains. For security, follow these guidelines:

1. Only enable cross-subdomain cookies if it's necessary
2. Set the domain to the most specific scope needed (e.g. `app.example.com` instead of `.example.com`)
3. Be cautious of untrusted subdomains that could potentially access these cookies
4. Consider using separate domains for untrusted services (e.g. `status.company.com` vs `app.company.com`)
</Callout>

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    advanced: {
        crossSubDomainCookies: {
            enabled: true,
            domain: "app.example.com", // your domain
        },
    },
    trustedOrigins: [
        'https://example.com',
        'https://app1.example.com',
        'https://app2.example.com',
    ],
})
```
### Secure Cookies

By default, cookies are secure only when the server is running in production mode. You can force cookies to be always secure by setting `useSecureCookies` to `true` in the `advanced` object in the auth options.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    advanced: {
        useSecureCookies: true
    }
})
```

## Safari, ITP, and Cross-Domain Setups

Safari includes a privacy feature called Intelligent Tracking Prevention (ITP) that blocks third-party cookies.

If your Better Auth API is hosted on a different domain than your frontend, Safari may block authentication cookies entirely.

Example that breaks in Safari:

```
Frontend: https://app.domainB.com
API:      https://domainA.com
```

If your frontend makes a request like:

```ts
fetch("https://domainA.com/api/auth/get-session", {
  credentials: "include"
})
```

Safari treats `domainA.com` as a third-party and blocks its cookies. Which can result in sessions not persisting,
`Set-Cookie` being ignored, users appearing logged out after login or auth working in Chrome but failing in Safari.

To solve this, there are two solutions:
1. Using a reverse proxy to proxy the request to the API.
2. Using a shared parent domain.

### Using a Reverse Proxy

Instead of calling your API directly, you can proxy it through the same domain as your frontend.

For example, instead of calling:
```
https://domainA.com/api/auth/*
```

you can call:
```
https://app.domainA.com/api/auth/*
```

Then configure your hosting provider to proxy the request to your actual API server.

This makes the request appear first-party to Safari, allowing cookies to function correctly.

#### Example with Netlify

```toml title="netlify.toml"
[[redirects]]
  from = "/api/*"
  to = "https://domainA.com/api/:splat"
  status = 200
  force = true
```

#### Example with Vercel

```ts title="vercel.json"
{
  "rewrites": [
    {
      "source": "/api/:path*",
      "destination": "https://domainA.com/api/:path*"
    }
  ]
}
```

### Using a Shared Parent Domain

You can also use a shared parent domain to allow cookies to be shared across subdomains:

```
https://app.example.com
https://api.example.com
```

Then, enable cross-subdomain cookies with the domain:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    advanced: {
        crossSubDomainCookies: {
            enabled: true,
            domain: "example.com",
        },
    },
})
```

Learn more about cross-subdomain cookies in the [documentation above](#cross-subdomain-cookies).

This avoids Safari treating the API as third-party.---
title: Hooks
description: Better Auth Hooks let you customize BetterAuth's behavior
---

Hooks in Better Auth let you "hook into" the lifecycle and execute custom logic. They provide a way to customize Better Auth's behavior without writing a full plugin. 

<Callout>
We highly recommend using hooks if you need to make custom adjustments to an endpoint rather than making another endpoint outside of Better Auth.
</Callout>

## Before Hooks

**Before hooks** run *before* an endpoint is executed. Use them to modify requests, pre validate data, or return early.

### Example: Enforce Email Domain Restriction

This hook ensures that users can only sign up if their email ends with `@example.com`:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { createAuthMiddleware, APIError } from "better-auth/api";

export const auth = betterAuth({
    hooks: {
        before: createAuthMiddleware(async (ctx) => {
            if (ctx.path !== "/sign-up/email") {
                return;
            }
            if (!ctx.body?.email.endsWith("@example.com")) {
                throw new APIError("BAD_REQUEST", {
                    message: "Email must end with @example.com",
                });
            }
        }),
    },
});
```

### Example: Modify Request Context

To adjust the request context before proceeding:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { createAuthMiddleware } from "better-auth/api";

export const auth = betterAuth({
    hooks: {
        before: createAuthMiddleware(async (ctx) => {
            if (ctx.path === "/sign-up/email") {
                return {
                    context: {
                        ...ctx,
                        body: {
                            ...ctx.body,
                            name: "John Doe",
                        },
                    }
                };
            }
        }),
    },
});
```

## After Hooks

**After hooks** run *after* an endpoint is executed. Use them to modify responses.

### Example: Send a notification to your channel when a new user is registered

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { createAuthMiddleware } from "better-auth/api";
import { sendMessage } from "@/lib/notification"

export const auth = betterAuth({
    hooks: {
        after: createAuthMiddleware(async (ctx) => {
            if(ctx.path.startsWith("/sign-up")){
                const newSession = ctx.context.newSession;
                if(newSession){
                    sendMessage({
                        type: "user-register",
                        name: newSession.user.name,
                    })
                }
            }
        }),
    },
});
```

## Ctx

When you call `createAuthMiddleware` a `ctx` object is passed that provides a lot of useful properties. Including:

- **Path:** `ctx.path` to get the current endpoint path.
- **Body:** `ctx.body` for parsed request body (available for POST requests).
- **Headers:** `ctx.headers` to access request headers.
- **Request:** `ctx.request` to access the request object (may not exist in server-only endpoints).
- **Query Parameters:** `ctx.query` to access query parameters.
- **Context**: `ctx.context` auth related context, useful for accessing new session, auth cookies configuration, password hashing, config...

and more.

### Request Response

This utilities allows you to get request information and to send response from a hook. 

#### JSON Responses

Use `ctx.json` to send JSON responses:

```ts
import { createAuthMiddleware } from "better-auth/api";

const hook = createAuthMiddleware(async (ctx) => {
    return ctx.json({
        message: "Hello World",
    });
});
```

#### Redirects

Use `ctx.redirect` to redirect users:

```ts
import { createAuthMiddleware } from "better-auth/api";

const hook = createAuthMiddleware(async (ctx) => {
    throw ctx.redirect("/sign-up/name");
});
```

#### Cookies

- Set cookies: `ctx.setCookies` or `ctx.setSignedCookie`.
- Get cookies: `ctx.getCookies` or `ctx.getSignedCookie`.

Example:

```ts
import { createAuthMiddleware } from "better-auth/api";

const hook = createAuthMiddleware(async (ctx) => {
    ctx.setCookies("my-cookie", "value");
    await ctx.setSignedCookie("my-signed-cookie", "value", ctx.context.secret, {
        maxAge: 1000,
    });

    const cookie = ctx.getCookies("my-cookie");
    const signedCookie = await ctx.getSignedCookie("my-signed-cookie");
});
```

#### Errors

Throw errors with `APIError` for a specific status code and message:

```ts
import { createAuthMiddleware, APIError } from "better-auth/api";

const hook = createAuthMiddleware(async (ctx) => {
    throw new APIError("BAD_REQUEST", {
        message: "Invalid request",
    });
});
```



### Context

The `ctx` object contains another `context` object inside that's meant to hold contexts related to auth. Including a newly created session on after hook, cookies configuration, password hasher and so on. 

#### New Session

The newly created session after an endpoint is run. This only exist in after hook.

```ts title="auth.ts"
import { createAuthMiddleware } from "better-auth/api";

createAuthMiddleware(async (ctx) => {
    const newSession = ctx.context.newSession
});
```

#### Returned

The returned value from the hook is passed to the next hook in the chain.

```ts title="auth.ts"
import { createAuthMiddleware } from "better-auth/api";

createAuthMiddleware(async (ctx) => {
    const returned = ctx.context.returned; //this could be a successful response or an APIError
});
```

#### Response Headers

The response headers added by endpoints and hooks that run before this hook.

```ts title="auth.ts"
import { createAuthMiddleware } from "better-auth/api";

createAuthMiddleware(async (ctx) => {
    const responseHeaders = ctx.context.responseHeaders;
});
```

#### Predefined Auth Cookies

Access BetterAuth’s predefined cookie properties:

```ts title="auth.ts"
import { createAuthMiddleware } from "better-auth/api";

createAuthMiddleware(async (ctx) => {
    const cookieName = ctx.context.authCookies.sessionToken.name;
});
```

#### Secret

You can access the `secret` for your auth instance on `ctx.context.secret`

#### Password

The password object provider `hash` and `verify`

- `ctx.context.password.hash`: let's you hash a given password.
- `ctx.context.password.verify`: let's you verify given `password` and a `hash`.

#### Adapter

Adapter exposes the adapter methods used by Better Auth. Including `findOne`, `findMany`, `create`, `delete`, `update` and `updateMany`. You generally should use your actually `db` instance from your orm rather than this adapter.


#### Internal Adapter

These are calls to your db that perform specific actions. `createUser`, `createSession`, `updateSession`...

This may be useful to use instead of using your db directly to get access to `databaseHooks`, proper `secondaryStorage` support and so on. If you're make a query similar to what exist in this internal adapter actions it's worth a look.

#### generateId

You can use `ctx.context.generateId` to generate Id for various reasons.

## Reusable Hooks

If you need to reuse a hook across multiple endpoints, consider creating a plugin. Learn more in the [Plugins Documentation](/docs/concepts/plugins).
---
title: Email
description: Learn how to use email with Better Auth.
---

Email is a key part of Better Auth, required for all users regardless of their authentication method. Better Auth provides email and password authentication out of the box, and a lot of utilities to help you manage email verification, password reset, and more.


## Email Verification

Email verification is a security feature that ensures users provide a valid email address. It helps prevent spam and abuse by confirming that the email address belongs to the user. In this guide, you'll get a walk through of how to implement token based email verification in your app.
To use otp based email verification, check out the [OTP Verification](/docs/plugins/email-otp) guide.

### Adding Email Verification to Your App

To enable email verification, you need to pass a function that sends a verification email with a link.

- **sendVerificationEmail**: This function is triggered when email verification starts. It accepts a data object with the following properties:
  - `user`: The user object containing the email address.
  - `url`: The verification URL the user must click to verify their email.
  - `token`: The verification token used to complete the email verification to be used when implementing a custom verification URL.

and a `request` object as the second parameter.

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { sendEmail } from './email'; // your email sending function

export const auth = betterAuth({
    emailVerification: {
        sendVerificationEmail: async ({ user, url, token }, request) => {
            void sendEmail({
                to: user.email,
                subject: 'Verify your email address',
                text: `Click the link to verify your email: ${url}`
            })
        }
    }
})
```

<Callout type="warn">
  Avoid awaiting the email sending to prevent 
  timing attacks. On serverless platforms, use `waitUntil` or similar to ensure the email is sent.
</Callout>

### Triggering Email Verification

You can initiate email verification in several ways:

#### 1. During Sign-up

To automatically send a verification email at signup, set `emailVerification.sendOnSignUp` to `true`. 

```ts title="auth.ts"
import { betterAuth } from 'better-auth';

export const auth = betterAuth({
    emailVerification: {
        sendOnSignUp: true
    }
})
```

This sends a verification email when a user signs up. For social logins, email verification status is read from the SSO.

<Callout>
    With `sendOnSignUp` enabled, when the user logs in with an SSO that does not claim the email as verified, Better Auth will dispatch a verification email, but the verification is not required to login even when `requireEmailVerification` is enabled.
</Callout>

#### 2. Require Email Verification

If you enable require email verification, users must verify their email before they can log in. And every time a user tries to sign in, `sendVerificationEmail` is called.

<Callout>
    This only works if you have `sendVerificationEmail` implemented, if `sendOnSignIn` is set to true and if the user is trying to sign in with email and password.
</Callout>

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sendEmail } from './email'; // your email sending function

export const auth = betterAuth({
  emailVerification: {
    sendVerificationEmail: async ({ user, url }) => {
      void sendEmail({
        to: user.email,
        subject: "Verify your email address",
        text: `Click the link to verify your email: ${url}`,
      });
    },
    sendOnSignIn: true,
  },
  emailAndPassword: {
    requireEmailVerification: true,
  },
});
```

If a user tries to sign in without verifying their email, you can handle the error and show a message to the user.

```ts title="auth-client.ts"
await authClient.signIn.email({
    email: "email@example.com",
    password: "password"
}, {
    onError: (ctx) => {
        // Handle the error
        if(ctx.error.status === 403) {
            alert("Please verify your email address")
        }
        //you can also show the original error message
        alert(ctx.error.message)
    }
})
```

#### 3. Manually

You can also manually trigger email verification by calling `sendVerificationEmail`.

```ts
await authClient.sendVerificationEmail({
    email: "user@email.com",
    callbackURL: "/" // The redirect URL after verification
})
```

### Verifying the Email

If the user clicks the provided verification URL, their email is automatically verified, and they are redirected to the `callbackURL`.

For manual verification, you can send the user a custom link with the `token` and call the `verifyEmail` function.

```ts
await authClient.verifyEmail({
    query: {
        token: "" // Pass the token here
    }
})
```

### Auto Sign In After Verification

To sign in the user automatically after they successfully verify their email, set the `autoSignInAfterVerification` option to `true`:

```ts
import { betterAuth } from "better-auth";

const auth = betterAuth({
    //...your other options
    emailVerification: {
        autoSignInAfterVerification: true
    }
})
```

### Callback after successful email verification

You can run custom code immediately after a user verifies their email using the `afterEmailVerification` callback. This is useful for any side-effects you want to trigger, like granting access to special features or logging the event.

The `afterEmailVerification` function runs automatically when a user's email is confirmed, receiving the `user` object and `request` details so you can perform actions for that specific user.

Here's how you can set it up:

```ts title="auth.ts"
import { betterAuth } from 'better-auth';

export const auth = betterAuth({
    emailVerification: {
        async afterEmailVerification(user, request) {
            // Your custom logic here, e.g., grant access to premium features
            console.log(`${user.email} has been successfully verified!`);
        }
    }
})
```

## Password Reset Email

Password reset allows users to reset their password if they forget it. Better Auth provides a simple way to implement password reset functionality.

You can enable password reset by passing a function that sends a password reset email with a link.

```ts title="auth.ts"
import { betterAuth } from 'better-auth';
import { sendEmail } from './email'; // your email sending function

export const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
        sendResetPassword: async ({ user, url, token }, request) => {
            void sendEmail({
                to: user.email,
                subject: 'Reset your password',
                text: `Click the link to reset your password: ${url}`
            })
        }
    }
})
```

<Callout type="warn">
  Avoid awaiting the email sending to prevent 
  timing attacks. On serverless platforms, use `waitUntil` or similar to ensure the email is sent.
</Callout>

Check out the [Email and Password](/docs/authentication/email-password#request-password-reset) guide for more details on how to implement password reset in your app.
Also you can check out the [Otp verification](/docs/plugins/email-otp#reset-password-with-otp) guide for how to implement password reset with OTP in your app.
---
title: Client
description: Better Auth client library for authentication.
---

Better Auth offers a client library compatible with popular frontend frameworks like React, Vue, Svelte, and more. This client library includes a set of functions for interacting with the Better Auth server. Each framework's client library is built on top of a core client library that is framework-agnostic, so that all methods and hooks are consistently available across all client libraries.

## Installation

If you haven't already, install better-auth.

```package-install 
npm i better-auth
```

## Create Client Instance

Import `createAuthClient` from the package for your framework (e.g., "better-auth/react" for React). Call the function to create your client. Pass the base URL of your auth server. If the auth server is running on the same domain as your client, you can skip this step.

<Callout type="info">
If you're using a different base path other than `/api/auth`, make sure to pass the whole URL, including the path. (e.g., `http://localhost:3000/custom-path/auth`)
</Callout>


<Tabs items={["react", "vue", "svelte", "solid", 
  "vanilla"]} defaultValue="react">
    <Tab value="vanilla">
            ```ts  title="lib/auth-client.ts" 
            import { createAuthClient } from "better-auth/client" // [!code highlight]
            export const authClient = createAuthClient({
                baseURL: "http://localhost:3000" // The base URL of your auth server // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="react" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts"  
            import { createAuthClient } from "better-auth/react" // [!code highlight]
            export const authClient = createAuthClient({
                baseURL: "http://localhost:3000" // The base URL of your auth server // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="vue" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts" 
            import { createAuthClient } from "better-auth/vue" // [!code highlight]
            export const authClient = createAuthClient({
                baseURL: "http://localhost:3000" // The base URL of your auth server // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="svelte" title="lib/auth-client.ts"> 
            ```ts  title="lib/auth-client.ts" 
            import { createAuthClient } from "better-auth/svelte" // [!code highlight]
            export const authClient = createAuthClient({
                baseURL: "http://localhost:3000" // The base URL of your auth server // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="solid" title="lib/auth-client.ts">
            ```ts title="lib/auth-client.ts" 
            import { createAuthClient } from "better-auth/solid" // [!code highlight]
            export const authClient = createAuthClient({
                baseURL: "http://localhost:3000" // The base URL of your auth server // [!code highlight]
            })
            ```
    </Tab>
</Tabs>

## Usage

Once you've created your client instance, you can use the client to interact with the Better Auth server. The client provides a set of functions by default and they can be extended with plugins.

**Example: Sign In**

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
const authClient = createAuthClient()

await authClient.signIn.email({
    email: "test@user.com",
    password: "password1234"
})
```

### Hooks

In addition to the standard methods, the client provides hooks to easily access different reactive data. Every hook is available in the root object of the client and they all start with `use`.

**Example: useSession**


<Tabs items={["React", "Vue","Svelte", "Solid"]} defaultValue="react">
    <Tab value="React">
        ```tsx title="user.tsx"
        //make sure you're using the react client
        import { createAuthClient } from "better-auth/react"
        const { useSession } = createAuthClient() // [!code highlight]
    
        export function User() {
            const {
                data: session,
                isPending, //loading state
                error, //error object 
                refetch //refetch the session
            } = useSession()
            return (
                //...
            )
        }
        ```
    </Tab>

    <Tab value="Vue">
        ```vue title="user.vue"
        <script lang="ts" setup>
        import { authClient } from '@/lib/auth-client'
        const session = authClient.useSession()
        </script>
        <template>
            <div>
                <button v-if="!session.data" @click="() => authClient.signIn.social({
                    provider: 'github'
                })">
                    Continue with GitHub
                </button>
                <div>
                    <pre>{{ session.data }}</pre>
                    <button v-if="session.data" @click="authClient.signOut()">
                        Sign out
                    </button>
                </div>
            </div>
        </template>
        ```
        </Tab>

        <Tab value="Svelte">
            ```svelte title="user.svelte"
            <script lang="ts">
            import { authClient } from "$lib/auth-client";
            const session = authClient.useSession();
            </script>

            <div
                style="display: flex; flex-direction: column; gap: 10px; border-radius: 10px; border: 1px solid #4B453F; padding: 20px; margin-top: 10px;"
            >
                <div>
                {#if $session.data}
                    <div>
                    <p>
                        {$session.data.user.name}
                    </p>
                    <p>
                        {$session.data.user.email}
                    </p>
                    <button
                        onclick={async () => {
                        await authClient.signOut();
                        }}
                    >
                        Signout
                    </button>
                    </div>
                {:else}
                    <button
                    onclick={async () => {
                        await authClient.signIn.social({
                        provider: "github",
                        });
                    }}
                    >
                    Continue with GitHub
                    </button>
                {/if}
                </div>
            </div>
            ```
        </Tab>

        <Tab value="Solid">
            ```tsx title="user.tsx"
            import { authClient } from "~/lib/auth-client";
            import { Show } from 'solid-js';

            export default function Home() {
                const session = authClient.useSession()
                return (
                    <Show
                        when={session()}
                        fallback={<button onClick={toggle}>Log in</button>}
                    >
                        <button onClick={toggle}>Log out</button>
                    </Show>
                ); 
            }
            ```
            </Tab>
</Tabs>

### Fetch Options

The client uses a library called [better fetch](https://better-fetch.vercel.app) to make requests to the server. 

Better fetch is a wrapper around the native fetch API that provides a more convenient way to make requests. It's created by the same team behind Better Auth and is designed to work seamlessly with it.

You can pass any default fetch options to the client by passing `fetchOptions` object to the `createAuthClient`.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"

const authClient = createAuthClient({
    fetchOptions: {
        //any better-fetch options
    },
})
```

### Disabling Default Fetch Plugins

The auth client includes default fetch plugins that handle browser-specific behaviors like automatic redirects. For non-browser environments (e.g., React Native/Expo), you can disable these by setting `disableDefaultFetchPlugins` to `true`:

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"

const authClient = createAuthClient({
    disableDefaultFetchPlugins: true,
})
```         

You can also pass fetch options to most of the client functions. Either as the second argument or as a property in the object.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.signIn.email({
    email: "email@email.com",
    password: "password1234",
}, {
    onSuccess(ctx) {
            //      
    }
})

//or

await authClient.signIn.email({
    email: "email@email.com",
    password: "password1234",
    fetchOptions: {
        onSuccess(ctx) {
            //      
        }
    },
})
```

### Disabling Hook Rerenders

Certain endpoints, upon successful response, will trigger atom signals and cause hooks like `useSession` to rerender.
This is useful for keeping your UI in sync with authentication state changes.

However, there are cases where you might want to make an endpoint call without triggering hook rerenders.
For example, when updating user preferences that don't affect the session, or when you want to manually control when hooks update.

You can disable hook rerenders for a specific endpoint call by setting `disableSignal: true` in the fetch options:

```ts
import { authClient } from "@/lib/auth-client"

// As the second argument
await authClient.updateUser({
    name: "New Name"
}, {
    disableSignal: true
})

// Or within fetchOptions
await authClient.updateUser({
    name: "New Name",
    fetchOptions: {
        disableSignal: true
    }
})
```

When `disableSignal` is set to `true`, the endpoint call will complete successfully,
but hooks like `useSession` won't automatically rerender. You can manually trigger a refetch if needed:

```ts
import { authClient } from "@/lib/auth-client"

const { refetch } = authClient.useSession()

await authClient.updateUser({
    name: "New Name"
}, {
    disableSignal: true,
    onSuccess() {
        // Manually refetch session if needed
        refetch()
    }
})
```

### Handling Errors

Most of the client functions return a response object with the following properties:
- `data`: The response data.
- `error`: The error object if there was an error.

The error object contains the following properties:
- `message`: The error message. (e.g., "Invalid email or password")
- `status`: The HTTP status code.
- `statusText`: The HTTP status text.

```ts
import { authClient } from "@/lib/auth-client"

const { data, error } = await authClient.signIn.email({
    email: "email@email.com",
    password: "password1234"
})
if (error) {
    //handle error
}
```

If the action accepts a `fetchOptions` option, you can pass an `onError` callback to handle errors.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.signIn.email({
    email: "email@email.com",
    password: "password1234",
}, {
    onError(ctx) {
        //handle error
    }
})

//or
await authClient.signIn.email({
    email: "email@email.com",
    password: "password1234",
    fetchOptions: {
        onError(ctx) {
            //handle error
        }
    }
})
```

Hooks like `useSession` also return an error object if there was an error fetching the session. On top of that, they also return an `isPending` property to indicate if the request is still pending.

```ts
import { useSession } from "@/lib/auth-client"

const { data, error, isPending } = useSession()
if (error) {
    //handle error
}
```

#### Error Codes

The client instance contains $ERROR_CODES object that contains all the error codes returned by the server. You can use this to handle error translations or custom error messages.

```ts title="auth-client.ts"
const authClient = createAuthClient();

type ErrorTypes = Partial<
	Record<
		keyof typeof authClient.$ERROR_CODES,
		{
			en: string;
			es: string;
		}
	>
>;

const errorCodes = {
	USER_ALREADY_EXISTS: {
		en: "user already registered",
		es: "usuario ya registrado",
	},
} satisfies ErrorTypes;

const getErrorMessage = (code: string, lang: "en" | "es") => {
	if (code in errorCodes) {
		return errorCodes[code as keyof typeof errorCodes][lang];
	}
	return "";
};


const { error } = await authClient.signUp.email({
	email: "user@email.com",
	password: "password",
	name: "User",
});
if(error?.code){
    alert(getErrorMessage(error.code, "en"));
}
```

### Plugins

You can extend the client with plugins to add more functionality. Plugins can add new functions to the client or modify existing ones. 

**Example: Magic Link Plugin**
```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
import { magicLinkClient } from "better-auth/client/plugins"

const authClient = createAuthClient({
    plugins: [
        magicLinkClient()
    ]
})
```

once you've added the plugin, you can use the new functions provided by the plugin.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.signIn.magicLink({
    email: "test@email.com"
})
```
---
title: Dynamic Base URL
description: Configure Better Auth to work with multiple domains and preview deployments.
---

When deploying to platforms like Vercel, your application can run on multiple URLs simultaneously:
- Custom domains (e.g., `myapp.com`, `www.myapp.com`)
- Preview deployments (e.g., `my-app-abc123.vercel.app`)
- Branch previews (e.g., `feature-branch.myapp.com`)

Better Auth supports dynamic base URL resolution using an **allowlist-based approach** that determines the correct URL from each incoming request.

## Basic Usage

Configure `baseURL` as an object with an `allowedHosts` array:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    baseURL: {
        allowedHosts: [
            "myapp.com",
            "www.myapp.com",
            "*.vercel.app",
        ],
    },
})
```

When a request comes in, Better Auth extracts the host from the `x-forwarded-host` or `host` header and validates it against your allowlist. If the host matches, that URL is used as the base URL for the request.

## Wildcard Patterns

The `allowedHosts` array supports wildcard patterns:

| Pattern | Matches |
|---------|---------|
| `myapp.com` | Exact match only |
| `*.vercel.app` | Any subdomain of vercel.app |
| `preview-*.myapp.com` | Subdomains starting with `preview-` |
| `localhost:*` | localhost on any port |

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: [
            "myapp.com",           // Production
            "*.vercel.app",        // All Vercel previews
            "preview-*.myapp.com", // Custom preview subdomains
            "localhost:3000",      // Local development
        ],
    },
})
```

## Fallback URL

By default, if the incoming host doesn't match any pattern in `allowedHosts`, Better Auth throws an error. You can provide a fallback URL instead:

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: ["myapp.com", "*.vercel.app"],
        fallback: "https://myapp.com",
    },
})
```

With a fallback configured:
- Matching hosts use the derived URL
- Non-matching hosts use the fallback URL (no error thrown)

<Callout type="warn">
Use fallbacks carefully. Silent fallbacks can mask misconfigurations. Consider whether throwing an error (the default) is more appropriate for your use case.
</Callout>

## Protocol Configuration

Control the protocol used when constructing URLs:

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: ["myapp.com", "localhost:3000"],
        protocol: "https", // Always use HTTPS
    },
})
```

| Value | Behavior |
|-------|----------|
| `"https"` | Always use HTTPS |
| `"http"` | Always use HTTP |
| `"auto"` | Derive from `x-forwarded-proto` header, then request URL; defaults to HTTPS if neither is available |
| Not set | Same as `"auto"` |

<Callout type="info">
The `protocol` setting controls how the **URL is constructed** for each request. For the cookie `Secure` flag, Better Auth uses `protocol: "https"` → secure, `protocol: "http"` → not secure, and for `"auto"` or unset → falls back to `NODE_ENV === "production"`. You can always override this with `advanced.useSecureCookies`.
</Callout>

For mixed environments (local dev + production), you can use environment variables:

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: ["myapp.com", "localhost:3000"],
        protocol: process.env.NODE_ENV === "development" ? "http" : "https",
    },
})
```

## Trusted Origins Integration

When you configure `allowedHosts`, Better Auth automatically adds them to `trustedOrigins`. This means:

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: ["myapp.com", "*.vercel.app"],
    },
})

// Automatically adds to trustedOrigins:
// - "https://myapp.com"
// - "https://*.vercel.app"
```

You don't need to duplicate your allowed hosts in both configurations.

## Static Base URL (Backwards Compatible)

The traditional static string configuration still works:

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: "https://myapp.com",
})
```

This is recommended when your application runs on a single, known URL.

## Common Patterns

### Vercel Deployment

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: [
            "myapp.com",        // Production custom domain
            "www.myapp.com",    // WWW variant
            "*.vercel.app",     // All preview deployments
        ],
    },
})
```

### Development + Production

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: [
            "localhost:3000",
            "localhost:5173",
            "myapp.com",
            "*.vercel.app",
        ],
        protocol: process.env.NODE_ENV === "development" ? "http" : "https",
    },
})
```

### Multiple Production Domains

```ts title="auth.ts"
export const auth = betterAuth({
    baseURL: {
        allowedHosts: [
            "myapp.com",
            "myapp.co.uk",
            "myapp.eu",
        ],
    },
})
```

## Cross-Subdomain Cookies

If you need to share cookies across subdomains, you can enable `crossSubDomainCookies` without specifying a static `domain`. Better Auth automatically derives the cookie domain from the resolved host of each request.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    baseURL: {
        allowedHosts: [
            "auth.example1.com",
            "auth.example2.com",
        ],
        protocol: "https",
    },
    advanced: {
        crossSubDomainCookies: {
            enabled: true,
        },
    },
})
```

With this configuration:
- A request to `auth.example1.com` sets cookies with `Domain=auth.example1.com`
- A request to `auth.example2.com` sets cookies with `Domain=auth.example2.com`

If you want to use the same domain for all hosts, you can set `domain` explicitly:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    baseURL: {
        allowedHosts: ["auth.example1.com", "auth.example2.com"],
        protocol: "https",
    },
    advanced: {
        crossSubDomainCookies: {
            enabled: true,
            domain: ".example.com", // always use this domain regardless of host
        },
    },
})
```

<Callout type="info">
With a static `baseURL` string, `crossSubDomainCookies` derives the domain from that string at init time. With dynamic base URL, the domain is computed per-request from the resolved host. Learn more about cross-subdomain cookies in the [Cookies](/docs/concepts/cookies#cross-subdomain-cookies) documentation.
</Callout>

## Security Considerations

<Callout type="info">
Dynamic base URL uses an **allowlist-based approach** for security. Only hosts explicitly listed in `allowedHosts` are accepted.
</Callout>

1. **Allowlist is mandatory** - You cannot accept arbitrary hosts
2. **Headers are validated** - The `x-forwarded-host` and `host` headers are sanitized before use
3. **Explicit patterns only** - No automatic platform detection; you must add each pattern
4. **Clear errors** - Unknown hosts throw descriptive errors (unless fallback is set)

This differs from some other auth libraries that auto-trust platforms or accept any header value. Better Auth prioritizes security over convenience.

## Configuration Reference

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `allowedHosts` | `string[]` | Required | List of allowed host patterns |
| `fallback` | `string` | - | URL to use when host doesn't match |
| `protocol` | `"http" \| "https" \| "auto"` | `"auto"` | Protocol for URL construction. `"auto"` derives from request headers, defaults to HTTPS |
---
title: TypeScript
description: Better Auth TypeScript integration.
---

Better Auth is designed to be type-safe. Both the client and server are built with TypeScript, allowing you to easily infer types.


## TypeScript Config

### Strict Mode

Better Auth is designed to work with TypeScript's strict mode. We recommend enabling strict mode in your TypeScript config file:

```json title="tsconfig.json"
{
  "compilerOptions": {
    "strict": true
  }
}
```

if you can't set `strict` to `true`, you can enable `strictNullChecks`:

```json title="tsconfig.json"
{
  "compilerOptions": {
    "strictNullChecks": true,
  }
}
```

<Callout type="warn">
If you're running into issues with TypeScript inference exceeding maximum length the compiler will serialize,
then please make sure you're following the instructions above, as well as ensuring that both `declaration` and `composite` are not enabled.
</Callout>

## Inferring Types

Both the client SDK and the server offer types that can be inferred using the `$Infer` property. Plugins can extend base types like `User` and `Session`, and you can use `$Infer` to infer these types. Additionally, plugins can provide extra types that can also be inferred through `$Infer`.

```ts title="auth-client.ts" 
import { createAuthClient } from "better-auth/client"

const authClient = createAuthClient()

export type Session = typeof authClient.$Infer.Session
```

The `Session` type includes both `session` and `user` properties. The user property represents the user object type, and the `session` property represents the `session` object type.

You can also infer types on the server side.

```ts title="auth.ts" 
import { betterAuth } from "better-auth"
import Database from "better-sqlite3"

export const auth = betterAuth({
    database: new Database("database.db")
})

type Session = typeof auth.$Infer.Session
```


## Additional Fields

Better Auth allows you to add additional fields to the user and session objects. All additional fields are properly inferred and available on the server and client side.

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import Database from "better-sqlite3"

export const auth = betterAuth({
    database: new Database("database.db"),
    user: {
       additionalFields: {
          role: {
              type: "string",
              input: false
            } 
        }
    }
   
})

type Session = typeof auth.$Infer.Session
```

In the example above, we added a `role` field to the user object. This field is now available on the `Session` type.


### The `input` property

The `input` property in an additional field configuration determines whether the field should be included in the user input. This property defaults to `true`, meaning the field will be part of the user input during operations like registration.

To prevent a field from being part of the user input, you must explicitly set `input: false`:

```ts
additionalFields: {
    role: {
        type: "string",
        input: false
    }
}
```

When `input` is set to `false`, the field will be excluded from user input, preventing users from passing a value for it.

By default, additional fields are included in the user input, which can lead to security vulnerabilities if not handled carefully. For fields that should not be set by the user, like a `role`, it is crucial to set `input: false` in the configuration.

### Inferring Additional Fields on Client

To make sure proper type inference for additional fields on the client side, you need to inform the client about these fields. There are two approaches to achieve this, depending on your project structure:

1. For Monorepo or Single-Project Setups

If your server and client code reside in the same project, you can use the `inferAdditionalFields` plugin to automatically infer the additional fields from your server configuration.

```ts title="auth-client.ts"
import { inferAdditionalFields } from "better-auth/client/plugins";
import { createAuthClient } from "better-auth/client";
import type { auth } from "@/lib/auth"; // Import the auth instance as a type

export const authClient = createAuthClient({
  plugins: [inferAdditionalFields<typeof auth>()],
});
```

2. For Separate Client-Server Projects

If your client and server are in separate projects, you'll need to manually specify the additional fields when creating the auth client.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { inferAdditionalFields } from "better-auth/client/plugins";

export const authClient = createAuthClient({
  plugins: [inferAdditionalFields({
      user: {
        role: {
          type: "string"
        }
      }
  })],
});
```
---
title: API
description: Better Auth API.
---

When you create a new Better Auth instance, it provides you with an `api` object. This object exposes every endpoint that exists in your Better Auth instance. And you can use this to interact with Better Auth server side.

Any endpoint added to Better Auth, whether from plugins or the core, will be accessible through the `api` object.

## Calling API Endpoints on the Server

To call an API endpoint on the server, import your `auth` instance and call the endpoint using the `api` object.

```ts title="server.ts"
import { betterAuth } from "better-auth";
import { headers } from "next/headers";

export const auth = betterAuth({
    //...
})

// calling get session on the server
await auth.api.getSession({
    headers: await headers() // some endpoints might require headers
})
```

### Body, Headers, Query

Unlike the client, the server needs the values to be passed as an object with the key `body` for the body, `headers` for the headers, and `query` for query parameters.

```ts title="server.ts"
import { auth } from "@/lib/auth"

await auth.api.getSession({
    headers: await headers() // headers containing the user's session token
})

await auth.api.signInEmail({
    body: {
        email: "john@doe.com",
        password: "password"
    },
    headers: await headers() // optional but would be useful to get the user IP, user agent, etc.
})

await auth.api.verifyEmail({
    query: {
        token: "my_token"
    }
})
```

<Callout>
Better Auth API endpoints are built on top of [better-call](https://github.com/bekacru/better-call), a tiny web framework that lets you call REST API endpoints as if they were regular functions and allows us to easily infer client types from the server.
</Callout>

### Getting `headers` and `Response` Object

When you invoke an API endpoint on the server, it will return a standard JavaScript object or array directly as it's just a regular function call.

But there are times when you might want to get the `headers` or the `Response` object instead. For example, if you need to get the cookies or the headers.

#### Getting `headers`

To get the `headers`, you can pass the `returnHeaders` option to the endpoint.

```ts title="server.ts"
import { auth } from "@/lib/auth"

const { headers, response } = await auth.api.signUpEmail({
	returnHeaders: true,
	body: {
		email: "john@doe.com",
		password: "password",
		name: "John Doe",
	},
});
```

The `headers` will be a `Headers` object, which you can use to get the cookies or the headers.

```ts
const cookies = headers.get("set-cookie");
const headers = headers.get("x-custom-header");
```

#### Getting `Response` Object

To get the `Response` object, you can pass the `asResponse` option to the endpoint.

```ts title="server.ts"
import { auth } from "@/lib/auth"

const response = await auth.api.signInEmail({
    body: {
        email: "",
        password: ""
    },
    asResponse: true
})
```

### Error Handling

When you call an API endpoint on the server, it will throw an error if the request fails. You can catch the error and handle it as you see fit. The error instance is an instance of `APIError`.

```ts title="server.ts"
import { auth } from "@/lib/auth"
import { APIError, isAPIError } from "better-auth/api";

try {
    await auth.api.signInEmail({
        body: {
            email: "",
            password: ""
        }
    })
} catch (error) {
    if (isAPIError(error)) {
        console.log(error.message, error.status)
    }
}
```
---
title: Rate Limit
description: How to limit the number of requests a user can make to the server in a given time period.
---

Better Auth includes a built-in rate limiter to help manage traffic and prevent abuse. By default, in production mode, the rate limiter is set to:

- Window: 60 seconds
- Max Requests: 100 requests

<Callout type="warning">
Server-side requests made using `auth.api` aren't affected by rate limiting. Rate limits only apply to client-initiated requests.
</Callout>

You can easily customize these settings by passing the rateLimit object to the betterAuth function.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    rateLimit: {
        window: 10, // time window in seconds
        max: 100, // max requests in the window
    },
})
```

Rate limiting is disabled in development mode by default. In order to enable it, set `enabled` to `true`:

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    rateLimit: {
        enabled: true,
        //...other options
    },
})
```

In addition to the default settings, Better Auth provides custom rules for specific paths. For example:
- `/sign-in/email`: Is limited to 3 requests within 10 seconds.

In addition, plugins also define custom rules for specific paths. For example, `twoFactor` plugin has custom rules:
- `/two-factor/verify`: Is limited to 3 requests within 10 seconds.

These custom rules ensure that sensitive operations are protected with stricter limits.

## Configuring Rate Limit

### Connecting IP Address

Rate limiting uses the connecting IP address to track the number of requests made by a user. The
default header checked is `x-forwarded-for`, which is commonly used in production environments. If
you are using a different header to track the user's IP address, you'll need to specify it.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other options
    advanced: {
        ipAddress: {
          ipAddressHeaders: ["cf-connecting-ip"], // Cloudflare specific header example
      },
    },
    rateLimit: {
        enabled: true,
        window: 60, // time window in seconds
        max: 100, // max requests in the window
    },
})
```

#### IPv6 Address Support

Better Auth automatically normalizes IPv6 addresses to prevent bypass attacks where attackers use different representations of the same IPv6 address (e.g., `2001:db8::1` vs `2001:0db8:0000:0000:0000:0000:0000:0001`). This ensures that all representations of the same IPv6 address are treated as the same for rate limiting purposes.

Additionally, IPv4-mapped IPv6 addresses (e.g., `::ffff:192.0.2.1`) are automatically converted to their IPv4 form (`192.0.2.1`) to prevent attackers from bypassing rate limits by switching between IPv4 and IPv6 representations.

#### IPv6 Subnet Rate Limiting

By default, IPv6 addresses are rate limited individually (using the full /128 address). However, since IPv6 typically allocates large address blocks to single users, attackers could potentially bypass rate limits by rotating through multiple IPv6 addresses from their allocation.

To prevent this, you can configure rate limiting to apply to IPv6 subnets instead of individual addresses:

```ts title="auth.ts"
export const auth = betterAuth({
    //...other options
    advanced: {
        ipAddress: {
            ipv6Subnet: 64, // Rate limit by /64 subnet instead of individual addresses
        },
    },
    rateLimit: {
        enabled: true,
        window: 60,
        max: 100,
    },
})
```

Common IPv6 subnet prefix lengths:
- `128` (default): Individual IPv6 address - most restrictive
- `64`: /64 subnet - typical home/business allocation
- `48`: /48 subnet - larger network allocation
- `32`: /32 subnet - ISP-level allocation

<Callout type="info">
IPv6 subnet configuration only affects IPv6 addresses. IPv4 addresses are always rate limited individually.
</Callout>

### Rate Limit Window

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other options
    rateLimit: {
        window: 60, // time window in seconds
        max: 100, // max requests in the window
    },
})
```

You can also pass custom rules for specific paths.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other options
    rateLimit: {
        window: 60, // time window in seconds
        max: 100, // max requests in the window
        customRules: {
            "/sign-in/email": {
                window: 10,
                max: 3,
            },
            "/two-factor/*": async (request)=> {
                // custom function to return rate limit window and max
                return {
                    window: 10,
                    max: 3,
                }
            }
        },
    },
})
```

If you like to disable rate limiting for a specific path, you can set it to `false` or return `false` from the custom rule function.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other options
    rateLimit: {
        customRules: {
            "/get-session": false,
        },
    },
})
```

### Storage

By default, rate limit data is stored in memory, which may not be suitable for many use cases, particularly in serverless environments. To address this, you can use a database, secondary storage, or custom storage for storing rate limit data.

**Using Database**

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other options
    rateLimit: {
        storage: "database",
        modelName: "rateLimit", //optional by default "rateLimit" is used
    },
})
```

Make sure to run `migrate` to create the rate limit table in your database:

```package-install
npx auth@latest migrate
```

<Callout type="info">
  The `migrate` command only works if you're using the built-in Kysely adapter. If you're using Prisma, Drizzle, or another ORM, run `npx auth@latest generate` first, then apply the schema using your ORM's migration tool. For more info, see the [Better Auth CLI](/docs/concepts/cli).
</Callout>

**Using Secondary Storage**

If a [Secondary Storage](/docs/concepts/database#secondary-storage) has been configured you can use that to store rate limit data.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other options
    rateLimit: {
		storage: "secondary-storage"
    },
})
```

**Custom Storage**

If none of the above solutions suits your use case you can implement a `customStorage`.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other options
    rateLimit: {
        customStorage: {
            get: async (key) => {
                // get rate limit data
            },
            set: async (key, value) => {
                // set rate limit data
            },
        },
    },
})
```

## Handling Rate Limit Errors

When a request exceeds the rate limit, Better Auth returns the following header:

- `X-Retry-After`: The number of seconds until the user can make another request.

To handle rate limit errors on the client side, you can manage them either globally or on a per-request basis. Since Better Auth clients wrap over Better Fetch, you can pass `fetchOptions` to handle rate limit errors

**Global Handling**

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";

export const authClient = createAuthClient({
    fetchOptions: {
        onError: async (context) => {
            const { response } = context;
            if (response.status === 429) {
                const retryAfter = response.headers.get("X-Retry-After");
                console.log(`Rate limit exceeded. Retry after ${retryAfter} seconds`);
            }
        },
    }
})
```


**Per Request Handling**

```ts title="auth-client.ts"
import { authClient } from "./auth-client";

await authClient.signIn.email({
    fetchOptions: {
        onError: async (context) => {
            const { response } = context;
            if (response.status === 429) {
                const retryAfter = response.headers.get("X-Retry-After");
                console.log(`Rate limit exceeded. Retry after ${retryAfter} seconds`);
            }
        },
    }
})
```

### Schema

If you are using a database to store rate limit data you need this schema:

Table Name: `rateLimit`

<DatabaseTable
    fields={[
        { 
        name: "id", 
        type: "string", 
        description: "Database ID",
        isPrimaryKey: true
        },
        { 
        name: "key", 
        type: "string", 
        description: "Unique identifier for each rate limit key",
        },
        { 
        name: "count", 
        type: "integer", 
        description: "Time window in seconds" 
        },
        { 
        name: "lastRequest", 
        type: "bigint", 
        description: "Max requests in the window" 
        }]}
    />
---
title: User & Accounts
description: User and account management.
---

Beyond authenticating users, Better Auth also provides a set of methods to manage users. This includes, updating user information, changing passwords, and more.

The user table stores the authentication data of the user [Click here to view the schema](/docs/concepts/database#user).

The user table can be extended using [additional fields](/docs/concepts/database#extending-core-schema) or by plugins to store additional data.

## Update User

### Update User Information

To update user information, you can use the `updateUser` function provided by the client. The `updateUser` function takes an object with the following properties:

```ts
import { authClient } from "@/lib/auth-client"

await authClient.updateUser({
    image: "https://example.com/image.jpg",
    name: "John Doe",
})
```
### Change Email

To allow users to change their email, first enable the `changeEmail` feature, which is disabled by default. Set `changeEmail.enabled` to `true`:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sendEmail } from './email'; // your email sending function

export const auth = betterAuth({
    user: {
        changeEmail: {
            enabled: true,
        }
    },
    emailVerification: {
        // Required to send the verification email
        sendVerificationEmail: async ({ user, url, token }) => {
            void sendEmail({
                to: user.email,
            })
        }
    }
})
```

<Callout type="warn">
  Avoid awaiting the email sending to prevent 
  timing attacks. On serverless platforms, use `waitUntil` or similar to ensure the email is sent.
</Callout>

By default, when a user requests to change their email, a verification email is sent to the **new** email address.
The email is only updated after the user verifies the new email.


#### Confirming with Current Email

For added security, you can require users to confirm the change via their **current** email before
the verification email is sent to the new address. To do this, provide the `sendChangeEmailConfirmation` function.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sendEmail } from './email'; // your email sending function

export const auth = betterAuth({
    user: {
        changeEmail: {
            enabled: true,
            sendChangeEmailConfirmation: async ({ user, newEmail, url, token }, request) => { 
                void sendEmail({
                    to: user.email, // Sent to the CURRENT email
                    subject: 'Approve email change',
                    text: `Click the link to approve the change to ${newEmail}: ${url}`
                })
            }
        }
    },
    // ...
})
```

#### Updating Without Verification

If you want to allow users to update their email immediately without verification (only if their current email is NOT verified), you can enable `updateEmailWithoutVerification`.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    user: {
        changeEmail: {
            enabled: true,
            updateEmailWithoutVerification: true
        }
    }
})
```

<Callout type="warn">
    If `updateEmailWithoutVerification` is false (default), the email will not be updated until the new email is verified, even if the current email is unverified.
</Callout>

#### Client Usage

Use the `changeEmail` function on the client to initiate the process.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.changeEmail({
    newEmail: "new-email@email.com",
    callbackURL: "/dashboard", // to redirect after verification
});
```
 
### Change Password
A user's password isn't stored in the user table. Instead, it's stored in the account table. To change the password of a user, you can use one of the following approaches:


<APIMethod path="/change-password" method="POST" requireSession>
```ts
type changePassword = {
    /**
     * The new password to set 
     */
    newPassword: string = "newpassword1234"
    /**
     * The current user password 
     */
    currentPassword: string = "oldpassword1234"
    /**
     * When set to true, all other active sessions for this user will be invalidated
     */
    revokeOtherSessions?: boolean = true
}
```
</APIMethod>

### Set Password

If a user was registered using OAuth or other providers, they won't have a password or a credential account. In this case, you can use the `setPassword` action to set a password for the user. For security reasons, this function can only be called from the server. We recommend having users go through a 'forgot password' flow to set a password for their account.

```ts title="set-password.ts"
import { auth } from "@/lib/auth"

await auth.api.setPassword({
    body: {
        newPassword: "new-password",
    },
    headers: await headers() // headers containing the user's session token
});
```
### Verify Password

The `verifyPassword` function allows you to verify a user's current password. This is useful for confirming user identity before performing sensitive operations like updating security settings. This function can only be called from the server.

```ts title="verify-password.ts"
import { auth } from "@/lib/auth"

await auth.api.verifyPassword({
    body: {
        password: "user-password" // required
    },
    headers: await headers() // headers containing the user's session token
});
```
<Callout type="info">
For OAuth users who don't have passwords, consider using email verification or fresh session checks for sensitive operations instead.
</Callout>

## Delete User

Better Auth provides a utility to hard delete a user from your database. It's disabled by default, but you can enable it easily by passing `enabled:true`

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    //...other config
    user: {
        deleteUser: { // [!code highlight]
            enabled: true // [!code highlight]
        } // [!code highlight]
    }
})
```

Once enabled, you can call `authClient.deleteUser` to permanently delete user data from your database.

### Adding Verification Before Deletion

For added security, you’ll likely want to confirm the user’s intent before deleting their account. A common approach is to send a verification email. Better Auth provides a `sendDeleteAccountVerification` utility for this purpose. 
This is especially needed if you have OAuth setup and want them to be able to delete their account without forcing them to login again for a fresh session.

Here’s how you can set it up:

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    user: {
        deleteUser: {
            enabled: true,
            sendDeleteAccountVerification: async (
                {
                    user,   // The user object
                    url, // The auto-generated URL for deletion
                    token  // The verification token  (can be used to generate custom URL)
                },
                request  // The original request object (optional)
            ) => {
                // Your email sending logic here
                // Example: sendEmail(data.user.email, "Verify Deletion", data.url);
            },
        },
    },
});
```

**How callback verification works:**

- **Callback URL**: The URL provided in `sendDeleteAccountVerification` is a pre-generated link that deletes the user data when accessed.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.deleteUser({
    callbackURL: "/goodbye" // you can provide a callback URL to redirect after deletion
});
```

- **Authentication Check**: The user must be signed in to the account they’re attempting to delete.
If they aren’t signed in, the deletion process will fail. 

If you have sent a custom URL, you can use the `deleteUser` method with the token to delete the user.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.deleteUser({
    token
});
```

### Authentication Requirements

To delete a user, the user must meet one of the following requirements:

1. A valid password

if the user has a password, they can delete their account by providing the password.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.deleteUser({
    password: "password"
});
```

2. Fresh session

The user must have a `fresh` session token, meaning the user must have signed in recently. This is checked if the password is not provided.

<Callout type="warn">
By default `session.freshAge` is set to `60 * 60 * 24` (1 day). You can change this value by passing the `session` object to the `auth` configuration. If it is set to `0`, the freshness check is disabled. It is recommended not to disable this check if you are not using email verification for deleting the account.
</Callout>

```ts
import { authClient } from "@/lib/auth-client"

await authClient.deleteUser();
```

3. Enabled email verification (needed for OAuth users)

As OAuth users don't have a password, we need to send a verification email to confirm the user's intent to delete their account. If you have already added the `sendDeleteAccountVerification` callback, you can just call the `deleteUser` method without providing any other information.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.deleteUser();
```

4. If you have a custom delete account page and sent that url via the `sendDeleteAccountVerification` callback.
Then you need to call the `deleteUser` method with the token to complete the deletion.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.deleteUser({
    token
});
```

### Callbacks

**beforeDelete**: This callback is called before the user is deleted. You can use this callback to perform any cleanup or additional checks before deleting the user.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    user: {
        deleteUser: {
            enabled: true,
            beforeDelete: async (user) => {
                // Perform any cleanup or additional checks here
            },
        },
    },
});
```
you can also throw `APIError` to interrupt the deletion process.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { APIError } from "better-auth/api";

export const auth = betterAuth({
    user: {
        deleteUser: {
            enabled: true,
            beforeDelete: async (user, request) => {
                if (user.email.includes("admin")) {
                    throw new APIError("BAD_REQUEST", {
                        message: "Admin accounts can't be deleted",
                    });
                }
            },
        },
    },
});
```

**afterDelete**: This callback is called after the user is deleted. You can use this callback to perform any cleanup or additional actions after the user is deleted.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    user: {
        deleteUser: {
            enabled: true,
            afterDelete: async (user, request) => {
                // Perform any cleanup or additional actions here
            },
        },
    },
});
```

## Accounts

Better Auth supports multiple authentication methods. Each authentication method is called a provider. For example, email and password authentication is a provider, Google authentication is a provider, etc.

When a user signs in using a provider, an account is created for the user. The account stores the authentication data returned by the provider. This data includes the access token, refresh token, and other information returned by the provider.

The account table stores the authentication data of the user [Click here to view the schema](/docs/concepts/database#account)


### List User Accounts

To list user accounts you can use `client.user.listAccounts` method. Which will return all accounts associated with a user.

```ts
import { authClient } from "@/lib/auth-client"

const accounts = await authClient.listAccounts();
```

### Token Encryption

Better Auth doesn’t encrypt tokens by default and that’s intentional. We want you to have full control over how encryption and decryption are handled, rather than baking in behavior that could be confusing or limiting. If you need to store encrypted tokens (like accessToken or refreshToken), you can use databaseHooks to encrypt them before they’re saved to your database.

```ts
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    databaseHooks: {
        account: {
            create: {
                before(account, context) {
                    const withEncryptedTokens = { ...account };
                    if (account.accessToken) {
                        const encryptedAccessToken = encrypt(account.accessToken)  // [!code highlight]
                        withEncryptedTokens.accessToken = encryptedAccessToken;
                    }
                    if (account.refreshToken) {
                        const encryptedRefreshToken = encrypt(account.refreshToken); // [!code highlight]
                        withEncryptedTokens.refreshToken = encryptedRefreshToken;
                    }
                    return {
                        data: withEncryptedTokens
                    }
                },
            }
        }
    }
})
```

Then whenever you retrieve back the account make sure to decrypt the tokens before using them.

### Account Linking

Account linking is [enabled by default](https://www.better-auth.com/docs/reference/options#accountlinking) and lets users associate multiple authentication methods with a single account. With Better Auth, users can connect additional social sign-ons or OAuth providers to their existing accounts if the provider confirms the user's email as verified.

If account linking is disabled, no accounts can be linked, regardless of the provider or email verification status.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    account: {
        accountLinking: {
            enabled: false, 
        }
    },
});
```

#### Forced Linking

You can specify a list of "trusted providers." When a user logs in using a trusted provider, their account will be automatically linked even if the provider doesn’t confirm the email verification status. Use this with caution as it may increase the risk of account takeover.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    account: {
        accountLinking: {
            enabled: true,
            trustedProviders: ["google", "github"]
        }
    },
});
```

#### Manually Linking Accounts

Users already signed in can manually link their account to additional social providers or credential-based accounts.

- **Linking Social Accounts:** Use the `linkSocial` method on the client to link a social provider to the user's account.

  ```ts
  import { authClient } from "@/lib/auth-client"

  await authClient.linkSocial({
      provider: "google", // Provider to link
      callbackURL: "/callback" // Callback URL after linking completes
  });
  ```

  You can also request specific scopes when linking a social account, which can be different from the scopes used during the initial authentication:

  ```ts
  import { authClient } from "@/lib/auth-client"

  await authClient.linkSocial({
      provider: "google",
      callbackURL: "/callback",
      scopes: ["https://www.googleapis.com/auth/drive.readonly"] // Request additional scopes
  });
  ```

  You can also link accounts using ID tokens directly, without redirecting to the provider's OAuth flow:

  ```ts
  import { authClient } from "@/lib/auth-client"

  await authClient.linkSocial({
      provider: "google",
      idToken: {
          token: "id_token_from_provider",
          nonce: "nonce_used_for_token", // Optional
          accessToken: "access_token", // Optional, may be required by some providers
          refreshToken: "refresh_token" // Optional
      }
  });
  ```

  This is useful when you already have valid tokens from the provider, for example:
  - After signing in with a native SDK
  - When using a mobile app that handles authentication
  - When implementing custom OAuth flows

  The ID token must be valid and the provider must support ID token verification.

  If you want your users to be able to link a social account with a different email address than the user, or if you want to use a provider that does not return email addresses, you will need to enable this in the account linking settings. 
  ```ts title="auth.ts"
  import { betterAuth } from "better-auth";

  export const auth = betterAuth({
      account: {
          accountLinking: {
              allowDifferentEmails: true
          }
      },
  });
  ```

  If you want the newly linked accounts to update the user information, you need to enable this in the account linking settings. 

  ```ts title="auth.ts"
  import { betterAuth } from "better-auth";
  
  export const auth = betterAuth({
      account: {
          accountLinking: {
              updateUserInfoOnLink: true
          }
      },
  });
  ```

- **Linking Credential-Based Accounts:** To link a credential-based account (e.g., email and password), users can initiate a "forgot password" flow, or you can call the `setPassword` method on the server. 

  ```ts title="set-password.ts"
  import { auth } from "@/lib/auth"

  await auth.api.setPassword({
    body: {
        newPassword: "new-password", // required
    },
    headers: await headers() // headers containing the user's session token
  });
  ```

<Callout>
`setPassword` can't be called from the client for security reasons.
</Callout>

### Account Unlinking

You can unlink a user account by providing a `providerId`.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.unlinkAccount({
    providerId: "google"
});

// Unlink a specific account
await authClient.unlinkAccount({
    providerId: "google",
    accountId: "123"
});
```

If the account doesn't exist, it will throw an error. Additionally, if the user only has one account, unlinking will be prevented to stop account lockout (unless `allowUnlinkingAll` is set to `true`).

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    account: {
        accountLinking: {
            allowUnlinkingAll: true
        }
    },
});
```
---
title: Session Management
description: Better Auth session management.
---

Better Auth manages session using a traditional cookie-based session management. The session is stored in a cookie and is sent to the server on every request. The server then verifies the session and returns the user data if the session is valid.

## Session table

The session table stores the session data. The session table has the following fields:

- `id`: Unique identifier for the session.
- `token`: The session token. Which is also used as the session cookie.
- `userId`: The user ID of the user.
- `expiresAt`: The expiration date of the session.
- `ipAddress`: The IP address of the user.
- `userAgent`: The user agent of the user. It stores the user agent header from the request.

## Session Expiration

The session expires after 7 days by default. But whenever the session is used and the `updateAge` is reached, the session expiration is updated to the current time plus the `expiresIn` value.

You can change both the `expiresIn` and `updateAge` values by passing the `session` object to the `auth` configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    //... other config options
    session: {
        expiresIn: 60 * 60 * 24 * 7, // 7 days
        updateAge: 60 * 60 * 24 // 1 day (every 1 day the session expiration is updated)
    }
})
```

### Disable Session Refresh

You can disable session refresh so that the session is not updated regardless of the `updateAge` option.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    //... other config options
    session: {
        disableSessionRefresh: true
    }
})
```

### Defer Session Refresh

By default, `GET /get-session` performs database writes to refresh the session. This can cause issues with read-replica database setups where GET requests are routed to read-only replicas.

When enabled, GET becomes read-only and returns `needsRefresh: true` when refresh is needed. The client automatically calls POST to perform the refresh.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    session: {
        deferSessionRefresh: true
    }
})
```

## Session Freshness

Some endpoints in Better Auth require the session to be **fresh**. A session is considered fresh if its `createdAt` is within the `freshAge` limit. By default, the `freshAge` is set to **1 day** (60 * 60 * 24).  

You can customize the `freshAge` value by passing a `session` object in the `auth` configuration:  

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    //... other config options
    session: {
        freshAge: 60 * 5 // 5 minutes (the session is fresh if created within the last 5 minutes)
    }
})
```

To **disable the freshness check**, set `freshAge` to `0`:  

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    //... other config options
    session: {
        freshAge: 0 // Disable freshness check
    }
})
```
## Session Management

Better Auth provides a set of functions to manage sessions.

### Get Session

The `getSession` function retrieves the current active session.

```ts
import { authClient } from "@/lib/auth-client"

const { data: session } = await authClient.getSession()
```

To learn how to customize the session response check the [Customizing Session Response](#customizing-session-response) section.

### Use Session

The `useSession` action provides a reactive way to access the current session.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

const { data: session } = authClient.useSession()
```

### List Sessions

The `listSessions` function returns a list of sessions that are active for the user.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

const sessions = await authClient.listSessions()
```

### Revoke Session

When a user signs out of a device, the session is automatically ended. However, you can also end a session manually from any device the user is signed into.

To end a session, use the `revokeSession` function. Just pass the session token as a parameter.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

await authClient.revokeSession({
    token: "session-token"
})
```

### Revoke Other Sessions

To revoke all other sessions except the current session, you can use the `revokeOtherSessions` function.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

await authClient.revokeOtherSessions()
```

### Revoke All Sessions

To revoke all sessions, you can use the `revokeSessions` function.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

await authClient.revokeSessions()
```

### Update Session

If you have [additional fields](/docs/concepts/database#extending-core-schema) configured on the session, you can update them using the `updateSession` function.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

await authClient.updateSession({
    theme: "dark",
    language: "en",
})
```

Core session fields (`token`, `userId`, `expiresAt`, `createdAt`, `updatedAt`, `ipAddress`, `userAgent`) cannot be updated through this endpoint. Only custom additional fields are allowed.

On the server:

```ts title="server.ts"
await auth.api.updateSession({
    body: {
        theme: "dark",
    },
    headers: await headers() // headers containing the user's session token
});
```

### Revoking Sessions on Password Change

You can revoke all sessions when the user changes their password by passing `revokeOtherSessions` as true on `changePassword` function.

```ts title="auth.ts"
import { authClient } from "@/lib/auth-client"

await authClient.changePassword({
    newPassword: newPassword,
    currentPassword: currentPassword,
    revokeOtherSessions: true,
})
```

## Session Caching

### Cookie Cache

Calling your database every time `useSession` or `getSession` is invoked isn't ideal, especially if sessions don't change frequently. Cookie caching handles this by storing session data in a short-lived, signed cookie—similar to how JWT access tokens are used with refresh tokens.

When cookie caching is enabled, the server can check session validity from the cookie itself instead of hitting the database each time. The cookie is signed to prevent tampering, and a short `maxAge` ensures that the session data gets refreshed regularly. If a session is revoked or expires, the cookie will be invalidated automatically.

To turn on cookie caching, just set `session.cookieCache` in your auth config:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    session: {
        cookieCache: {
            enabled: true,
            maxAge: 5 * 60 // Cache duration in seconds (5 minutes)
        }
    }
});
```

<Callout type="info">
**Notes**

When `cookieCache` is enabled, revoked sessions may remain active on other devices until the cookie cache expires (`maxAge`). This is because:

- Cookie cache stores session data in the client's browser
- The server cannot directly delete cookies from other devices
- Sessions are only revalidated when the cache expires or `disableCookieCache: true` is used

**If immediate session revocation is critical:**
- Disable `cookieCache` entirely, or
- Set a shorter `maxAge` (e.g. 60 seconds), or
- Use `disableCookieCache: true` for sensitive operations
</Callout>

#### Cookie Cache Strategies

Better Auth supports three different encoding strategies for cookie cache:

- **`compact`** (default): Uses base64url encoding with HMAC-SHA256 signature. Most compact format with no JWT spec overhead. Best for performance and size.
- **`jwt`**: Standard JWT with HMAC-SHA256 signature (HS256). Signed but not encrypted - readable by anyone but tamper-proof. Follows JWT spec for interoperability.
- **`jwe`**: Uses JWE (JSON Web Encryption) with A256CBC-HS512 and HKDF key derivation. Fully encrypted tokens - neither readable nor tamperable. Most secure but largest size.

**Comparison:**

| Strategy | Size | Security | Readable | Interoperable | Use Case |
|----------|------|----------|----------|---------------|----------|
| `compact` | Smallest | Good (signed) | Yes | No | Performance-critical, internal use |
| `jwt` | Medium | Good (signed) | Yes | Yes | Need JWT compatibility, external integrations |
| `jwe` | Largest | Best (encrypted) | No | Yes | Sensitive data, maximum security |

```ts title="auth.ts"
export const auth = betterAuth({
    session: {
        cookieCache: {
            enabled: true,
            maxAge: 5 * 60,
            strategy: "compact" // or "jwt" or "jwe"
        }
    }
});
```

**Note:** All strategies are cryptographically secure and prevent tampering. The main differences are size, readability, and JWT spec compliance.

**When to use each:**

- **Use `compact`** when you need maximum performance and smallest cookie size. Best for most applications where cookies are only used internally by Better Auth.
- **Use `jwt`** when you need JWT compatibility for external systems, or when you want standard JWT tokens that can be verified by third-party tools. The tokens are readable (base64-encoded JSON) but tamper-proof.
- **Use `jwe`** when you need maximum security and want to hide session data from the client. The tokens are fully encrypted and cannot be read without the secret key. Use this for sensitive data or compliance requirements.

If you want to disable returning from the cookie cache when fetching the session, you can pass `disableCookieCache:true` this will force the server to fetch the session from the database and also refresh the cookie cache.

```ts title="auth-client.ts"
import { authClient } from "@/lib/auth-client"

const session = await authClient.getSession({ query: {
    disableCookieCache: true
}})
```

or on the server

```ts title="server.ts"
await auth.api.getSession({
    query: {
        disableCookieCache: true,
    }, 
    headers: await headers() // headers containing the user's session token
});
```

## Sessions in Secondary Storage

By default, if you provide a [secondary storage](/docs/concepts/database#secondary-storage) in your auth configuration, the session will be stored in the secondary storage.

```ts
import { betterAuth } from "better-auth";

betterAuth({
  // ... other options
  secondaryStorage: {
    // Your implementation here
  },
});
```

### Storing Sessions in the Database

By default, Better Auth already stores sessions in the database, however if you provide a secondary storage,
Better Auth will store sessions in the secondary storage instead of the database.

You can choose to store sessions in the database instead of secondary storage by passing
`storeSessionInDatabase: true` in the session configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    secondaryStorage: { /** your secondary storage implementation here */ },
    session: { // [!code highlight]
        storeSessionInDatabase: true, // [!code highlight]
    } // [!code highlight]
});
```

### Preserving Sessions

When a session is revoked, it will be removed from the secondary storage, however if you enable `preserveSessionInDatabase`,
the session will be preserved in the database and not be deleted.

This is useful if you want to keep track of the sessions that have been revoked.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    secondaryStorage: { /** your secondary storage implementation here */ },
    session: { // [!code highlight]
        preserveSessionInDatabase: true, // [!code highlight]
    } // [!code highlight]
});
```


## Stateless Session Management

Better Auth supports stateless session management without any database. This means that the session data is stored in a signed/encrypted cookie and the server never queries a database to validate sessions - it simply verifies the cookie signature and checks expiration.

### Basic Stateless Setup

If you don't pass a database configuration, Better Auth will automatically enable stateless mode.

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    // No database configuration
    socialProviders: {
        google: {
            clientId: process.env.GOOGLE_CLIENT_ID,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        },
    },
});
```

To manually enable stateless mode, you need to configure `cookieCache` and `account` with the following options:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    session: {
        cookieCache: {
            enabled: true,
            maxAge: 7 * 24 * 60 * 60, // 7 days cache duration
            strategy: "jwe", // can be "jwt" or "compact"
            refreshCache: true, // Enable stateless refresh
        },
    },
    account: {
        storeStateStrategy: "cookie",
        storeAccountCookie: true, // Store account data after OAuth flow in a cookie (useful for database-less flows)
    }
});
```

<Callout type="info">
If you don't provide a database, by default we provide the above configuration for you.
</Callout>

### Understanding `refreshCache`

The `refreshCache` option controls automatic cookie refresh **before expiry** without querying any database:

- **`false`** (default): No automatic refresh. When the cookie cache expires (reaches `maxAge`), it will attempt to fetch from the database if available.
- **`true`**: Enable automatic refresh with default settings. Refreshes when 80% of `maxAge` is reached (20% time remaining).
- **`object`**: Custom refresh configuration with `updateAge` property.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    session: {
        cookieCache: {
            enabled: true,
            maxAge: 300, // 5 minutes
            refreshCache: {
                updateAge: 60 // Refresh when 60 seconds remain before expiry
            }
        }
    }
});
```

### Versioning Stateless Sessions

One of the biggest drawbacks of stateless sessions is that you can't invalidate session easily. To solve this with better auth, if you would like to invalidate all sessions, you can change the version of the cookie cache and re-deploy your application.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
    session: {
        cookieCache: {
            version: "2", // [!code highlight] Change the version to invalidate all sessions
        }
    }
});
```

<Callout type="warning">
This will invalidate all sessions that don't match the new version.
</Callout>

### Stateless with Secondary Storage

You can combine stateless sessions with secondary storage (Redis, etc.) for the best of both worlds:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { redis } from "./redis"

export const auth = betterAuth({
    // No primary database needed
    secondaryStorage: {
        get: async (key) => await redis.get(key),
        set: async (key, value, ttl) => await redis.set(key, value, "EX", ttl),
        delete: async (key) => await redis.del(key)
    },
    session: {
        cookieCache: {
            maxAge: 5 * 60, // [!code highlight] 5 minutes (short-lived cookie)
            refreshCache: false // [!code highlight] Disable stateless refresh
        }
    }
});
```

This setup:
- Uses cookies for session validation (no DB queries)
- Uses Redis for storing session data and refreshing the cookie cache before expiry
- You can revoke sessions from the secondary storage and the cookie cache will be invalidated on refresh

## Customizing Session Response

When you call `getSession` or `useSession`, the session data is returned as a `user` and `session` object. You can customize this response using the `customSession` plugin.

```ts title="auth.ts"
import { customSession } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [
        customSession(async ({ user, session }) => {
            const roles = findUserRoles(session.session.userId);
            return {
                roles,
                user: {
                    ...user,
                    newField: "newField",
                },
                session
            };
        }),
    ],
});
```

This will add `roles` and `user.newField` to the session response.

**Infer on the Client**

```ts title="auth-client.ts"
import { customSessionClient } from "better-auth/client/plugins";
import type { auth } from "@/lib/auth"; // Import the auth instance as a type

const authClient = createAuthClient({
    plugins: [customSessionClient<typeof auth>()],
});

const { data } = authClient.useSession();
const { data: sessionData } = await authClient.getSession();
// data.roles
// data.user.newField
```

### Caveats on Customizing Session Response

1. The passed `session` object to the callback does not infer fields added by plugins.  

However, as a workaround, you can pull up your auth options and pass it to the plugin to infer the fields.

```ts
import { betterAuth, BetterAuthOptions } from "better-auth";

const options = {
  //...config options
  plugins: [
    //...plugins 
  ]
} satisfies BetterAuthOptions;

export const auth = betterAuth({
    ...options,
    plugins: [
        ...(options.plugins ?? []),
        customSession(async ({ user, session }, ctx) => {
            // now both user and session will infer the fields added by plugins and your custom fields
            return {
                user,
                session
            }
        }, options), // pass options here  // [!code highlight]
    ]
})
```

2. When your server and client code are in separate projects or repositories, and you cannot import the `auth` instance as a type reference, type inference for custom session fields will not work on the client side.
3. Session caching, including secondary storage or cookie cache, does not include custom fields. Each time the session is fetched, your custom session function will be called.

**Mutating the list-device-sessions endpoint**
The `/multi-session/list-device-sessions` endpoint from the [multi-session](/docs/plugins/multi-session) plugin is used to list the devices that the user is signed into.

You can mutate the response of this endpoint by passing the `shouldMutateListDeviceSessionsEndpoint` option to the `customSession` plugin.

By default, we do not mutate the response of this endpoint.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { customSession } from "better-auth/plugins";

export const auth = betterAuth({
    plugins: [
        customSession(async ({ user, session }, ctx) => {
            return {
                user,
                session
            }
        }, {}, { shouldMutateListDeviceSessionsEndpoint: true }), // [!code highlight]
    ],
});
```
---
title: Figma
description: Figma provider setup and usage.
---

<Steps>
    <Step>
        ### Get your Credentials
        1. Sign in to your Figma account and go to the [Developer Apps page](https://www.figma.com/developers/apps)
        2. Click "Create new app"
        3. Fill out the app details (name, description, etc.)
        4. Configure your redirect URI (e.g., `https://yourdomain.com/api/auth/callback/figma`)
        5. Note your Client ID and Client Secret

        <Callout type="info">
            The default scope is `current_user:read`. For additional scopes like `file_content:read`, refer to the [Figma OAuth scopes documentation](https://developers.figma.com/docs/rest-api/scopes).
        </Callout>

        Make sure to set the redirect URI to match your application's callback URL. If you change the base path of the auth routes, you should update the redirect URI accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                figma: { // [!code highlight]
                    clientId: process.env.FIGMA_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.FIGMA_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Figma
        To sign in with Figma, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `figma`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "figma"
            })
        }
        ```
        <Callout type="info">
        For more information about Figma's OAuth scopes and API capabilities, refer to the [official Figma API documentation](https://www.figma.com/developers/api).
        </Callout>
    </Step>

</Steps>
---
title: Dropbox
description: Dropbox provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Dropbox credentials
        To use Dropbox sign in, you need a client ID and client secret. You can get them from the [Dropbox Developer Portal](https://www.dropbox.com/developers). You can Allow "Implicit Grant & PKCE" for the application in the App Console.
        
        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/dropbox` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

    If you need deeper dive into Dropbox Authentication, you can check out the [official documentation](https://developers.dropbox.com/oauth-guide).

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                dropbox: { // [!code highlight]
                    clientId: process.env.DROPBOX_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.DROPBOX_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Dropbox
        To sign in with Dropbox, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `dropbox`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "dropbox"
            })
        }
        ```
    </Step>

</Steps>
---
title: Microsoft
description: Microsoft provider setup and usage.
---

Enabling OAuth with Microsoft Azure Entra ID (formerly Active Directory) allows your users to sign in and sign up to your application with their Microsoft account.

<Steps>
    <Step> 
        ### Get your Microsoft credentials
        To use Microsoft as a social provider, you need to get your Microsoft credentials. Which involves generating your own Client ID and Client Secret using your Microsoft Entra ID dashboard account.

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/microsoft` for local development. For production, you should change it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        see the [Microsoft Entra ID documentation](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app) for more information.
    </Step>

    <Step>
    ### Configure the provider
    To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.microsoft` in your auth configuration.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"

    export const auth = betterAuth({
        socialProviders: {
            microsoft: { // [!code highlight]
                clientId: process.env.MICROSOFT_CLIENT_ID as string, // [!code highlight]
                clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string, // [!code highlight]
                // Optional
                tenantId: 'common', // [!code highlight]                
                authority: "https://login.microsoftonline.com", // Authentication authority URL // [!code highlight]
                prompt: "select_account", // Forces account selection // [!code highlight]
            }, // [!code highlight]
        },
    })
    ```
    
    **Authority URL**: Use the default `https://login.microsoftonline.com` for standard Entra ID scenarios or `https://<tenant-id>.ciamlogin.com` for CIAM (Customer Identity and Access Management) scenarios.
    
    </Step>

</Steps>

## Sign In with Microsoft

To sign in with Microsoft, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:

- `provider`: The provider to use. It should be set to `microsoft`.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";

const authClient = createAuthClient();

const signIn = async () => {
  const data = await authClient.signIn.social({
    provider: "microsoft",
    callbackURL: "/dashboard", // The URL to redirect to after the sign in
  });
};
```
---
title: Naver
description: Naver provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Naver Credentials
        To use Naver sign in, you need a client ID and client secret. You can get them from the [Naver Developers](https://developers.naver.com/).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/naver` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>
    <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                naver: { // [!code highlight]
                    clientId: process.env.NAVER_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.NAVER_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            }
        })
        ```
    </Step>
    <Step>
        ### Sign In with Naver
        To sign in with Naver, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `naver`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "naver"
            })
        }
        ```
    </Step>

</Steps>
---
title: GitLab
description: GitLab provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your GitLab credentials
        To use GitLab sign in, you need a client ID and client secret. [GitLab OAuth documentation](https://docs.gitlab.com/ee/api/oauth2.html).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/gitlab` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                gitlab: { // [!code highlight]
                    clientId: process.env.GITLAB_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.GITLAB_CLIENT_SECRET as string, // [!code highlight]
                    issuer: process.env.GITLAB_ISSUER as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```

        #### Configuration Options

        - `clientId`: Your GitLab application's Client ID
        - `clientSecret`: Your GitLab application's Client Secret  
        - `issuer`: (Optional) The URL of your GitLab instance. Use this for self-hosted GitLab servers.
            - Default: `"https://gitlab.com"` (GitLab.com)
            - Example: `"https://gitlab.company.com"`

        <Callout type="info">
            The `issuer` option is useful when using a self-hosted GitLab instance. If you're using GitLab.com, you can omit this option as it defaults to `https://gitlab.com`.
        </Callout>

        #### Example with self-hosted GitLab

        ```ts title="auth.ts"
        export const auth = betterAuth({
            socialProviders: {
                gitlab: {
                    clientId: process.env.GITLAB_CLIENT_ID as string,
                    clientSecret: process.env.GITLAB_CLIENT_SECRET as string,
                    issuer: "https://gitlab.company.com", // Your self-hosted GitLab URL // [!code highlight]
                },
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with GitLab
        To sign in with GitLab, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `gitlab`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "gitlab"
            })
        }
        ```
    </Step>
</Steps>
---
title: GitHub
description: GitHub provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your GitHub credentials
        To use GitHub sign in, you need a client ID and client secret. You can get them from the [GitHub Developer Portal](https://github.com/settings/developers).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/github` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        Important: You MUST include the user:email scope in your GitHub app. See details below.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                github: { // [!code highlight]
                    clientId: process.env.GITHUB_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.GITHUB_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with GitHub
        To sign in with GitHub, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `github`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "github"
            })
        }
        ```
    </Step>
</Steps>

## Usage

### Setting up your Github app

Github has two types of apps: Github apps and OAuth apps.

For OAuth apps, you don't have to do anything special (just follow the steps above). For Github apps, you DO have to add one more thing, which is enable it to read the user's email:

1. After creating your app, go to *Permissions and Events* > *Account Permissions* > *Email Addresses* and select "Read-Only"

2. Save changes. 

That's all! Now you can copy the Client ID and Client Secret of your app! 

<Callout>
If you get "email_not_found" error, it's because you selected a Github app & did not configure this part!
</Callout>

### Why don't I have a refresh token?

Github doesn't issue refresh tokens for OAuth apps. For regular OAuth apps,
GitHub issues access tokens that remain valid indefinitely unless the user revokes them,
the app revokes them, or they go unused for a year.
There's no need for a refresh token because the access token doesn't expire on a short interval like Google or Discord.
---
title: Hugging Face
description: Hugging Face provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Hugging Face credentials
        To use Hugging Face sign in, you need a client ID and client secret. [Hugging Face OAuth documentation](https://huggingface.co/docs/hub/oauth). Make sure the created oauth app on Hugging Face has the "email" scope.

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/huggingface` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                huggingface: { // [!code highlight]
                    clientId: process.env.HUGGINGFACE_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.HUGGINGFACE_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Hugging Face
        To sign in with Hugging Face, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `huggingface`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "huggingface"
            })
        }
        ```
    </Step>
</Steps>
---
title: VK
description: VK ID Provider
---

<Steps>
    <Step>
        ### Get your VK ID credentials
        To use VK ID sign in, you need a client ID and client secret. You can get them from the [VK ID Developer Portal](https://id.vk.com/about/business/go/docs).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/vk` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

    <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.
        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";

        export const auth = betterAuth({
          socialProviders: {
            vk: { // [!code highlight]
              clientId: process.env.VK_CLIENT_ID as string, // [!code highlight]
              clientSecret: process.env.VK_CLIENT_SECRET as string, // [!code highlight]
            },
          },
        });
        ```
    </Step>
    <Step>
        ### Sign In with VK
        To sign in with VK, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `vk`.


        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client";
        const authClient = createAuthClient();

        const signIn = async () => {
          const data = await authClient.signIn.social({
            provider: "vk",
          });
        };
        ```
    </Step>

</Steps>
---
title: Zoom
description: Zoom provider setup and usage.
---

<Steps>
  <Step> 
    ### Create a Zoom App from Marketplace
    1. Visit [Zoom Marketplace](https://marketplace.zoom.us).

    1. Hover on the `Develop` button and select `Build App`

    1. Select `General App` and click `Create`

  </Step>

  <Step> 
    ### Configure your Zoom App
    
    Ensure that you are in the `Basic Information` of your app settings.

    1. Under `Select how the app is managed`, choose `User-managed`

    1. Under `App Credentials`, copy your `Client ID` and `Client Secret` and store them in a safe location

    1. Under `OAuth Information` -> `OAuth Redirect URL`, add your Callback URL. For example,

       ```
       http://localhost:3000/api/auth/callback/zoom
       ```

       <Callout>
       For production, you should set it to the URL of your application. If you change the base
       path of the auth routes, you should update the redirect URL accordingly.
       </Callout>

    Skip to the `Scopes` section, then
    1. Click the `Add Scopes` button
    1. Search for `user:read:user` (View a user) and select it
    1. Add any other scopes your applications needs and click `Done`

  </Step>

  <Step>
    ### Configure the provider
    To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"

    export const auth = betterAuth({
      socialProviders: {
        zoom: { // [!code highlight]
          clientId: process.env.ZOOM_CLIENT_ID as string, // [!code highlight]
          clientSecret: process.env.ZOOM_CLIENT_SECRET as string, // [!code highlight]
        }, // [!code highlight]
      },
    })
    ```

  </Step>

  <Step>
    ### Sign In with Zoom 
    To sign in with Zoom, you can use the `signIn.social` function provided by the client.
    You will need to specify `zoom` as the provider.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    const authClient =  createAuthClient()

    const signIn = async () => {
      const data = await authClient.signIn.social({
        provider: "zoom"
      })
    }
    ```

  </Step>
</Steps>
---
title: Railway
description: Railway provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Railway credentials
        To use Railway sign in, you need a client ID and client secret. You can get them from the [Railway Developer Settings](https://railway.com/account/developer).

        1. Go to your Railway account's Developer Settings
        2. Click "Create OAuth App"
        3. Set the Application Type to "Web Application"
        4. Set the redirect URL to `http://localhost:3000/api/auth/callback/railway` for local development. For production, you should set it to the URL of your application.

        Make sure to save your client ID and client secret securely. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        <Callout type="info">
            Railway uses PKCE (Proof Key for Code Exchange) for enhanced security. This is automatically handled by Better Auth.
        </Callout>
    </Step>

    <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                railway: { // [!code highlight]
                    clientId: process.env.RAILWAY_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.RAILWAY_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
</Steps>

## Usage

### Sign in with Railway

To sign in with Railway, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:

- `provider`: The provider to use. It should be set to `railway`.

```ts title="auth-client.ts"  
import { createAuthClient } from "better-auth/client"
const authClient = createAuthClient()

const signIn = async () => {
    const data = await authClient.signIn.social({
        provider: "railway"
    })
}
```

## Options

For the full list of options supported by all social providers, check the [Provider Options](/docs/concepts/oauth#provider-options).

### Available Scopes

Railway OAuth supports the following scopes:

| Scope | Description |
|-------|-------------|
| `openid` | Required for all requests (included by default) |
| `email` | Access user's email address (included by default) |
| `profile` | Access user's name and picture (included by default) |
| `offline_access` | Receive refresh tokens for long-lived access |
| `workspace:viewer` | Viewer access to user-selected workspaces |
| `workspace:member` | Member access to user-selected workspaces |
| `workspace:admin` | Admin access to user-selected workspaces |
| `project:viewer` | Viewer access to user-selected projects |
| `project:member` | Member access to user-selected projects |

When requesting workspace or project scopes, users will select which specific workspaces or projects to share during the consent screen.

You can specify additional scopes when configuring the provider:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    socialProviders: {
        railway: {
            clientId: process.env.RAILWAY_CLIENT_ID as string,
            clientSecret: process.env.RAILWAY_CLIENT_SECRET as string,
            scope: ["workspace:viewer", "project:viewer"], // [!code highlight]
        },
    },
})
```

<Callout type="warn">
    When requesting `offline_access` scope, Railway requires `prompt=consent` to be set in the authorization URL:

    ```ts
    railway: {
        clientId: process.env.RAILWAY_CLIENT_ID as string,
        clientSecret: process.env.RAILWAY_CLIENT_SECRET as string,
        scope: ["offline_access"],
        prompt: "consent", // [!code highlight]
    }
    ```
</Callout>

For more information about Railway's OAuth implementation, refer to the [official Railway documentation](https://docs.railway.com/reference/oauth/login-with-railway).
---
title: Salesforce
description: Salesforce provider setup and usage.
---

<Steps>
    <Step>
        ### Get your Salesforce Credentials
       1. Log into your Salesforce org (Production or Developer Edition)
    2. Navigate to **Setup > App Manager**
    3. Click **New Connected App**
    4. Fill in the basic information:
       - Connected App Name: Your app name
       - API Name: Auto-generated from app name
       - Contact Email: Your email address
    5. Enable OAuth Settings:
       - Check **Enable OAuth Settings**
       - Set **Callback URL** to your redirect URI (e.g., `http://localhost:3000/api/auth/callback/salesforce` for development)
       - Select Required OAuth Scopes:
         - Access your basic information (id)
         - Access your identity URL service (openid)
         - Access your email address (email)
         - Perform requests on your behalf at any time (refresh_token, offline_access)
    6. Enable **Require Proof Key for Code Exchange (PKCE)** (required)
    7. Save and note your **Consumer Key** (Client ID) and **Consumer Secret** (Client Secret)

    <Callout type="info">
        - For development, you can use `http://localhost:3000` URLs, but production requires HTTPS
        - The callback URL must exactly match what's configured in Better Auth
        - PKCE (Proof Key for Code Exchange) is required by Salesforce and is automatically handled by the provider
    </Callout>

    <Callout type="warning">
        For sandbox testing, you can create the Connected App in your sandbox org, or use the same Connected App but specify `environment: "sandbox"` in the provider configuration.
    </Callout>

    </Step>

  <Step>
  ### Configure the provider
    To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"

    export const auth = betterAuth({
        socialProviders: {
            salesforce: { // [!code highlight]
                clientId: process.env.SALESFORCE_CLIENT_ID as string, // [!code highlight]
                clientSecret: process.env.SALESFORCE_CLIENT_SECRET as string, // [!code highlight]
                environment: "production", // or "sandbox" // [!code highlight]
            }, // [!code highlight]
        },
    })
    ```

    #### Configuration Options

    - `clientId`: Your Connected App's Consumer Key
    - `clientSecret`: Your Connected App's Consumer Secret  
    - `environment`: `"production"` (default) or `"sandbox"`
    - `loginUrl`: Custom My Domain URL (without `https://`) - overrides environment setting
    - `redirectURI`: Override the auto-generated redirect URI if needed

    #### Advanced Configuration

    ```ts title="auth.ts"
    export const auth = betterAuth({
        socialProviders: {
            salesforce: {
                clientId: process.env.SALESFORCE_CLIENT_ID as string,
                clientSecret: process.env.SALESFORCE_CLIENT_SECRET as string,
                environment: "sandbox", // [!code highlight]
                loginUrl: "my-company.my.salesforce.com", // Custom My Domain // [!code highlight]
                redirectURI: "http://localhost:3000/api/auth/callback/salesforce", // Override if needed // [!code highlight]
            },
        },
    })
    ```

    <Callout type="info">
        - Use `environment: "sandbox"` for testing with Salesforce sandbox orgs
        - The `loginUrl` option is useful for organizations with My Domain enabled
        - The `redirectURI` option helps resolve redirect URI mismatch errors
    </Callout>
    </Step>
        
   <Step>
    ### Environment Variables
    Add the following environment variables to your `.env.local` file:

    ```bash title=".env.local"
    SALESFORCE_CLIENT_ID=your_consumer_key_here
    SALESFORCE_CLIENT_SECRET=your_consumer_secret_here
    BETTER_AUTH_URL=http://localhost:3000 # Important for redirect URI generation
    ```

    For production:
    ```bash title=".env"
    SALESFORCE_CLIENT_ID=your_consumer_key_here
    SALESFORCE_CLIENT_SECRET=your_consumer_secret_here
    BETTER_AUTH_URL=https://yourdomain.com
    ```
    </Step>

    <Step>
    ### Sign In with Salesforce
    To sign in with Salesforce, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
    - `provider`: The provider to use. It should be set to `salesforce`.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    const authClient = createAuthClient()

    const signIn = async () => {
        const data = await authClient.signIn.social({
            provider: "salesforce"
        })
    }
    ```
</Step>
<Step>
    ### Troubleshooting

    #### Redirect URI Mismatch Error
    If you encounter a `redirect_uri_mismatch` error:

    1. **Check Callback URL**: Ensure the Callback URL in your Salesforce Connected App exactly matches your Better Auth callback URL
    2. **Protocol**: Make sure you're using the same protocol (`http://` vs `https://`)
    3. **Port**: Verify the port number matches (e.g., `:3000`)
    4. **Override if needed**: Use the `redirectURI` option to explicitly set the redirect URI

    ```ts
    salesforce: {
        clientId: process.env.SALESFORCE_CLIENT_ID as string,
        clientSecret: process.env.SALESFORCE_CLIENT_SECRET as string,
        redirectURI: "http://localhost:3000/api/auth/callback/salesforce", // [!code highlight]
    }
    ```

    #### Environment Issues
    - **Production**: Use `environment: "production"` (default) with `login.salesforce.com`
    - **Sandbox**: Use `environment: "sandbox"` with `test.salesforce.com`
    - **My Domain**: Use `loginUrl: "yourcompany.my.salesforce.com"` for custom domains

    #### PKCE Requirements
    Salesforce requires PKCE (Proof Key for Code Exchange) which is automatically handled by this provider. Make sure PKCE is enabled in your Connected App settings.

    <Callout type="info">
        The default scopes requested are `openid`, `email`, and `profile`. The provider will automatically include the `id` scope for accessing basic user information.
    </Callout>
</Step>
</Steps>
---
title: Notion
description: Notion provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Notion credentials
        To use Notion as a social provider, you need to get your Notion OAuth credentials. You can get them by creating a new integration in the [Notion Developers Portal](https://www.notion.so/my-integrations).

        In the Notion integration settings > OAuth Domain & URIs, make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/notion` for local development. For production, make sure to set the redirect URL as your application domain, e.g. `https://example.com/api/auth/callback/notion`. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        <Callout>
        Make sure your Notion integration has the appropriate capabilities enabled. For user authentication, you'll need the "Read user information including email addresses" capability.
        </Callout>
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.notion` in your auth configuration.

        ```ts title="auth.ts"   
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                notion: { // [!code highlight]
                    clientId: process.env.NOTION_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.NOTION_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
</Steps>

## Usage

### Sign In with Notion

To sign in with Notion, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
- `provider`: The provider to use. It should be set to `notion`.

```ts title="auth-client.ts"  
import { createAuthClient } from "better-auth/client"
const authClient =  createAuthClient()

const signIn = async () => {
    const data = await authClient.signIn.social({
        provider: "notion"
    })
}
```

### Notion Integration Types

Notion supports different integration types. When creating your integration, you can choose between:

- **Public integrations**: Can be installed by any Notion workspace
- **Internal integrations**: Limited to your own workspace

For most authentication use cases, you'll want to create a public integration to allow users from different workspaces to sign in.

### Requesting Additional Notion Scopes

If your application needs additional Notion capabilities after the user has already signed up, you can request them using the `linkSocial` method with the same Notion provider and additional scopes.

```ts title="auth-client.ts"
const requestNotionAccess = async () => {
    await authClient.linkSocial({
        provider: "notion",
        // Notion automatically provides access based on integration capabilities
    });
};

// Example usage in a React component
return <button onClick={requestNotionAccess}>Connect Notion Workspace</button>;
```

<Callout>
After authentication, you can use the access token to interact with the Notion API to read and write pages, databases, and other content that the user has granted access to.
</Callout>---
title: Email & Password
description: Implementing email and password authentication with Better Auth.
---

Email and password authentication is a common method used by many applications. Better Auth provides a built-in email and password authenticator that you can easily integrate into your project.

<Callout type="info">
  If you prefer username-based authentication, check out the{" "}
  <Link href="/docs/plugins/username">username plugin</Link>. It extends the
  email and password authenticator with username support.
</Callout>

## Enable Email and Password

To enable email and password authentication, you need to set the `emailAndPassword.enabled` option to `true` in the `auth` configuration.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  emailAndPassword: { // [!code highlight]
    enabled: true, // [!code highlight]
  }, // [!code highlight]
});
```

<Callout type="info">
  If it's not enabled, it'll not allow you to sign in or sign up with email and
  password.
</Callout>

## Usage

### Sign Up

To sign a user up, you can use the `signUp.email` function provided by the client.

<APIMethod path="/sign-up/email" method="POST">
```ts
type signUpEmail = {
    /**
     * The name of the user.
     */
    name: string = "John Doe"
    /**
     * The email address of the user.
     */
    email: string = "john.doe@example.com"
    /**
     * The password of the user. It should be at least 8 characters long and max 128 by default.
     */
    password: string = "password1234"
    /**
     * An optional profile image of the user.
     */
    image?: string = "https://example.com/image.png"
    /**
     * An optional URL to redirect to after the user signs up.
     */
    callbackURL?: string = "https://example.com/callback"
}
```
</APIMethod>

<Callout>
  These are the default properties for the sign up email endpoint, however it's possible that with [additional fields](/docs/concepts/typescript#additional-fields) or special plugins you can pass more properties to the endpoint.
</Callout>


### Sign In

To sign a user in, you can use the `signIn.email` function provided by the client.  

<APIMethod path="/sign-in/email" method="POST" requireSession>
```ts
type signInEmail = {
    /**
     * The email address of the user.
     */
    email: string = "john.doe@example.com"
    /**
     * The password of the user. It should be at least 8 characters long and max 128 by default.
     */
    password: string = "password1234"
    /**
     * If false, the user will be signed out when the browser is closed. (optional) (default: true)
     */
    rememberMe?: boolean = true
    /**
     * An optional URL to redirect to after the user signs in. (optional)
     */
    callbackURL?: string = "https://example.com/callback"
}
```
</APIMethod>

<Callout>
  These are the default properties for the sign in email endpoint, however it's possible that with [additional fields](/docs/concepts/typescript#additional-fields) or special plugins you can pass different properties to the endpoint.
</Callout>


### Sign Out

To sign a user out, you can use the `signOut` function provided by the client.

<APIMethod path="/sign-out" method="POST" requireSession noResult>
```ts
type signOut = {
}
```
</APIMethod>

you can pass `fetchOptions` to redirect onSuccess
  
```ts
import { authClient } from "@/lib/auth-client"

await authClient.signOut({
  fetchOptions: {
    onSuccess: () => {
      router.push("/login"); // redirect to login page
    },
  },
});
```

### Email Verification

To enable email verification, you need to pass a function that sends a verification email with a link. The `sendVerificationEmail` function takes a data object with the following properties:

- `user`: The user object.
- `url`: The URL to send to the user which contains the token.
- `token`: A verification token used to complete the email verification.

and a `request` object as the second parameter.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sendEmail } from "./email"; // your email sending function

export const auth = betterAuth({
  emailVerification: {
    sendVerificationEmail: async ( { user, url, token }, request) => {
      void sendEmail({
        to: user.email,
        subject: "Verify your email address",
        text: `Click the link to verify your email: ${url}`,
      });
    },
  },
});
```

<Callout type="warn">
  Avoid awaiting the email sending to prevent 
  timing attacks. On serverless platforms, use `waitUntil` or similar to ensure the email is sent.
</Callout>

On the client side you can use `sendVerificationEmail` function to send verification link to user. This will trigger the `sendVerificationEmail` function you provided in the `auth` configuration.

Once the user clicks on the link in the email, if the token is valid, the user will be redirected to the URL provided in the `callbackURL` parameter. If the token is invalid, the user will be redirected to the URL provided in the `callbackURL` parameter with an error message in the query string `?error=invalid_token`.

#### Require Email Verification

If you enable require email verification, users must verify their email before they can log in. And every time a user tries to sign in, sendVerificationEmail is called.

<Callout>
  This only works if you have sendVerificationEmail implemented and if the user
  is trying to sign in with email and password.

  When `requireEmailVerification` is enabled, signing up with an existing email returns a success response instead of an error to prevent user enumeration.
</Callout>

```ts title="auth.ts"
export const auth = betterAuth({
  emailAndPassword: {
    requireEmailVerification: true, // [!code highlight]
  },
});
```

You can use the `onExistingUserSignUp` callback to notify the existing user when someone tries to register with their email address:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sendEmail } from "./email"; // your email sending function

export const auth = betterAuth({
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: true,
    onExistingUserSignUp: async ({ user }, request) => {
      void sendEmail({
        to: user.email,
        subject: "Sign-up attempt with your email",
        text: "Someone tried to create an account using your email address. If this was you, try signing in instead. If not, you can safely ignore this email.",
      });
    },
  },
});
```

If a user tries to sign in without verifying their email, you can handle the error and show a message to the user.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.signIn.email(
  {
    email: "email@example.com",
    password: "password",
  },
  {
    onError: (ctx) => {
      // Handle the error
      if (ctx.error.status === 403) {
        alert("Please verify your email address");
      }
      //you can also show the original error message
      alert(ctx.error.message);
    },
  }
);
```

#### Triggering manually Email Verification

You can trigger the email verification manually by calling the `sendVerificationEmail` function.

```ts
import { authClient } from "@/lib/auth-client"

await authClient.sendVerificationEmail({
  email: "user@email.com",
  callbackURL: "/", // The redirect URL after verification
});
```

### Request Password Reset

To allow users to reset a password first you need to provide `sendResetPassword` function to the email and password authenticator. The `sendResetPassword` function takes a data object with the following properties:

- `user`: The user object.
- `url`: The URL to send to the user which contains the token.
- `token`: A verification token used to complete the password reset.

and a `request` object as the second parameter.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { sendEmail } from "./email"; // your email sending function

export const auth = betterAuth({
  emailAndPassword: {
    enabled: true,
    sendResetPassword: async ({user, url, token}, request) => {
      void sendEmail({
        to: user.email,
        subject: "Reset your password",
        text: `Click the link to reset your password: ${url}`,
      });
    },
    onPasswordReset: async ({ user }, request) => {
      // your logic here
      console.log(`Password for user ${user.email} has been reset.`);
    },
  },
});
```

<Callout type="warn">
  Avoid awaiting the email sending to prevent 
  timing attacks. On serverless platforms, use `waitUntil` or similar to ensure the email is sent.
</Callout>

Additionally, you can provide an `onPasswordReset` callback to execute logic after a password has been successfully reset.

Once you configured your server you can call `requestPasswordReset` function to send reset password link to user. If the user exists, it will trigger the `sendResetPassword` function you provided in the auth config.

<APIMethod path="/request-password-reset" method="POST">
```ts
type requestPasswordReset = {
    /**
     * The email address of the user to send a password reset email to 
     */
    email: string = "john.doe@example.com"
    /**
     * The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN 
     */
    redirectTo?: string = "https://example.com/reset-password"
}
```
</APIMethod>

When a user clicks on the link in the email, they will be redirected to the reset password page. You can add the reset password page to your app. Then you can use `resetPassword` function to reset the password. It takes an object with the following properties:

- `newPassword`: The new password of the user.

```ts
import { authClient } from "@/lib/auth-client"

const { data, error } = await authClient.resetPassword({
  newPassword: "password1234",
  token,
});
```

<APIMethod path="/reset-password" method="POST">
```ts
const token = new URLSearchParams(window.location.search).get("token");

if (!token) {
  // Handle the error
}

type resetPassword = {
    /**
     * The new password to set 
     */
    newPassword: string = "password1234"
    /**
     * The token to reset the password 
     */
    token: string
}
```
</APIMethod>

### Update password
A user's password isn't stored in the user table. Instead, it's stored in the account table. To change the password of a user, you can use one of the following approaches:


<APIMethod path="/change-password" method="POST" requireSession>
```ts
type changePassword = {
    /**
     * The new password to set 
     */
    newPassword: string = "newpassword1234"
    /**
     * The current user password 
     */
    currentPassword: string = "oldpassword1234"
    /**
     * When set to true, all other active sessions for this user will be invalidated
     */
    revokeOtherSessions?: boolean = true
}
```
</APIMethod>

### Configuration

**Password**

Better Auth stores passwords inside the `account` table with `providerId` set to `credential`.

**Password Hashing**: Better Auth uses `scrypt` to hash passwords. The `scrypt` algorithm is designed to be slow and memory-intensive to make it difficult for attackers to brute force passwords. OWASP recommends using `scrypt` if `argon2id` is not available. We decided to use `scrypt` because it's natively supported by Node.js.

You can pass custom password hashing algorithm by setting `password` option in the `emailAndPassword` configuration.

**Example**

Here's an example of customizing the password hashing to use Argon2:
```ts title="password.ts"
import { hash, type Options, verify } from "@node-rs/argon2";

const opts: Options = {
  memoryCost: 65536, // 64 MiB
  timeCost: 3, // 3 iterations
  parallelism: 4, // 4 lanes
  outputLen: 32, // 32 bytes
  algorithm: 2, // Argon2id
};

export async function hashPassword(password: string) {
  const result = await hash(password, opts);
  return result;
}

export async function verifyPassword(data: { password: string; hash: string }) {
  const { password, hash } = data;
  const result = await verify(hash, password, opts);
  return result;
}
```
```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { hashPassword, verifyPassword } from "./password";

export const auth = betterAuth({
  emailAndPassword: {
    //...rest of the options
    enabled: true,
    password: {
      hash: hashPassword,
      verify: verifyPassword,
    },
  },
});
```

<TypeTable
  type={{
    enabled: {
      description: "Enable email and password authentication.",
      type: "boolean",
      default: "false",
    },
    disableSignUp: {
      description: "Disable email and password sign up.",
      type: "boolean",
      default: "false"
    },
    minPasswordLength: {
      description: "The minimum length of a password.",
      type: "number",
      default: 8,
    },
    maxPasswordLength: {
      description: "The maximum length of a password.",
      type: "number",
      default: 128,
    },
    sendResetPassword: {
      description:
        "Sends a password reset email. It takes a function that takes two parameters: token and user.",
      type: "function",
    },
    onPasswordReset: {
      description:
        "A callback function that is triggered when a user's password is changed successfully.",
      type: "function",
    },
    onExistingUserSignUp: {
      description:
        "A callback triggered when someone signs up with an already-registered email. Only called when enumeration protection is active (requireEmailVerification: true or autoSignIn: false).",
      type: "function",
      default: "undefined",
    },
    autoSignIn: {
      description:
        "Automatically sign in the user after sign up. When set to false, the sign-up response returns a success response and enables enumeration protection.",
      type: "boolean",
      default: "true",
    },
    requireEmailVerification: {
      description:
        "Require users to verify their email before they can sign in. When enabled, the sign-up response returns a success response and enables enumeration protection.",
      type: "boolean",
      default: "false",
    },
    revokeSessionsOnPasswordReset: {
      description:
        "Whether to revoke all other sessions when resetting password.",
      type: "boolean",
      default: "false",
    },
    resetPasswordTokenExpiresIn: {
      description:
        "Number of seconds the reset password token is valid for.",
      type: "number",
      default: 3600
    },
    password: {
      description: "Password configuration.",
      type: "object",
      properties: {
        hash: {
          description: "custom password hashing function",
          type: "function",
        },
        verify: {
          description: "custom password verification function",
          type: "function",
        },
      },
    },
  }}
/>
---
title: Spotify
description: Spotify provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Spotify Credentials
        To use Spotify sign in, you need a client ID and client secret. You can get them from the [Spotify Developer Portal](https://developer.spotify.com/dashboard/applications).

        **Important:** Spotify no longer supports `localhost` as a redirect URI. You must use `127.0.0.1` for local development.

        Make sure to set the redirect URL to `http://127.0.0.1:3000/api/auth/callback/spotify` in your Spotify Dashboard.
        
        Consequently, ensure you access your local app via `http://127.0.0.1:3000` (not `localhost:3000`) so the browser URL matches the redirect URI exactly.

        For production, you should set it to the URL of your application (must be HTTPS). If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        You must also ensure your environment variables use the correct loopback IP to match the redirect URI. Update your `.env` file:
        
        ```bash title=".env"
        BETTER_AUTH_URL=http://127.0.0.1:3000
        ```

        ```ts title="auth.ts"  
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            
            socialProviders: {
                spotify: { // [!code highlight]
                    clientId: process.env.SPOTIFY_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.SPOTIFY_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Spotify
        To sign in with Spotify, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `spotify`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "spotify"
            })
        }
        ```
    </Step>
</Steps>---
title: Other Social Providers
description: Other social providers setup and usage.
---

Better Auth provides support for any social provider that implements the OAuth2 protocol or OpenID Connect (OIDC) flows through the [Generic OAuth Plugin](/docs/plugins/generic-oauth). You can use pre-configured helper functions for popular providers like Auth0, Keycloak, Okta, Microsoft Entra ID, and Slack, or manually configure any OAuth provider.

## Installation

<Steps>
  <Step>
    ### Add the plugin to your auth config

    To use the Generic OAuth plugin, add it to your auth config.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"
    import { genericOAuth } from "better-auth/plugins" // [!code highlight]

    export const auth = betterAuth({
        // ... other config options
        plugins: [
            genericOAuth({ // [!code highlight]
                config: [ // [!code highlight]
                    { // [!code highlight]
                        providerId: "provider-id", // [!code highlight]
                        clientId: "test-client-id", // [!code highlight]
                        clientSecret: "test-client-secret", // [!code highlight]
                        discoveryUrl: "https://auth.example.com/.well-known/openid-configuration", // [!code highlight]
                        // ... other config options // [!code highlight]
                    }, // [!code highlight]
                    // Add more providers as needed // [!code highlight]
                ] // [!code highlight]
            }) // [!code highlight]
        ]
    })
    ```

  </Step>

  <Step>
    ### Add the client plugin

    Include the Generic OAuth client plugin in your authentication client instance.

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"
    import { genericOAuthClient } from "better-auth/client/plugins"

    const authClient = createAuthClient({
        plugins: [
            genericOAuthClient()
        ]
    })
    ```

  </Step>
</Steps>

<Callout>
  Read more about installation and usage of the Generic Oauth plugin
  [here](/docs/plugins/generic-oauth#usage).
</Callout>

## Example Usage

Here's a basic example of configuring a generic OAuth provider:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { genericOAuth } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    genericOAuth({
      config: [
        {
          providerId: "provider-id",
          clientId: process.env.CLIENT_ID,
          clientSecret: process.env.CLIENT_SECRET,
          discoveryUrl: "https://auth.example.com/.well-known/openid-configuration",
        },
      ],
    }),
  ],
})
```

## Using Pre-configured Providers

Better Auth provides pre-configured helper functions for popular OAuth providers. Here's an example using Slack:

```ts title="auth.ts"
import { betterAuth } from "better-auth"
import { genericOAuth, slack } from "better-auth/plugins"

export const auth = betterAuth({
  plugins: [
    genericOAuth({
      config: [
        slack({
          clientId: process.env.SLACK_CLIENT_ID,
          clientSecret: process.env.SLACK_CLIENT_SECRET,
        }),
      ],
    }),
  ],
})
```

```ts title="sign-in.ts"
const response = await authClient.signIn.oauth2({
  providerId: "slack",
  callbackURL: "/dashboard",
})
```

For more pre-configured providers (Auth0, Keycloak, Okta, Microsoft Entra ID) and their configuration options, see the [Generic OAuth Plugin documentation](/docs/plugins/generic-oauth#pre-configured-provider-helpers).

## Manual Configuration Examples

If you need to configure a provider that doesn't have a pre-configured helper, you can manually configure it:

### Instagram Example

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { genericOAuth } from "better-auth/plugins";

export const auth = betterAuth({
  // ... other config options
  plugins: [
    genericOAuth({
      config: [
        {
          providerId: "instagram",
          clientId: process.env.INSTAGRAM_CLIENT_ID as string,
          clientSecret: process.env.INSTAGRAM_CLIENT_SECRET as string,
          authorizationUrl: "https://api.instagram.com/oauth/authorize",
          tokenUrl: "https://api.instagram.com/oauth/access_token",
          scopes: ["user_profile", "user_media"],
        },
      ],
    }),
  ],
});
```

```ts title="sign-in.ts"
const response = await authClient.signIn.oauth2({
  providerId: "instagram",
  callbackURL: "/dashboard", // the path to redirect to after the user is authenticated
});
```

### Coinbase Example

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { genericOAuth } from "better-auth/plugins";

export const auth = betterAuth({
  // ... other config options
  plugins: [
    genericOAuth({
      config: [
        {
          providerId: "coinbase",
          clientId: process.env.COINBASE_CLIENT_ID as string,
          clientSecret: process.env.COINBASE_CLIENT_SECRET as string,
          authorizationUrl: "https://www.coinbase.com/oauth/authorize",
          tokenUrl: "https://api.coinbase.com/oauth/token",
          scopes: ["wallet:user:read"], // and more...
        },
      ],
    }),
  ],
});
```

```ts title="sign-in.ts"
const response = await authClient.signIn.oauth2({
  providerId: "coinbase",
  callbackURL: "/dashboard", // the path to redirect to after the user is authenticated
});
```
---
title: Facebook
description: Facebook provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Facebook credentials
        To use Facebook sign in, you need a client ID and client Secret. You can get them from the [Facebook Developer Portal](https://developers.facebook.com/).
        Select your app, navigate to **App Settings > Basic**, locate the following:  
        - **App ID**: This is your `clientId`
        - **App Secret**: This is your `clientSecret`.

        <Callout type="warn">
        Avoid exposing the `clientSecret` in client-side code (e.g., frontend apps) because it’s sensitive information.
        </Callout>

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/facebook` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"  
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                facebook: { // [!code highlight]
                    clientId: process.env.FACEBOOK_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.FACEBOOK_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```

        <Callout>
        BetterAuth also supports Facebook Login for Business, all you need
        to do is provide the `configId` as listed in **Facebook Login For Business > Configurations** alongside your `clientId` and `clientSecret`. Note that the app must be a Business app and, since BetterAuth expects to have an email address and account id, the configuration must be of the "User access token" type. "System-user access token" is not supported.
        </Callout>
    </Step>
       <Step>
        ### Sign In with Facebook
        To sign in with Facebook, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `facebook`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/auth-client"
        const authClient = createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "facebook"
            })
        }
        ```
    </Step>
</Steps>

## Additional Configuration

### Scopes
By default, Facebook provides basic user information. If you need additional permissions, you can specify scopes in your auth configuration:

```ts title="auth.ts"
export const auth = betterAuth({
    socialProviders: {
        facebook: {
            clientId: process.env.FACEBOOK_CLIENT_ID as string,
            clientSecret: process.env.FACEBOOK_CLIENT_SECRET as string,
            scopes: ["email", "public_profile", "user_friends"], // Overwrites permissions
            fields: ["user_friends"], // Extending list of fields
        },
    },
})
```

Additional options:
- `scopes`: Access basic account information (overwrites).
    - Default: `"email", "public_profile"`
- `fields`: Extend list of fields to retrieve from the Facebook user profile (assignment).
    - Default: `"id", "name", "email", "picture"`

### Sign In with Facebook With ID or Access Token

To sign in with Facebook using the ID Token, you can use the `signIn.social` function to pass the ID Token.

This is useful when you have the ID Token from Facebook on the client-side and want to use it to sign in on the server.

<Callout>
 If ID token is provided no redirection will happen, and the user will be signed in directly.
</Callout>

For limited login, you need to pass `idToken.token`, for only `accessToken` you need to pass `idToken.accessToken` and `idToken.token` together because of (#1183)[https://github.com/better-auth/better-auth/issues/1183].


```ts title="auth-client.ts"
const data = await authClient.signIn.social({
    provider: "facebook",
    idToken: {  // [!code highlight]
        ...(platform === 'ios' ?  // [!code highlight]
            { token: idToken }  // [!code highlight]
            : { token: accessToken, accessToken: accessToken }), // [!code highlight]
    },
})
```

For a complete list of available permissions, refer to the [Permissions Reference](https://developers.facebook.com/docs/permissions).
---
title: PayPal
description: Paypal provider setup and usage.
---

<Steps>
    <Step>
        ### Get your PayPal Credentials
        To integrate with PayPal, you need to obtain API credentials by creating an application in the [PayPal Developer Portal](https://developer.paypal.com/dashboard).

         Follow these steps:
            1. Create an account on the PayPal Developer Portal
            2. Create a new application, [official docs]( https://developer.paypal.com/developer/applications/)
            3. Configure Log in with PayPal under "Other features"
            4. Set up your Return URL (redirect URL)
            5. Configure user information permissions
            6. Note your Client ID and Client Secret

        <Callout type="info">
            - PayPal has two environments: Sandbox (for testing) and Live (for production)
            - For testing, create sandbox test accounts in the Developer Dashboard under "Sandbox" → "Accounts"
            - You cannot use your real PayPal account to test in sandbox mode - you must use the generated test accounts
            - The Return URL in your PayPal app settings must exactly match your redirect URI
            - The PayPal API does not work with localhost. You need to use a public domain for the redirect URL and HTTPS for local testing. You can use [NGROK](https://ngrok.com/) or another similar tool for this.
        </Callout>
         Make sure to configure "Log in with PayPal" in your app settings:
            1. Go to your app in the Developer Dashboard
            2. Under "Other features", check "Log in with PayPal"
            3. Click "Advanced Settings"
            4. Enter your Return URL
            5. Select the user information you want to access (email, name, etc.)
            6. Enter Privacy Policy and User Agreement URLs

        <Callout type="info">
            - PayPal doesn't use traditional OAuth2 scopes in the authorization URL. Instead, you configure permissions directly in the Developer Dashboard
            - For live apps, PayPal must review and approve your application before it can go live, which typically takes a few weeks
        </Callout>
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                paypal: { // [!code highlight]
                    clientId: process.env.PAYPAL_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.PAYPAL_CLIENT_SECRET as string, // [!code highlight]
                    environment: "sandbox", // or "live" for production //, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
        #### Options
        The PayPal provider accepts the following options:
    
        - `environment`: `'sandbox' | 'live'` - PayPal environment to use (default: `'sandbox'`)
        - `requestShippingAddress`: `boolean` - Whether to request shipping address information (default: `false`)
    
        ```ts title="auth.ts"
        export const auth = betterAuth({
            socialProviders: {
                paypal: {
                    clientId: process.env.PAYPAL_CLIENT_ID as string,
                    clientSecret: process.env.PAYPAL_CLIENT_SECRET as string,
                    environment: "live", // Use "live" for production
                    requestShippingAddress: true, // Request address info
                },
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with PayPal
        To sign in with PayPal, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `paypal`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "paypal"
            })
        }
        ```
        ### Additional Options:
        - `environment`: PayPal environment to use.
            - Default: `"sandbox"`
            - Options: `"sandbox"` | `"live"`
        - `requestShippingAddress`: Whether to request shipping address information.
            - Default: `false`
        - `scope`: Additional scopes to request (combined with default permissions).
            - Default: Configured in PayPal Developer Dashboard
            - Note: PayPal doesn't use traditional OAuth2 scopes - permissions are set in the Dashboard
            For more details refer to the [Scopes Reference](https://developer.paypal.com/docs/log-in-with-paypal/integrate/reference/#scope-attributes)
        - `mapProfileToUser`: Custom function to map PayPal profile data to user object.
        - `getUserInfo`: Custom function to retrieve user information.
        For more details refer to the [User Reference](https://developer.paypal.com/docs/api/identity/v1/#userinfo_get)
        - `verifyIdToken`: Custom ID token verification function.   
    </Step>

</Steps>
---
title: Paybin
description: Paybin provider setup and usage.
---

<Steps>
    <Step>
        ### Get your Paybin credentials
        To use Paybin sign in, you need to create an OAuth 2.0 Client through your Paybin Portfolio application.

        1. Log in to your [Paybin Portfolio](https://portfolio.paybin.io)
        2. Navigate to Developer Settings or OAuth Applications section
        3. Click "Create OAuth Application" or "New Application"
        4. Fill in the required fields:
           - **Application Name**: The name shown to users during authorization
           - **Redirect URIs**: Set to `http://localhost:3000/api/auth/callback/paybin` for local development. For production, set it to `https://yourdomain.com/api/auth/callback/paybin`. If you change the base path of the auth routes, update the redirect URI accordingly.

        5. After creation, copy the Client ID and Client Secret to your environment variables. Keep these credentials secure.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                paybin: { // [!code highlight]
                    clientId: process.env.PAYBIN_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.PAYBIN_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
    <Step>
        ### Sign In with Paybin
        To sign in with Paybin, you can use the `signIn.social` function provided by the client, where the `provider` should be set to `paybin`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient = createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "paybin"
            })
        }
        ```
    </Step>

</Steps>

## Additional Configuration

### Scopes
By default, Paybin provider requests the following scopes: `openid`, `email`, and `profile`. You can customize the scopes based on your application's needs.

For a complete list of available scopes and their descriptions, see the [Paybin OIDC Scopes Documentation](https://developers.paybin.io/knowledge-center/oidc#available-scopes).

```ts title="auth.ts"
export const auth = betterAuth({
    socialProviders: {
        paybin: {
            clientId: process.env.PAYBIN_CLIENT_ID as string,
            clientSecret: process.env.PAYBIN_CLIENT_SECRET as string,
            scope: ["openid", "email", "profile", "transactions"], // [!code highlight]
        },
    },
})
```

### User Profile Mapping
Paybin returns user information in the ID token following OpenID Connect standards. The provider automatically extracts:
- `id` from `sub` claim
- `name` from `name`, `preferred_username`, or `email` (in order of preference)
- `email` from `email` claim
- `image` from `picture` claim
- `emailVerified` from `email_verified` claim
---
title: Kick
description: Kick provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Kick Credentials
        To use Kick sign in, you need a client ID and client secret. You can get them from the [Kick Developer Portal](https://kick.com/settings/developer).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/kick` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"  
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                kick: { // [!code highlight]
                    clientId: process.env.KICK_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.KICK_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            }
        })
        ```
    </Step>
       <Step>
        ### Sign In with Kick
        To sign in with Kick, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `kick`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "kick"
            })
        }
        ```
    </Step>
</Steps>
---
title: Atlassian
description: Atlassian provider setup and usage.
---

<Steps>
    <Step>
        ### Get your Credentials
        1. Sign in to your Atlassian account and go to the [Atlassian Developer Console](https://developer.atlassian.com/console/myapps/)
        2. Click "Create new app"
        3. Fill out the app details
        4. Configure your redirect URI (e.g., `https://yourdomain.com/api/auth/callback/atlassian`)
        5. Note your Client ID and Client Secret

        <Callout type="info">
            - The default scope is `read:jira-user` and `offline_access`. For additional scopes, refer to the [Atlassian OAuth documentation](https://developer.atlassian.com/cloud/confluence/oauth-2-3lo-apps/).
        </Callout>

        Make sure to set the redirect URI to match your application's callback URL. If you change the base path of the auth routes, you should update the redirect URI accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                atlassian: { // [!code highlight]
                    clientId: process.env.ATLASSIAN_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.ATLASSIAN_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Atlassian
        To sign in with Atlassian, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `atlassian`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "atlassian"
            })
        }
        ```
        <Callout type="info">
        For more information about Atlassian's OAuth scopes and API capabilities, refer to the [official Atlassian OAuth 2.0 (3LO) apps documentation](https://developer.atlassian.com/cloud/confluence/oauth-2-3lo-apps/).
        </Callout>
    </Step>

</Steps>
---
title: LINE
description: LINE provider setup and usage.
---

<Steps>
    <Step>
        ### Get your LINE credentials

        1. Create a channel in the LINE Developers Console.
        2. Note your Channel ID (client_id) and Channel secret (client_secret).
        3. In the channel settings, add your Redirect URI, e.g. `http://localhost:3000/api/auth/callback/line` for local development.
        4. Enable required scopes (at least `openid`; add `profile`, `email` if you need name, avatar, email).

        See LINE Login v2.1 reference for details: [`https://developers.line.biz/en/reference/line-login/#issue-access-token`]
    </Step>

    <Step>
        ### Configure the provider

        Add your LINE credentials to `socialProviders.line` in your auth configuration.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";

        export const auth = betterAuth({
          socialProviders: {
            line: {
              clientId: process.env.LINE_CLIENT_ID as string,
              clientSecret: process.env.LINE_CLIENT_SECRET as string,
              // redirectURI: "https://your.app/api/auth/callback/line", // uncomment to use a custom redirect URI
              // scope: ["custom"], // uncomment to add additional scopes
              // disableDefaultScope: true, // uncomment to replace default scopes [`openid`, `profile`, `email`]
            },
          },
        });
        ```
    </Step>
</Steps>

## Usage

### Sign In with LINE

Use the client `signIn.social` with `provider: "line"`.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
const authClient = createAuthClient();

async function signInWithLINE() {
  const res = await authClient.signIn.social({ provider: "line" });
}
```

### Sign In with LINE using ID Token (optional)

If you obtain the LINE ID token on the client, you can sign in directly without redirection.

```ts title="auth-client.ts"
await authClient.signIn.social({
  provider: "line",
  idToken: {
    token: "<LINE_ID_TOKEN>",
    accessToken: "<LINE_ACCESS_TOKEN>",
  },
});
```

### Notes

- Default scopes include `openid profile email`. Adjust as needed via provider options.
- Verify redirect URI exactly matches the value configured in LINE Developers Console.
- LINE ID token verification uses the official endpoint and checks audience and optional nonce per spec.

Designing a login button? Follow LINE's button [guidelines](https://developers.line.biz/en/docs/line-login/login-button/).

## Multi-Channel Support

LINE requires separate OAuth channels for different countries (Japan, Thailand, Taiwan, etc.), each with its own `clientId` and `clientSecret`. The standard `socialProviders.line` configuration only supports a single channel.

To support multiple countries/channels, use the [Generic OAuth plugin](/docs/plugins/generic-oauth) with the `line()` helper function. This allows you to configure multiple LINE providers with different `providerId`s:

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { genericOAuth, line } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    genericOAuth({
      config: [
        // Japan channel
        line({
          providerId: "line-jp",
          clientId: process.env.LINE_JP_CLIENT_ID,
          clientSecret: process.env.LINE_JP_CLIENT_SECRET,
        }),
        // Thailand channel
        line({
          providerId: "line-th",
          clientId: process.env.LINE_TH_CLIENT_ID,
          clientSecret: process.env.LINE_TH_CLIENT_SECRET,
        }),
        // Taiwan channel
        line({
          providerId: "line-tw",
          clientId: process.env.LINE_TW_CLIENT_ID,
          clientSecret: process.env.LINE_TW_CLIENT_SECRET,
        }),
      ],
    }),
  ],
});
```

When signing in, use the appropriate `providerId` (e.g., `"line-jp"`, `"line-th"`, `"line-tw"`) to identify which channel to use:

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
import { genericOAuthClient } from "better-auth/client/plugins";

const authClient = createAuthClient({
  plugins: [genericOAuthClient()],
});

// Sign in with Japan channel
await authClient.signIn.social({ provider: "line-jp" });

// Sign in with Thailand channel
await authClient.signIn.social({ provider: "line-th" });
```

---
title: Google
description: Google provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Google credentials
        To use Google as a social provider, you need to get your Google credentials. You can get them by creating a new project in the [Google Cloud Console](https://console.cloud.google.com/apis/dashboard).

        In the Google Cloud Console > Credentials > Authorized redirect URIs, make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/google` for local development. For production, make sure to set the redirect URL as your application domain, e.g. `https://example.com/api/auth/callback/google`. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        <Callout type="info">
        **Creating Your Google OAuth Credentials**

        If you haven't created OAuth credentials yet, follow these step-by-step instructions:

        1. Open **Google Cloud Console** → **APIs & Services** → **Credentials**
        2. Click **Create Credentials** → **OAuth client ID**
        3. Choose **Web application**
        4. Add your redirect URIs:
           - `http://localhost:3000/api/auth/callback/google` (for local development)
           - `https://your-domain.com/api/auth/callback/google` (for production)
        5. Copy the **Client ID** and **Client Secret** into your environment variables

        These steps avoid common issues such as `redirect_uri_mismatch`.
        </Callout>
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.google` in your auth configuration.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            baseURL: process.env.BETTER_AUTH_URL, // [!code highlight]
            socialProviders: {
                google: { // [!code highlight]
                    clientId: process.env.GOOGLE_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
        <Callout type="warn">
        **Important: Set Your Base URL**

        You must configure the `baseURL` to avoid `redirect_uri_mismatch` errors. Better Auth uses this to construct the OAuth callback URL sent to Google.

        **Option 1: Environment Variable (Recommended)**

        Add to your `.env` file:
        ```dotenv
        BETTER_AUTH_URL=https://your-domain.com
        ```

        **Option 2: Explicit Configuration**

        Pass `baseURL` directly in the auth config as shown above.
        Without this, the callback URL may default to `localhost`, causing Google OAuth to fail in production.
        </Callout>
    </Step>

</Steps>

## Usage

### Sign In with Google

To sign in with Google, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:

- `provider`: The provider to use. It should be set to `google`.

```ts title="auth-client.ts"  /
import { createAuthClient } from "better-auth/client";
const authClient = createAuthClient();

const signIn = async () => {
  const data = await authClient.signIn.social({
    provider: "google",
  });
};
```

### Sign In with Google With ID Token

To sign in with Google using the ID Token, you can use the `signIn.social` function to pass the ID Token.

This is useful when you have the ID Token from Google on the client-side and want to use it to sign in on the server.

<Callout>
  If ID token is provided no redirection will happen, and the user will be
  signed in directly.
</Callout>

```ts title="auth-client.ts"
const data = await authClient.signIn.social({
    provider: "google",
    idToken: {
        token: // Google ID Token,
        accessToken: // Google Access Token
    }
})
```

<Callout>
  If you want to use google one tap, you can use the [One Tap
  Plugin](/docs/plugins/one-tap) guide.
</Callout>

### Always ask to select an account

If you want to always ask the user to select an account, you pass the `prompt` parameter to the provider, setting it to `select_account`.

```ts
socialProviders: {
    google: {
        prompt: "select_account", // [!code highlight]
        clientId: process.env.GOOGLE_CLIENT_ID as string,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,
    },
}
```

### Requesting Additional Google Scopes

If your application needs additional Google scopes after the user has already signed up (e.g., for Google Drive, Gmail, or other Google services), you can request them using the `linkSocial` method with the same Google provider.

```tsx title="auth-client.ts"
const requestGoogleDriveAccess = async () => {
  await authClient.linkSocial({
    provider: "google",
    scopes: ["https://www.googleapis.com/auth/drive.file"],
  });
};

// Example usage in a React component
return (
  <button onClick={requestGoogleDriveAccess}>
    Add Google Drive Permissions
  </button>
);
```

This will trigger a new OAuth flow that requests the additional scopes. After completion, your account will have the new scope in the database, and the access token will give you access to the requested Google APIs.

<Callout>
  Ensure you're using Better Auth version 1.2.7 or later to avoid "Social
  account already linked" errors when requesting additional scopes from the same
  provider.
</Callout>

### Always get refresh token

Google only issues a refresh token the first time a user consents to your app.
If the user has already authorized your app, subsequent OAuth flows will only return an access token, not a refresh token.

To always get a refresh token, you can set the `accessType` to `offline`, and `prompt` to `select_account consent` in the provider options.

```ts
socialProviders: {
    google: {
        clientId: process.env.GOOGLE_CLIENT_ID as string,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,
        accessType: "offline", // [!code highlight]
        prompt: "select_account consent", // [!code highlight]
    },
}
```

<Callout>
  **Revoking Access:** If you want to get a new refresh token for a user who has
  already authorized your app, you must have them revoke your app's access in
  their Google account settings, then re-authorize.
</Callout>
---
title: Vercel
description: Vercel provider setup and usage.
---

<Steps>
    <Step>
        ### Get your Vercel credentials
        To use Sign in with Vercel, you need a client ID and client secret. You can get them from the [Vercel Dashboard](https://vercel.com/dashboard) by [creating a Vercel App](https://vercel.com/docs/sign-in-with-vercel/manage-from-dashboard).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/vercel` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        <Callout type="info">
            Vercel requires PKCE (Proof Key for Code Exchange) for enhanced security. This is automatically handled by Better Auth.
        </Callout>
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts" 
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({ 
            socialProviders: {
                vercel: { // [!code highlight]
                    clientId: process.env.VERCEL_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.VERCEL_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
</Steps>

## Usage

### Sign in with Vercel 

To sign in with Vercel, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:

- `provider`: The provider to use. It should be set to `vercel`.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
const authClient = createAuthClient()

const signIn = async () => {
    const data = await authClient.signIn.social({
        provider: "vercel"
    })
}
```

## Options

For the full list of options supported by all social providers, check the [Provider Options](/docs/concepts/oauth#provider-options).

### Available Scopes

Vercel supports the following OpenID Connect scopes:

- `openid` (default): Returns the user's unique identifier in the ID token
- `email`: Returns the user's email address
- `profile`: Returns the user's profile information (name, picture)
- `offline_access`: Returns a refresh token for offline access

Scopes are configured on the Vercel App, and so it is not necessary to pass a `scope` parameter to the provider and it is more convenient to omit it.

If you do pass a `scope` parameter, it has the effect of requesting a subset of the configured scopes:

```ts title="auth.ts"
import { betterAuth } from "better-auth"

export const auth = betterAuth({
    socialProviders: {
        vercel: {
            clientId: process.env.VERCEL_CLIENT_ID as string,
            clientSecret: process.env.VERCEL_CLIENT_SECRET as string,
            scope: ["openid", "email", "profile"], // [!code highlight]
        },
    },
})
```

<Callout type="info">
    For more information about Vercel's scopes and API capabilities, refer to the [official Vercel documentation](https://vercel.com/docs/sign-in-with-vercel).
</Callout>
---
title: Polar
description: Polar provider setup and usage.
---

<Steps>
    <Step>
        ### Get your Polar credentials
        To use Polar sign in, you need to create an OAuth 2.0 Client. You can get your credentials from the [Polar User Settings](https://polar.sh/dashboard/account/developer).

        1. Go to your [Polar User Settings](https://polar.sh/settings#oauth)
        2. Click "Create OAuth Client"
        3. Fill in the required fields:
           - **Application Name**: The name shown to users during authorization
           - **Client Type**: Choose the appropriate client type for your application
           - **Redirect URIs**: Set to `http://localhost:3000/api/auth/callback/polar` for local development. For production, set it to `https://yourdomain.com/api/auth/callback/polar`. If you change the base path of the auth routes, update the redirect URI accordingly.
           - **Scopes**: Select the permissions your application needs (openid, profile, email are default)
           - **Homepage URL**: Your application's main URL

        4. Optionally, add:
           - Logo for your application
           - Terms of service URL
           - Privacy policy URL

        5. After creation, copy the Client ID and Client Secret to your environment variables. Keep these credentials secure.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                polar: { // [!code highlight]
                    clientId: process.env.POLAR_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.POLAR_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Polar
        To sign in with Polar, you can use the `signIn.social` function provided by the client, where the `provider` should be set to `polar`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "polar"
            })
        }
        ```
    </Step>

</Steps>
---
title: Twitch
description: Twitch provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Twitch Credentials
        To use Twitch sign in, you need a client ID and client secret. You can get them from the [Twitch Developer Portal](https://dev.twitch.tv/console/apps).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/twitch` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"  
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                twitch: { // [!code highlight]
                    clientId: process.env.TWITCH_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.TWITCH_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            }
        })
        ```
    </Step>
       <Step>
        ### Sign In with Twitch 
        To sign in with Twitch, you can use the `signIn.social` function provided by the client.
        The `signIn` function takes an object with the following properties:

        - `provider`: The provider to use. It should be set to `twitch`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "twitch"
            })
        }
        ```

        <Callout type="warn">
            Twitch users who do not have an email address will not be able to sign in.
        </Callout>
    </Step>
</Steps>
---
title: Kakao
description: Kakao provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Kakao Credentials
        To use Kakao sign in, you need a client ID and client secret. You can get them from the [Kakao Developer Portal](https://developers.kakao.com).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/kakao` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>
    <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        <Callout type="info">
            - The default scopes are `account_email`, `profile_image`, and `profile_nickname`. 
            - Note that retrieving `account_email` requires the app to be a **Biz App** (an app that has completed business verification). For more details, refer to the [Kakao Login scopes documentation](https://developers.kakao.com/docs/latest/kakaologin/utilize#scope-user).
        </Callout>

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                kakao: { // [!code highlight]
                    clientId: process.env.KAKAO_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.KAKAO_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            }
        })
        ```
    </Step>
    <Step>
        ### Sign In with Kakao
        To sign in with Kakao, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `kakao`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "kakao"
            })
        }
        ```
    </Step>
</Steps>
---
title: Linear
description: Linear provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Linear credentials
        To use Linear sign in, you need a client ID and client secret. You can get them from the [Linear Developer Portal](https://linear.app/settings/api).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/linear` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        When creating your OAuth application in Linear, you'll need to specify the required scopes. The default scope is `read`, but you can also request additional scopes like `write` if needed.
    </Step>

    <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                linear: { // [!code highlight]
                    clientId: process.env.LINEAR_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.LINEAR_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>

    <Step>
        ### Sign In with Linear
        To sign in with Linear, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `linear`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient = createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "linear"
            })
        }
        ```
    </Step>

    <Step>
        ### Available scopes
        Linear OAuth supports the following scopes:
        - `read` (default): Read access for the user's account
        - `write`: Write access for the user's account
        - `issues:create`: Allows creating new issues and their attachments
        - `comments:create`: Allows creating new issue comments
        - `timeSchedule:write`: Allows creating and modifying time schedules
        - `admin`: Full access to admin level endpoints (use with caution)

        You can specify additional scopes when configuring the provider:

        ```ts title="auth.ts"
        export const auth = betterAuth({
            socialProviders: {
                linear: {
                    clientId: process.env.LINEAR_CLIENT_ID as string,
                    clientSecret: process.env.LINEAR_CLIENT_SECRET as string,
                    scope: ["read", "write"] // [!code highlight]
                },
            },
        })
        ```
    </Step>
</Steps>
---
title: Roblox
description: Roblox provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Roblox Credentials
        Get your Roblox credentials from the [Roblox Creator Hub](https://create.roblox.com/dashboard/credentials?activeTab=OAuthTab).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/roblox` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
        
        <Callout type="info">
            The Roblox API does not provide email addresses. As a workaround, the user's `email` field uses the `preferred_username` value instead.
        </Callout>
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"  
        import { betterAuth } from "better-auth" 
        
        export const auth = betterAuth({
            socialProviders: {
                roblox: { // [!code highlight]
                    clientId: process.env.ROBLOX_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.ROBLOX_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Roblox 
        To sign in with Roblox, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `roblox`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "roblox"
            })
        }
        ```
    </Step>
</Steps>
---
title: Reddit
description: Reddit provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Reddit Credentials
        To use Reddit sign in, you need a client ID and client secret. You can get them from the [Reddit Developer Portal](https://www.reddit.com/prefs/apps).

        1. Click "Create App" or "Create Another App"
        2. Select "web app" as the application type
        3. Set the redirect URL to `http://localhost:3000/api/auth/callback/reddit` for local development
        4. For production, set it to your application's domain (e.g. `https://example.com/api/auth/callback/reddit`)
        5. After creating the app, you'll get the client ID (under the app name) and client secret

        If you change the base path of the auth routes, make sure to update the redirect URL accordingly.
    </Step>

    <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({
            socialProviders: {
                reddit: {
                    clientId: process.env.REDDIT_CLIENT_ID as string,
                    clientSecret: process.env.REDDIT_CLIENT_SECRET as string,
                },
            },
        })
        ```
    </Step>

    <Step>
        ### Sign In with Reddit
        To sign in with Reddit, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `reddit`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient = createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "reddit"
            })
        }
        ```
    </Step>
</Steps>

## Additional Configuration

### Scopes
By default, Reddit provides basic user information. If you need additional permissions, you can specify scopes in your auth configuration:

```ts title="auth.ts"
export const auth = betterAuth({
    socialProviders: {
        reddit: {
            clientId: process.env.REDDIT_CLIENT_ID as string,
            clientSecret: process.env.REDDIT_CLIENT_SECRET as string,
            duration: "permanent",
            scope: ["read", "submit"] // Add required scopes
        },
    },
})
```

Common Reddit scopes include:
- `identity`: Access basic account information
- `read`: Access posts and comments
- `submit`: Submit posts and comments
- `subscribe`: Manage subreddit subscriptions
- `history`: Access voting history

For a complete list of available scopes, refer to the [Reddit OAuth2 documentation](https://www.reddit.com/dev/api/oauth).
---
title: Twitter (X)
description: Twitter provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Twitter Credentials
        Get your Twitter credentials from the [Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/twitter` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
        
        <Callout type="info">
            Twitter API v2 now supports email address retrieval. Make sure to request the `user.email` scope when configuring your Twitter app to enable this feature.
        </Callout>
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"  
        import { betterAuth } from "better-auth" 
        
        export const auth = betterAuth({
            socialProviders: {
                twitter: { // [!code highlight]
                    clientId: process.env.TWITTER_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.TWITTER_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with Twitter 
        To sign in with Twitter, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `twitter`.

        ```ts title="auth-client.ts"  
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()
        
        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "twitter"
            })
        }
        ```
    </Step>
</Steps>
---
title: Discord
description: Discord provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Discord credentials
        To use Discord sign in, you need a client ID and client secret. You can get them from the [Discord Developer Portal](https://discord.com/developers/applications).

        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/discord` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts" 
        import { betterAuth } from "better-auth"
        
        export const auth = betterAuth({ 
            socialProviders: {
                discord: { // [!code highlight]
                    clientId: process.env.DISCORD_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.DISCORD_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
</Steps>

## Usage

### Sign In with Discord 

To sign in with Discord, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
- `provider`: The provider to use. It should be set to `discord`.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client"
const authClient =  createAuthClient()

const signIn = async () => {
    const data = await authClient.signIn.social({
        provider: "discord"
    })
}
```

## Options

For the full list of options supported by all social providers, check the [Provider Options](/docs/concepts/oauth#provider-options).

### Bot Permissions (Optional)

If you're using the `bot` scope with Discord OAuth, you can specify bot permissions using the `permissions` option. It can either be a bitwise value (e.g `2048 | 16384` for Send Messages and Embed Links) or a specific permission value (e.g `16384` for Embed Links).

```ts title="auth.ts" 
import { betterAuth } from "better-auth"

export const auth = betterAuth({ 
    socialProviders: {
        discord: {
            clientId: process.env.DISCORD_CLIENT_ID as string,
            clientSecret: process.env.DISCORD_CLIENT_SECRET as string,
            permissions: 2048 | 16384, // Send Messages + Embed Links // [!code highlight]
        }, 
    },
})
```

**Note:** The `permissions` parameter only works when the `bot` scope is included in your OAuth2 scopes. Read more about [Discord bot permissions](https://discord.com/developers/docs/topics/permissions).---
title: LinkedIn
description: LinkedIn Provider
---

<Steps>
    <Step> 
        ### Get your LinkedIn credentials
        To use LinkedIn sign in, you need a client ID and client secret. You can get them from the [LinkedIn Developer Portal](https://www.linkedin.com/developers/).
        
        Make sure to set the redirect URL to `http://localhost:3000/api/auth/callback/linkedin` for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.
    </Step>

    <Callout type="info">
     In the LinkedIn portal under products you need the **Sign In with LinkedIn using OpenID Connect** product.
    </Callout>

    There are some different Guides here:
        [Authorization Code Flow (3-legged OAuth) (Outdated)](https://learn.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow)
        [Sign In with LinkedIn using OpenID Connect](https://learn.microsoft.com/en-us/linkedin/consumer/integrations/self-serve/sign-in-with-linkedin-v2?context=linkedin%2Fconsumer%2Fcontext)

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                linkedin: { // [!code highlight]
                    clientId: process.env.LINKEDIN_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.LINKEDIN_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with LinkedIn
        To sign in with LinkedIn, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `linkedin`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "linkedin"
            })
        }
        ```
    </Step>

</Steps>
---
title: Slack
description: Slack provider setup and usage.
---

<Steps>
    <Step> 
        ### Get your Slack credentials
        To use Slack as a social provider, you need to create a Slack app and get your credentials.

        1. Go to [Your Apps on Slack API](https://api.slack.com/apps) and click "Create New App"
        2. Choose "From scratch" and give your app a name and select a development workspace
        3. In your app settings, navigate to "OAuth & Permissions"
        4. Under "Redirect URLs", add your redirect URL:
           - For local development: `http://localhost:3000/api/auth/callback/slack`
           - For production: `https://yourdomain.com/api/auth/callback/slack`
        5. Copy your Client ID and Client Secret from the "Basic Information" page

        <Callout>
            Slack requires HTTPS for redirect URLs in production. For local development, you can use tools like [ngrok](https://ngrok.com/) to create a secure tunnel.
        </Callout>
    </Step>

    <Step>
        ### Configure the provider
        To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.slack` in your auth configuration.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                slack: { // [!code highlight]
                    clientId: process.env.SLACK_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.SLACK_CLIENT_SECRET as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>

</Steps>

## Usage

### Sign In with Slack

To sign in with Slack, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:

- `provider`: The provider to use. It should be set to `slack`.

```ts title="auth-client.ts"
import { createAuthClient } from "better-auth/client";
const authClient = createAuthClient();

const signIn = async () => {
  const data = await authClient.signIn.social({ provider: "slack" });
};
```

### Requesting Additional Scopes

By default, Slack uses OpenID Connect scopes: `openid`, `profile`, and `email`. You can request additional Slack scopes during sign-in:

```ts title="auth-client.ts"
const signInWithSlack = async () => {
  await authClient.signIn.social({
    provider: "slack",
    scopes: ["channels:read", "chat:write"], // Additional Slack API scopes
  });
};
```

### Workspace-Specific Sign In

If you want to restrict sign-in to a specific Slack workspace, you can pass the `team` parameter:

```ts title="auth.ts"
socialProviders: {
    slack: {
        clientId: process.env.SLACK_CLIENT_ID as string,
        clientSecret: process.env.SLACK_CLIENT_SECRET as string,
        team: "T1234567890", // Your Slack workspace ID
    },
}
```

### Using Slack API After Sign In

After successful authentication, you can access the user's Slack information through the session. The access token can be used to make requests to the Slack API:

```ts
const session = await authClient.getSession();
if (session?.user) {
  // Access Slack-specific data
  const slackUserId = session.user.id; // This is the Slack user ID
  // The access token is stored securely on the server
}
```

<Callout>
  The Slack provider uses OpenID Connect by default, which provides basic user
  information. If you need to access other Slack APIs, make sure to request the
  appropriate scopes during sign-in.
</Callout>
---
title: Cognito
description: Amazon Cognito provider setup and usage.
---

<Steps>
  <Step>
    ### Get your Cognito Credentials
    To integrate with Cognito, you need to set up a **User Pool** and an **App client** in the [Amazon Cognito Console](https://console.aws.amazon.com/cognito/).

    Follow these steps:
    1. Go to the **Cognito Console** and create a **User Pool**.
    2. Under **App clients**, create a new **App client** (note the Client ID and Client Secret if enabled).
    3. Go to **Domain** and set a Cognito Hosted UI domain (e.g., `your-app.auth.us-east-1.amazoncognito.com`).
    4. In **App client settings**, enable:
       - Allowed OAuth flows: `Authorization code grant`
       - Allowed OAuth scopes: `openid`, `profile`, `email`
    5. Add your callback URL (e.g., `http://localhost:3000/api/auth/callback/cognito`).

    <Callout type="info">
      - **User Pool is required** for Cognito authentication.  
      - Make sure the callback URL matches exactly what you configure in Cognito.   
    </Callout>
  </Step>

  <Step>
    ### Configure the provider
    Configure the `cognito` key in `socialProviders` key of your `auth` instance.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";

    export const auth = betterAuth({
      socialProviders: {
        cognito: {
          clientId: process.env.COGNITO_CLIENT_ID as string, // [!code highlight]
          clientSecret: process.env.COGNITO_CLIENT_SECRET as string, // [!code highlight]
          domain: process.env.COGNITO_DOMAIN as string, // e.g. "your-app.auth.us-east-1.amazoncognito.com" [!code highlight]
          region: process.env.COGNITO_REGION as string, // e.g. "us-east-1" [!code highlight]
          userPoolId: process.env.COGNITO_USERPOOL_ID as string, // [!code highlight]
        },
      },
    })
    ```
  </Step>

  <Step>
    ### Sign In with Cognito
    To sign in with Cognito, use the `signIn.social` function from the client.  

    ```ts title="auth-client.ts"
    import { createAuthClient } from "better-auth/client"

    const authClient = createAuthClient()

    const signIn = async () => {
      const data = await authClient.signIn.social({
        provider: "cognito"
      })
    }
    ```
    
      ### Additional Options:
        - `scope`: Additional OAuth2 scopes to request (combined with default permissions).
            - Default: `"openid" "profile" "email"`
            - Common Cognito scopes:
              - `openid`: Required for OpenID Connect authentication
              - `profile`: Access to basic profile info
              - `email`: Access to user’s email
              - `phone`: Access to user’s phone number
              - `aws.cognito.signin.user.admin`: Grants access to Cognito-specific APIs
        - Note: You must configure the scopes in your Cognito App Client settings. [available scopes](https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html#token-endpoint-userinfo)
        - `getUserInfo`: Custom function to retrieve user information from the Cognito UserInfo endpoint.  
       <Callout type="info">
        For more information about Amazon Cognito's scopes and API capabilities, refer to the [official documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-define-resource-servers.html?utm_source).
        </Callout>
  </Step>
</Steps>
---
title: TikTok
description: TikTok provider setup and usage.
---

<Steps>
    <Step>
        ### Get your TikTok Credentials
        To integrate with TikTok, you need to obtain API credentials by creating an application in the [TikTok Developer Portal](https://developers.tiktok.com/apps).

        Follow these steps:
        1. Create an account on the TikTok Developer Portal
        2. Create a new application
        3. Set up a sandbox environment for testing
        4. Configure your redirect URL (must be HTTPS)
        5. Note your Client Secret and Client Key

        <Callout type="info">
            - The TikTok API does not work with localhost. You need to use a public domain for the redirect URL and HTTPS for local testing. You can use [NGROK](https://ngrok.com/) or another similar tool for this.
            - For testing, you will need to use the [Sandbox mode](https://developers.tiktok.com/blog/introducing-sandbox), which you can enable in the TikTok Developer Portal.
            - The default scope is `user.info.profile`. For additional scopes, refer to the [Available Scopes](https://developers.tiktok.com/doc/tiktok-api-scopes/) documentation.
        </Callout>

        Make sure to set the redirect URL to a valid HTTPS domain for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly.

        <Callout type="info">
            - The TikTok API does not provide email addresses. As a workaround, this implementation uses the user's `username` value for the `email` field, which is why it requires the `user.info.profile` scope instead of just `user.info.basic`.
            - For production use, you will need to request approval from TikTok for the scopes you intend to use.
        </Callout>
    </Step>

  <Step>
        ### Configure the provider
        To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                tiktok: { // [!code highlight]
                    clientSecret: process.env.TIKTOK_CLIENT_SECRET as string, // [!code highlight]
                    clientKey: process.env.TIKTOK_CLIENT_KEY as string, // [!code highlight]
                }, // [!code highlight]
            },
        })
        ```
    </Step>
       <Step>
        ### Sign In with TikTok
        To sign in with TikTok, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
        - `provider`: The provider to use. It should be set to `tiktok`.

        ```ts title="auth-client.ts"
        import { createAuthClient } from "better-auth/client"
        const authClient =  createAuthClient()

        const signIn = async () => {
            const data = await authClient.signIn.social({
                provider: "tiktok"
            })
        }
        ```
    </Step>

</Steps>
---
title: Apple
description: Apple provider setup and usage.
---
<Steps>
    <Step>
        ### Get your OAuth credentials
        To use Apple sign in, you need a client ID and client secret. You can get them from the [Apple Developer Portal](https://developer.apple.com/account/resources/authkeys/list).

        You will need an active **Apple Developer account** to access the developer portal and generate these credentials.

        Follow these steps to set up your App ID, Service ID, and generate the key needed for your client secret:

        1.  **Navigate to Certificates, Identifiers & Profiles:**
            In the Apple Developer Portal, go to the "Certificates, Identifiers & Profiles" section.

        2.  **Create an App ID:**
            *   Go to the `Identifiers` tab.
            *   Click the `+` icon next to Identifiers.
            *   Select `App IDs`, then click `Continue`.
            *   Select `App` as the type, then click `Continue`.
            *   **Description:** Enter a name for your app (e.g., "My Awesome App"). This name may be displayed to users when they sign in.
            *   **Bundle ID:** Set a bundle ID. The recommended format is a reverse domain name (e.g., `com.yourcompany.yourapp`). Using a suffix like `.ai` (for app identifier) can help with organization but is not required (e.g., `com.yourcompany.yourapp.ai`).
            *   Scroll down to **Capabilities**. Select the checkbox for `Sign In with Apple`.
            *   Click `Continue`, then `Register`.

        3.  **Create a Service ID:**
            *   Go back to the `Identifiers` tab.
            *   Click the `+` icon.
            *   Select `Service IDs`, then click `Continue`.
            *   **Description:** Enter a description for this service (e.g., your app name again).
            *   **Identifier:** Set a unique identifier for the service. Use a reverse domain format, distinct from your App ID (e.g., `com.yourcompany.yourapp.si`, where `.si` indicates service identifier - this is for your organization and not required). **This Service ID will be your `clientId`.**
            *   Click `Continue`, then `Register`.

        4.  **Configure the Service ID:**
            *   Find the Service ID you just created in the `Identifiers` list and click on it.
            *   Check the `Sign In with Apple` capability, then click `Configure`.
            *   Under **Primary App ID**, select the App ID you created earlier (e.g., `com.yourcompany.yourapp.ai`).
            *   Under **Domains and Subdomains**, list all the root domains you will use for Sign In with Apple (e.g., `example.com`, `anotherdomain.com`).
            *   Under **Return URLs**, enter the callback URL. `https://yourdomain.com/api/auth/callback/apple`. Add all necessary return URLs.
            *   Click `Next`, then `Done`.
            *   Click `Continue`, then `Save`.

        5.  **Create a Client Secret Key:**
            *   Go to the `Keys` tab.
            *   Click the `+` icon to create a new key.
            *   **Key Name:** Enter a name for the key (e.g., "Sign In with Apple Key").
            *   Scroll down and select the checkbox for `Sign In with Apple`.
            *   Click the `Configure` button next to `Sign In with Apple`.
            *   Select the **Primary App ID** you created earlier.
            *   Click `Save`, then `Continue`, then `Register`.
            *   **Download the Key:** Immediately download the `.p8` key file. **This file is only available for download once.** Note the Key ID (available on the Keys page after creation) and your Team ID (available in your Apple Developer Account settings).

        6.  **Generate the Client Secret (JWT):**
            Apple requires a JSON Web Token (JWT) to be generated dynamically using the downloaded `.p8` key, the Key ID, and your Team ID. This JWT serves as your `clientSecret`.

            You can use the guide below from [Apple's documentation](https://developer.apple.com/documentation/accountorganizationaldatasharing/creating-a-client-secret) to understand how to generate this client secret. You can also use our built in generator [below](#generate-apple-client-secret-jwt) to generate the client secret JWT required for 'Sign in with Apple'.

            **Note:** Apple allows a maximum expiration of 6 months (180 days) for the client secret JWT. You will need to regenerate the client secret before it expires to maintain uninterrupted authentication.


    </Step>
    <Step>
        ### Configure the provider
        To configure the provider, you need to add it to the `socialProviders` option of the auth instance.

        You also need to add `https://appleid.apple.com` to the `trustedOrigins` array in your auth instance configuration to allow communication with Apple's authentication servers.

        ```ts title="auth.ts"
        import { betterAuth } from "better-auth"

        export const auth = betterAuth({
            socialProviders: {
                apple: { // [!code highlight]
                    clientId: process.env.APPLE_CLIENT_ID as string, // [!code highlight]
                    clientSecret: process.env.APPLE_CLIENT_SECRET as string, // [!code highlight]
                    // Optional
                    appBundleIdentifier: process.env.APPLE_APP_BUNDLE_IDENTIFIER as string, // [!code highlight]
                }, // [!code highlight]
            },
            // Add appleid.apple.com to trustedOrigins for Sign In with Apple flows
            trustedOrigins: ["https://appleid.apple.com"], // [!code highlight]
        })
        ```

        On native iOS, it doesn't use the service ID but the app ID (bundle ID) as client ID, so if using the service ID as `clientId` in `signIn.social` with `idToken`, it throws an error: `JWTClaimValidationFailed: unexpected "aud" claim value`. So you need to provide the `appBundleIdentifier` when you want to sign in with Apple using the ID Token.
    </Step>
</Steps>

<Callout type="warn">
**Localhost and Non-TLS Restrictions**

Apple Sign In does **not** support `localhost` or non-HTTPS URLs. During development:
- You cannot use `http://localhost` as a return URL
- You must use a domain with valid HTTPS/TLS certificate

This limitation is enforced by Apple's security requirements and cannot be bypassed.
</Callout>

## Usage

### Sign In with Apple

To sign in with Apple, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties:
- `provider`: The provider to use. It should be set to `apple`.

```ts title="auth-client.ts"  /
import { createAuthClient } from "better-auth/client"
const authClient =  createAuthClient()

const signIn = async () => {
    const data = await authClient.signIn.social({
        provider: "apple"
    })
}
```


### Sign In with Apple With ID Token

To sign in with Apple using the ID Token, you can use the `signIn.social` function to pass the ID Token. 

This is useful when you have the ID Token from Apple on the client-side and want to use it to sign in on the server.

<Callout>
 If ID token is provided no redirection will happen, and the user will be signed in directly.
</Callout>

```ts title="auth-client.ts"
await authClient.signIn.social({
    provider: "apple",
    idToken: {
        token: // Apple ID Token,
        nonce: // Nonce (optional)
        accessToken: // Access Token (optional)
    }
})
```

## Generate Apple Client Secret (JWT)

<GenerateAppleJwt />
---
title: Contributing to BetterAuth
description: A concise guide to contributing to BetterAuth
---

Thank you for your interest in contributing to Better Auth! This guide is a concise guide to contributing to Better Auth.

## Getting Started

Before diving in, here are a few important resources:

- Take a look at our existing <Link href="https://github.com/better-auth/better-auth/issues">issues</Link> and <Link href="https://github.com/better-auth/better-auth/pulls">pull requests</Link>
- Join our community discussions in <Link href="https://discord.gg/better-auth">Discord</Link>


## Development Setup

To get started with development:

<Callout type="warn">
  Make sure you have <Link href="https://nodejs.org/en/download">Node.JS</Link>{" "}
  installed, preferably on LTS.
</Callout>

<Steps>

    <Step>
        ### 1. Fork the repository

        Visit https://github.com/better-auth/better-auth

        Click the "Fork" button in the top right.

    </Step>

    <Step>
        ### 2. Clone your fork

        ```bash
        # Replace YOUR-USERNAME with your GitHub username
        git clone https://github.com/YOUR-USERNAME/better-auth.git
        cd better-auth
        ```
    </Step>

    <Step>
        ### 3. Install dependencies

        Make sure you have <Link href="https://pnpm.io/installation">pnpm</Link> installed!

        ```bash
        pnpm install
        ```
    </Step>

    <Step>
        ### 4. Prepare ENV files

        Copy the example env file to create your new `.env` file.

        ```bash
        cp -n ./docs/.env.example ./docs/.env
        ```
    </Step>

</Steps>

## Making changes

Once you have an idea of what you want to contribute, you can start making changes. Here are some steps to get started:

<Steps>
    <Step>
        ### 1. Create a new branch

        ```bash
        # Add upstream remote (if not already added)
        git remote add upstream https://github.com/better-auth/better-auth.git

        # Make sure you're on canary
        git checkout canary

        # Pull latest changes
        git pull upstream canary

        # Create and switch to a new branch
        git checkout -b feature/your-feature-name
        ```
    </Step>
    <Step>
        ### 2. Start development server

        Start the development server:

        ```bash
        pnpm dev
        ```

        To start the docs server:

        ```bash
        pnpm -F docs dev
        ```
    </Step>
    <Step>
        ### 3. Make Your Changes

        * Make your changes to the codebase.

        * Write tests if needed. (Read more about testing <Link href="/docs/reference/contributing#testing">here</Link>)

        * Update documentation.  (Read more about documenting <Link href="/docs/reference/contributing#documentation">here</Link>)

    </Step>

</Steps>


### Issues and Bug Fixes

- Check our [GitHub issues](https://github.com/better-auth/better-auth/issues) for tasks labeled `good first issue`
- When reporting bugs, include steps to reproduce and expected behavior
- Comment on issues you'd like to work on to avoid duplicate efforts

### Framework Integrations

We welcome contributions to support more frameworks:

- Focus on framework-agnostic solutions where possible
- Keep integrations minimal and maintainable
- All integrations currently live in the main package

### Plugin Development

- For core plugins: Open an issue first to discuss your idea
- For community plugins: Feel free to develop independently
- Follow our plugin architecture guidelines

### Documentation

- Fix typos and errors
- Add examples and clarify existing content
- Ensure documentation is up to date with code changes

## Testing

We use Vitest for testing. Place test files next to the source files they test:

```ts
import { describe, it, expect } from "vitest";
import { getTestInstance } from "./test-utils/test-instance";

describe("Feature", () => {
    it("should work as expected", async () => {
        const { client } = await getTestInstance();
        // Test code here
        expect(result).toBeDefined();
    });
});
```

### Using the Test Instance Helper

The test instance helper now includes improved async context support for managing user sessions:

```ts
const { client, runWithUser, signInWithTestUser } = await getTestInstance();

// Run tests with a specific user context
await runWithUser("user@example.com", "password", async (headers) => {
    // All client calls within this block will use the user's session
    const response = await client.getSession();
    // headers are automatically applied
});

// Or use the test user with async context
const { runWithDefaultUser } = await signInWithTestUser();
await runWithDefaultUser(async (headers) => {
    // Code here runs with the test user's session context
});
```

### Testing Best Practices

- Write clear commit messages
- Update documentation to reflect your changes
- Add tests for new features
- Follow our coding standards
- Keep pull requests focused on a single change

## Need Help?

Don't hesitate to ask for help! You can:

- Open an <Link href="https://github.com/better-auth/better-auth/issues">issue</Link> with questions
- Join our <Link href="https://discord.gg/better-auth">community discussions</Link>
- Reach out to project maintainers

Thank you for contributing to Better Auth!---
title: Telemetry
description: Better Auth now collects anonymous telemetry data about general usage.
---

Better Auth collects anonymous usage data to help us improve the project. This is optional, transparent, and disabled by default.

## Why is telemetry collected?

Since v1.3.5, Better Auth collects anonymous telemetry data about general usage if enabled.

Telemetry data helps us understand how Better Auth is being used across different environments so we can improve performance, prioritize features, and fix issues more effectively. It guides our decisions on performance optimizations, feature development, and bug fixes. All data is collected completely anonymously and with privacy in mind, and users can opt out at any time. We strive to keep what we collect as transparent as possible.

## What is being collected?

The following data points may be reported. Everything is anonymous and intended for aggregate insights only.

- **Anonymous identifier**: A non-reversible hash derived from your project (`package.json` name and optionally `baseURL`). This lets us de‑duplicate events per project without knowing who you are.
- **Runtime**: `{ name: "node" | "bun" | "deno", version }`.
- **Environment**: one of `development`, `production`, `test`, or `ci`.
- **Framework (if detected)**: `{ name, version }` for frameworks like Next.js, Nuxt, React Router, Astro, SvelteKit, etc.
- **Database (if detected)**: `{ name, version }` for integrations like PostgreSQL, MySQL, SQLite, Prisma, Drizzle, MongoDB, etc.
- **System info**: platform, OS release, architecture, CPU count/model/speed, total memory, and flags like `isDocker`, `isWSL`, `isTTY`.
- **Package manager**: `{ name, version }` derived from the npm user agent.
- **Redacted auth config snapshot**: A minimized, privacy‑preserving view of your `betterAuth` options produced by `getTelemetryAuthConfig`.

We also collect anonymous telemetry from the CLI:

- **CLI generate (`cli_generate`)**: outcome `generated | overwritten | appended | no_changes | aborted` plus redacted config.
- **CLI migrate (`cli_migrate`)**: outcome `migrated | no_changes | aborted | unsupported_adapter` plus adapter id (when relevant) and redacted config.


<Callout type="info">
  You can audit telemetry locally by setting the `BETTER_AUTH_TELEMETRY_DEBUG=1` environment variable when running your project or by setting `telemetry: { debug: true }` in your auth config. In this debug mode, telemetry events are logged only to the console.

  ```ts title="auth.ts"
  export const auth = betterAuth({
    // [!code highlight]
    telemetry: { // [!code highlight]
      debug: true // [!code highlight]
    } // [!code highlight]
  });
  ```
</Callout>

## How is my data protected?

All collected data is fully anonymous and only useful in aggregate. It cannot be traced back to any individual source and is accessible only to a small group of core Better Auth maintainers to guide roadmap decisions.

- **No PII or secrets**: We do not collect emails, usernames, tokens, secrets, client IDs, client secrets, or database URLs.
- **No full config**: We never send your full `betterAuth` configuration. Instead we send a reduced, redacted snapshot of non‑sensitive toggles and counts.
- **Redaction by design**: See [detect-auth-config.ts](https://github.com/better-auth/better-auth/blob/canary/packages/telemetry/src/detectors/detect-auth-config.ts) in the Better Auth source for the exact shape of what is included. It purposely converts sensitive values to booleans, counts, or generic identifiers.

## How can I enable it?

You can enable telemetry collection in your auth config or by setting an environment variable.

- Via your auth config.

  ```ts title="auth.ts"
  export const auth = betterAuth({
    // [!code highlight]
    telemetry: { // [!code highlight]
      enabled: true// [!code highlight]
    } // [!code highlight]
  });
  ```

- Via an environment variable.

  ```txt title=".env"
  # Enable telemetry
  BETTER_AUTH_TELEMETRY=1

  # Disable telemetry
  BETTER_AUTH_TELEMETRY=0
  ```


### When is telemetry sent?

- On `betterAuth` initialization (`type: "init"`).
- On CLI actions: `generate` and `migrate` as described above.

Telemetry is disabled automatically in tests (`NODE_ENV=test`) unless explicitly overridden by internal tooling.
---
title: Security
description: Better Auth security features.
---

This page contains information about security features of Better Auth.


## Password Hashing

Better Auth uses the `scrypt` algorithm to hash passwords by default. This algorithm is designed to be memory-hard and CPU-intensive, making it resistant to brute-force attacks. You can customize the password hashing function by setting the `password` option in the configuration. This option should include a `hash` function to hash passwords and a `verify` function to verify them.

## Session Management

### Session Expiration

Better Auth uses secure session management to protect user data. Sessions are stored in the database or a secondary storage, if configured, to prevent unauthorized access. By default, sessions expire after 7 days, but you can customize this value in the configuration. Additionally, each time a session is used, if it reaches the `updateAge` threshold, the expiration date is extended, which by default is set to 1 day.

### Session Revocation

Better Auth allows you to revoke sessions to enhance security. When a session is revoked, the user is logged out and can no longer access the application. A logged in user can also revoke their own sessions to log out from different devices or browsers.

See the [session management](/docs/concepts/session-management) for more details.

## CSRF Protection

Better Auth includes multiple safeguards to prevent Cross-Site Request Forgery (CSRF) attacks:

1. **Avoid simple requests**
   See [Avoiding simple requests](https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF#avoiding_simple_requests) for more details. Better Auth only allows requests with a non-simple header or a `Content-Type` header of `application/json`.
   
2. **Origin Validation**
   Each request’s `Origin` header is verified to confirm it comes from your application or another explicitly trusted source. Requests from untrusted origins are rejected. By default, Better Auth trusts the base URL of your app, but you can specify additional trusted origins via the `trustedOrigins` configuration option.

3. **Secure Cookie Settings**
   Session cookies use the `SameSite=Lax` attribute by default, preventing browsers from sending cookies with most cross-site requests. You can override this behavior using the `defaultCookieAttributes` option.

4. **Fetch Metadata Protection for First-Login CSRF**
   Better Auth also uses [Fetch Metadata headers](https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF#fetch_metadata) (`Sec-Fetch-Site`, `Sec-Fetch-Mode`, `Sec-Fetch-Dest`) to provide additional CSRF protection specifically for **first-login scenarios**, where the client does not yet have any cookies.
   
   This protection applies to **sign-in and sign-up email routes**, which accept form submissions (simple requests) to support progressive enhancement patterns.
   
   When a sign-in or sign-up request is received **without** any cookies:
   
   - If the browser indicates a **cross-site navigation** (for example: `Sec-Fetch-Site: cross-site` and `Sec-Fetch-Mode: navigate`), Better Auth **blocks** the request as a potential login CSRF attack.
   
   - If the request is **same-origin** or **same-site**, Better Auth still validates the `Origin`/`Referer` against your `trustedOrigins` configuration, using the existing origin validation logic.
   
   - If the client does **not** send Fetch Metadata headers (older browsers, some mobile WebViews, non-browser clients), Better Auth falls back to its **previous behavior** and only performs origin validation when cookies are present, preserving backward compatibility.
   
   This mechanism allows modern browsers to receive stronger protection against first-login CSRF attacks **without requiring CSRF tokens or client-side JavaScript**, and works seamlessly with progressive enhancement patterns.
   
   <Callout type="info">
     Non-browser HTTP clients (mobile apps, server-to-server) should set the `Origin` or `Referer` header appropriately when making requests that include cookies. This ensures proper CSRF validation regardless of Fetch Metadata support.
   </Callout> 

5. **No Mutations on GET Requests (with additional safeguards)**
  `GET` requests are assumed to be read-only and should not alter the application's state. In cases where a `GET` request must perform a mutation—such as during OAuth callbacks - Better Auth applies extra security measures, including validating `nonce` and `state` parameters to ensure the request's authenticity.

### Disabling Security Checks

Better Auth provides two separate options to disable security checks. These options control different aspects of security:

#### `disableCSRFCheck`

Disables **all CSRF protection**, including:
- Origin header validation when cookies are present
- Fetch Metadata checks (`Sec-Fetch-Site`, `Sec-Fetch-Mode`, `Sec-Fetch-Dest`)
- Cross-site navigation blocking for first-login scenarios

```typescript
{
  advanced: {
    disableCSRFCheck: true
  }
}
```

<Callout type="warning">
  Disabling CSRF checks allows requests from any origin to use cookies and perform actions on behalf of users. This opens your application to CSRF attacks.
</Callout>

#### `disableOriginCheck`

Disables **URL validation** against `trustedOrigins`, including:
- `callbackURL` validation
- `redirectTo` validation
- `errorCallbackURL` validation
- `newUserCallbackURL` validation

```typescript
{
  advanced: {
    disableOriginCheck: true
  }
}
```

<Callout type="warning">
  Disabling origin checks allows any URL to be used in redirects and callbacks. This opens your application to open redirect vulnerabilities.
</Callout>

<Callout type="info">
  For backward compatibility, `disableOriginCheck: true` also disables CSRF protection. If you only want to disable URL validation without affecting CSRF protection, this is not currently possible - both checks are disabled together when using this option.
</Callout>

#### Summary

| Option | What it disables |
|--------|-----------------|
| `disableCSRFCheck` | CSRF protection only (origin header validation, Fetch Metadata checks) |
| `disableOriginCheck` | URL validation AND CSRF protection (for backward compatibility) |

## OAuth State and PKCE

To secure OAuth flows, Better Auth stores the OAuth state and PKCE (Proof Key for Code Exchange) in the database. The state helps prevent CSRF attacks, while PKCE protects against code injection threats. Once the OAuth process completes, these values are removed from the database.

## Cookies

Better Auth assigns secure cookies by default when the base URL uses `https`. These secure cookies are encrypted and only sent over secure connections, adding an extra layer of protection. They are also set with the `sameSite` attribute to `lax` by default to prevent cross-site request forgery attacks. And the `httpOnly` attribute is enabled to prevent client-side JavaScript from accessing the cookie. 

For Cross-Subdomain Cookies, you can set the `crossSubDomainCookies` option in the configuration. This option allows cookies to be shared across subdomains, enabling seamless authentication across multiple subdomains.

### Customizing Cookies

You can customize cookie names to minimize the risk of fingerprinting attacks and set specific cookie options as needed for additional control. For more information, refer to the [cookie options](/docs/concepts/cookies).

Plugins can also set custom cookie options to align with specific security needs. If you're using Better Auth in non-browser environments, plugins offer ways to manage cookies securely in those contexts as well.

## Rate Limiting

Better Auth includes built-in rate limiting to safeguard against brute-force attacks. Rate limits are applied across all routes by default, with specific routes subject to stricter limits based on potential risk.

## IP Address Headers

Better Auth uses client IP addresses for rate limiting and security monitoring. By default, it reads the IP address from the standard `X-Forwarded-For` header. However, you can configure a specific trusted header to ensure accurate IP address detection and prevent IP spoofing attacks.

You can configure the IP address header in your Better Auth configuration:

```typescript
{
  advanced: {
    ipAddress: {
      ipAddressHeaders: ['cf-connecting-ip'] // or any other custom header
    }
  }
}
```

This ensures that Better Auth only accepts IP addresses from your trusted proxy's header, making it more difficult for attackers to bypass rate limiting or other IP-based security measures by spoofing headers.

<Callout type="info">
**Important**

- When setting a custom IP address header, ensure that your proxy or load balancer is properly configured to set this header, and that it cannot be set by end users directly.
- In dev/test environments, if the IP cannot be retrieved from headers, 127.0.0.1 is used as a fallback.
</Callout>

## Trusted Proxy Headers

If your application runs behind a reverse proxy or load balancer, Better Auth can derive the base URL from the inbound request's `X-Forwarded-Host` and `X-Forwarded-Proto` headers. This is useful when your app is accessible from multiple domains (e.g. `example.com` and `app.example.dev`) and you don't want to hardcode a single `baseURL` in the configuration.

When `trustedProxyHeaders` is enabled and no `baseURL` is set in the configuration (or via environment variables), Better Auth uses the forwarded headers to construct the base URL on each request. This means OAuth callbacks, email verification links, and redirects will automatically use whichever domain the user loaded the app on.

```typescript
{
  advanced: {
    trustedProxyHeaders: true
  }
}
```

<Callout type="warning">
Only enable this option if you trust the proxy headers reaching your application. Your reverse proxy or load balancer must be configured to set `X-Forwarded-Host` and `X-Forwarded-Proto` correctly, and end users must not be able to set these headers directly. If untrusted clients can forge these headers, they could manipulate redirects and callback URLs.
</Callout>

When enabled, the base URL resolution follows this priority:

1. Static `baseURL` from the configuration (if set, proxy headers are ignored)
2. Environment variables (`BETTER_AUTH_URL`, `NEXT_PUBLIC_BETTER_AUTH_URL`, etc.)
3. `X-Forwarded-Host` + `X-Forwarded-Proto` headers (when `trustedProxyHeaders` is `true`)
4. The request URL origin as a final fallback

If you're serving your app from multiple approved domains, you'll typically want to:
- **Omit `baseURL`** from the configuration so it's derived per-request from the proxy headers
- Set **`trustedOrigins`** to an allowlist of your approved domains (see below)
- Leave `crossSubDomainCookies` disabled — cookies are host-only by default, which means each domain gets its own independent session

## Trusted Origins

Trusted origins prevent CSRF attacks and block open redirects. You can set a list of trusted origins in the `trustedOrigins` configuration option. Requests from origins not on this list are automatically blocked.

### Basic Usage

The most basic usage is to specify exact origins:

```typescript
{
  trustedOrigins: [
    "https://example.com",
    "https://app.example.com",
    "http://localhost:3000"
  ]
}
```

### Wildcard Origins

Better Auth supports wildcard patterns in trusted origins, which allows you to trust multiple subdomains with a single entry:

```typescript
{
  trustedOrigins: [
    "*.example.com",             // Trust all subdomains of example.com (any protocol)
    "https://*.example.com",     // Trust only HTTPS subdomains of example.com
    "http://*.dev.example.com"   // Trust all HTTP subdomains of dev.example.com
  ]
}
```

#### Protocol-specific wildcards

When using a wildcard pattern with a protocol prefix (like `https://`):
- The protocol must match exactly
- The domain can have any subdomain in place of the `*`
- Requests using a different protocol will be rejected, even if the domain matches

#### Protocol-agnostic wildcards

When using a wildcard pattern without a protocol prefix (like `*.example.com`):
- Any protocol (http, https, etc.) will be accepted
- The domain must match the wildcard pattern

### Custom Schemes

Trusted origins also support custom schemes for mobile apps and browser extensions:

```typescript
{
  trustedOrigins: [
    "myapp://",                               // Mobile app scheme
    "chrome-extension://YOUR_EXTENSION_ID",   // Browser extension
    "exp://**",                               // Trust all Expo development URLs
    "exp://10.0.0.*:*/**",                    // Trust 10.0.0.x IP range with any port
  ]
}
```

### Dynamic origin list

You can also dynamically set the list of trusted origins by providing a function that returns it:

```typescript
{
  trustedOrigins: async (request) => {
    const trustedOrigins = await queryTrustedDomains();
    return trustedOrigins;
  }
}
```

<Callout>
**Important**: This function will be invoked per incoming request, so be careful if you decide to dynamically fetch your list of trusted domains.
</Callout>

## Reporting Vulnerabilities

If you discover a security vulnerability in Better Auth, please report it to us at [security@better-auth.com](mailto:security@better-auth.com). We address all reports promptly, and credits will be given for validated discoveries.
---
title: FAQ
description: Frequently asked questions about Better Auth.
---

This page contains frequently asked questions, common issues, and other helpful information about Better Auth.

<Accordions>
  <Accordion id="auth-client-not-working" title="Auth client not working">
  When encountering `createAuthClient` related errors, make sure to have the correct import path as it varies based on environment.

If you're using the auth client on react front-end, you'll need to import it from `/react`:

```ts title="component.ts"
import { createAuthClient } from "better-auth/react";
```

Where as if you're using the auth client in Next.js middleware, server-actions, server-components or anything server-related, you'll likely need to import it from `/client`:

```ts title="server.ts"
import { createAuthClient } from "better-auth/client";
```

</Accordion>

<Accordion id="getsession-not-working" title="getSession not working">
If you try to call `authClient.getSession` on a server environment (e.g, a Next.js server component), it doesn't work since it can't access the cookies. You can use the `auth.api.getSession` instead and pass the request headers to it. 

```tsx title="server.tsx"
import { auth } from "./auth";
import { headers } from "next/headers";

const session = await auth.api.getSession({
    headers: await headers()
})
```

if you need to use the auth client on the server for different purposes, you still can pass the request headers to it:

```tsx title="server.tsx"
import { authClient } from "./auth-client";
import { headers } from "next/headers";

const session = await authClient.getSession({
    fetchOptions:{
      headers: await headers()
    }
})
```
</Accordion>

<Accordion id="corporate-proxy-configuration" title="How to configure a corporate proxy for server-side requests">
If you need to configure a corporate proxy for Better Auth's outbound requests (e.g., OAuth provider requests), you can use undici's ProxyAgent to set up a global fetch proxy.

```typescript title="auth.ts"
import { betterAuth } from "better-auth";
import { ProxyAgent, setGlobalDispatcher } from "undici";

const proxyAgent = new ProxyAgent("http://your-proxy.example.com:8080");
setGlobalDispatcher(proxyAgent);

export const auth = betterAuth({
  // your configuration
});
```

Since Better Auth runs on the server side, you have full control over Node.js's fetch behavior through undici's global dispatcher. This approach allows all outbound requests from Better Auth to go through your corporate proxy.

<Callout type="info">
  Learn more about undici ProxyAgent in the [undici documentation](https://github.com/nodejs/undici/blob/main/docs/docs/api/ProxyAgent.md).
</Callout>
</Accordion>

<Accordion id="adding-custom-fields-to-the-users-table" title="Adding custom fields to the users table">

Better Auth provides a type-safe way to extend the user and session schemas, take a look at our docs on <Link href="/docs/concepts/database#extending-core-schema">extending core schema</Link>.

</Accordion>

<Accordion id="difference-between-getsession-and-usesession" title="Difference between getSession and useSession">
Both `useSession` and `getSession` instances are used fundamentally different based on the situation.

`useSession` is a hook, meaning it can trigger re-renders whenever session data changes.

If you have UI you need to change based on user or session data, you can use this hook.

<Callout type="warn">
  For performance reasons, do not use this hook on your `layout.tsx` file. We
  recommend using RSC and use your server auth instance to get the session data
  via `auth.api.getSession`.
</Callout>

`getSession` returns a promise containing data and error.

For all other situations where you shouldn't use `useSession`, is when you should be using `getSession`.

<Callout type="info">
   `getSession` is available on both server and client auth instances.
   Not just the latter.
</Callout>
</Accordion>

<Accordion id="common-typescript-errors" title="Common TypeScript Errors">
If you're facing typescript errors, make sure your tsconfig has `strict` set to `true`:
```json title="tsconfig.json"
{
  "compilerOptions": {
    "strict": true,
  }
}
```

if you can't set strict to true, you can enable strictNullChecks:
```json title="tsconfig.json"
{
  "compilerOptions": {
    "strictNullChecks": true,
  }
}
```

You can learn more in our <Link href="/docs/concepts/typescript#typescript-config">TypeScript docs</Link>.
</Accordion>
<Accordion id="can-i-remove-name-image-or-email-fields-from-the-user-table" title="Can I remove `name`, `image`, or `email` fields from the user table?">
At this time, you can't remove the `name`, `image`, or `email` fields from the user table.

We do plan to have more customizability in the future in this regard, but for now, you can't remove these fields.
</Accordion>

<Accordion id="dual-module-hazard-issue" title="Dual Module Hazard Issue">
If you're encountering errors like:

```
No request state found. Please make sure you are calling this function within a `runWithRequestState` callback.
```

This is typically caused by a **dual module hazard** - when multiple versions of `better-auth` or `@better-auth/core` exist in your dependency tree. This commonly occurs after upgrading to v1.4+, especially in Cloudflare Workers, Nuxt, or when using plugins like `oauthProvider`.

### How to Diagnose

Check if you have duplicate versions of Better Auth packages:

```bash
# For pnpm users
pnpm why @better-auth/core
pnpm why better-auth

# For npm users
npm ls @better-auth/core
npm ls better-auth

# For yarn users
yarn why @better-auth/core
yarn why better-auth
```

If you see multiple versions listed, you have a dual module hazard.

### How to Fix

#### Basic Steps

Start by ensuring your dependencies are clean and all Better Auth packages use compatible versions.

<Callout type="tip">
**Clean reinstall:**

```bash
# Remove node_modules and lockfile
rm -rf node_modules
rm pnpm-lock.yaml # or package-lock.json or yarn.lock

# Reinstall dependencies
pnpm install # or npm install or yarn install
```

Check your `package.json` and make sure all Better Auth related packages (`better-auth`, `@better-auth/core`, `@better-auth/oauth-provider`, etc.) are using compatible versions.
</Callout>

#### Package Manager Resolution Issues

If you're using Yarn v1 (Classic) or potentially other package managers like pnpm v9, you may need to force `better-call` to resolve to a single instance.

<Callout type="warn">
**For Yarn v1 / pnpm v9 users:**

Manually install `better-call` and add it to both `dependencies` and `resolutions` to force it to be hoisted to the top level:

```json title="package.json"
{
  "dependencies": {
    "better-call": "^1.1.8",
    // ... other dependencies
  },
  "resolutions": {
    "better-call": "^1.1.8"
  }
}
```

Then reinstall your dependencies:

```bash
yarn install # or pnpm install
```

Note: Yarn v3 and pnpm v10 don't typically have this issue.
</Callout>

<Callout type="error">
**Important:** Make sure to install `better-auth` and related packages in `dependencies`, not `devDependencies`.
</Callout>

#### Bundler Resolution Issues

This is a bundler-level issue where the same module gets resolved to different instances. The goal is to make your bundler resolve the module to the same instance.

<Callout type="info">
**For Next.js users:**

Add `better-auth` to `serverExternalPackages` in your `next.config.js`:

```ts title="next.config.js"
const config = {
  serverExternalPackages: ['better-auth']
};
```
</Callout>

<Callout type="info">
**For Cloudflare Workers users:**

Make sure you have the `nodejs_compat` compatibility flag enabled in your `wrangler.toml`:

```toml title="wrangler.toml"
compatibility_flags = ["nodejs_compat"]
```
</Callout>

#### Verify the Fix

Run the diagnostic commands again to confirm only one version of each package exists:

```bash
pnpm why @better-auth/core
pnpm why better-auth
pnpm why better-call
```

You should see only one version listed for each package.

<Callout type="info">
  Related issues: [#6613](https://github.com/better-auth/better-auth/issues/6613), [yjs#438](https://github.com/yjs/yjs/issues/438)
</Callout>
</Accordion>
</Accordions>
---
title: Options
description: Better Auth configuration options reference.
---

List of all the available options for configuring Better Auth. See [Better Auth Options](https://github.com/better-auth/better-auth/blob/main/packages/core/src/types/init-options.ts).

## `appName`

The name of the application.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	appName: "My App",
})
```

## `baseURL`

Base URL for Better Auth. This is typically the root URL where your application server is hosted. Note: If you include a path in the baseURL, it will take precedence over the default path.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	baseURL: "https://example.com",
})
```

If not explicitly set, the system will check for the environment variable `BETTER_AUTH_URL`. If that's also not set, it will be inferred from the incoming request.

<Callout type="warn">
Relying on request inference is not recommended. For security and stability, always set `baseURL` explicitly in your config or via the `BETTER_AUTH_URL` environment variable.
</Callout>

## `basePath`

Base path for Better Auth. This is typically the path where the Better Auth routes are mounted. It will be overridden if there is a path component within `baseURL`.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	basePath: "/api/auth",
})
```

Default: `/api/auth`

## `trustedOrigins`

List of trusted origins. You can provide a static array of origins, a function that returns origins dynamically, or use wildcard patterns to match multiple domains.

### Static Origins

You can provide a static array of origins:

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	trustedOrigins: ["http://localhost:3000", "https://example.com"],
})
```

### Dynamic Origins

You can provide a function that returns origins dynamically:

```ts
export const auth = betterAuth({
	trustedOrigins: async (request) => {
		// request is undefined during initialization and auth.api calls
		if (!request) {
			return ["https://my-frontend.com"];
		}
		// Dynamic logic based on the request
		return ["https://dynamic-origin.com"];
	}
})
```

<Callout type="info">
  The `request` parameter is `undefined` during initialization and when calling `auth.api` directly. Make sure to handle this case by returning default trusted origins.
</Callout>

### Wildcard Support

You can use wildcard patterns in trusted origins:

```ts
export const auth = betterAuth({
	trustedOrigins: [
		"https://*.example.com", // trust all HTTPS subdomains of example.com
		"http://*.dev.example.com" // trust all HTTP subdomains of dev.example.com
	]
})
```

#### Pattern Syntax

| Pattern | Description |
|---------|-------------|
| `?` | Matches exactly one character (except `/`) |
| `*` | Matches zero or more characters that don't cross `/` |
| `**` | Matches zero or more characters including `/` |

#### Pattern Examples

| Pattern | Matches | Does Not Match |
|---------|---------|----------------|
| `http://*.example.com` | `http://api.example.com`<br/>`http://app.example.com`<br/>`http://api.app.example.com` | `https://api.example.com`<br/>`http://example.com` |
| `https://**.example.com` | `https://api.example.com`<br/>`https://api.app.example.com` | `http://api.example.com` |
| `https://example.com` | `https://example.com`<br/>`https://example.com/path` | `https://api.example.com`<br/>`http://example.com` |
| `exp://192.168.*.*:*/**` | `exp://192.168.1.100:8081/path`<br/>`exp://192.168.50.200:19000/auth/callback` | `exp://10.0.0.29:8081/path` |
| `myapp://` | All URLs starting with `myapp://` | - |


<Callout type="info">
**Notes**

- For `http://` and `https://` URLs, patterns match the full origin. Paths and query strings are ignored.
- For custom schemes (like `exp://` or `myapp://`), patterns match against the full URL including paths when wildcards are present, or use prefix matching when no wildcards exist.
- The separator is `/` (forward slash). This means `http://*.example.com` matches both `http://api.example.com` and `http://api.app.example.com`.
</Callout>

## `secret`

The secret used for encryption, signing, and hashing.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	secret: "your-secret-key",
})
```

By default, Better Auth will look for the following environment variables:
- `process.env.BETTER_AUTH_SECRET`
- `process.env.AUTH_SECRET`

If none of these environment variables are set, it will default to `"better-auth-secret-123456789"`. In production, if it's not set, it will throw an error.

You can generate a good secret using the following command:

```bash
openssl rand -base64 32
```

## `database`

Database configuration for Better Auth.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	database: {
		dialect: "postgres",
		type: "postgres",
		casing: "camel"
	},
})
```

Better Auth supports various database configurations including [PostgreSQL](/docs/adapters/postgresql), [MySQL](/docs/adapters/mysql), and [SQLite](/docs/adapters/sqlite).

Read more about databases [here](/docs/concepts/database).

## `secondaryStorage`

Secondary storage configuration used to store session and rate limit data.

```ts
import { betterAuth } from "better-auth";

export const auth = betterAuth({
	// ... other options
    secondaryStorage: {
    	// Your implementation here
    },
})
```

Read more about secondary storage [here](/docs/concepts/database#secondary-storage).

## `emailVerification`

Email verification configuration.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	emailVerification: {
		sendVerificationEmail: async ({ user, url, token }) => {
			// Send verification email to user
		},
		sendOnSignUp: true,
		autoSignInAfterVerification: true,
		expiresIn: 3600 // 1 hour
	},
})
```

- `sendVerificationEmail`: Function to send verification email
- `sendOnSignUp`: Send verification email automatically after sign up. `true` always sends, `false` never sends, `undefined` follows `requireEmailVerification` behavior (default: `undefined`)
- `sendOnSignIn`: Send verification email automatically on sign in when the user's email is not verified (default: `false`)
- `autoSignInAfterVerification`: Auto sign in the user after they verify their email
- `expiresIn`: Number of seconds the verification token is valid for (default: `3600` seconds)

## `emailAndPassword`

Email and password authentication configuration.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	emailAndPassword: {
		enabled: true,
		disableSignUp: false,
		requireEmailVerification: true,
		minPasswordLength: 8,
		maxPasswordLength: 128,
		autoSignIn: true,
		sendResetPassword: async ({ user, url, token }) => {
			// Send reset password email
		},
		resetPasswordTokenExpiresIn: 3600, // 1 hour
		password: {
			hash: async (password) => {
				// Custom password hashing
				return hashedPassword;
			},
			verify: async ({ hash, password }) => {
				// Custom password verification
				return isValid;
			}
		}
	},
})
```

- `enabled`: Enable email and password authentication (default: `false`)
- `disableSignUp`: Disable email and password sign up (default: `false`)
- `requireEmailVerification`: Require email verification before a session can be created
- `minPasswordLength`: Minimum password length (default: `8`)
- `maxPasswordLength`: Maximum password length (default: `128`)
- `autoSignIn`: Automatically sign in the user after sign up
- `sendResetPassword`: Function to send reset password email
- `onPasswordReset`: Callback triggered when a user's password is changed successfully
- `revokeSessionsOnPasswordReset`: Revoke all other sessions when resetting password (default: `false`)
- `resetPasswordTokenExpiresIn`: Number of seconds the reset password token is valid for (default: `3600` seconds)
- `onExistingUserSignUp`: Callback triggered when someone signs up with an already-registered email. Only called when `requireEmailVerification` is `true` or `autoSignIn` is `false` (default: `undefined`).
- `password`: Custom password hashing and verification functions

## `socialProviders`

Configure social login providers.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	socialProviders: {
		google: {
			clientId: "your-client-id",
			clientSecret: "your-client-secret",
			redirectURI: "https://example.com/api/auth/callback/google"
		},
		github: {
			clientId: "your-client-id",
			clientSecret: "your-client-secret",
			redirectURI: "https://example.com/api/auth/callback/github"
		}
	},
})
```

- `clientId`: OAuth client ID from the provider
- `clientSecret`: OAuth client secret from the provider
- `clientKey`: Client key (used by some providers like TikTok instead of clientId) (optional)
- `redirectURI`: Custom redirect URI for the OAuth callback (optional)
- `scope`: Additional OAuth scopes to request (optional)
- `mapProfileToUser`: Custom function to map the provider profile to a user (optional)
- `disableSignUp`: Disable sign up for new users (optional)
- `disableImplicitSignUp`: Disable implicit sign up for new users (optional)
- `overrideUserInfoOnSignIn`: Override user info with provider user info on sign in (optional)
- `prompt`: The prompt to use for the authorization code request (`"select_account"`, `"consent"`, `"login"`, `"none"`, `"select_account consent"`) (optional)
- `responseMode`: The response mode to use (`"query"`, `"form_post"`) (optional)
- `getUserInfo`: Custom function to get user info from the provider (optional)
- `refreshAccessToken`: Custom function to refresh a token (optional)
- `verifyIdToken`: Custom function to verify the ID token (optional)
- `disableIdTokenSignIn`: Disable sign in with ID token sent from the client (optional)
- `disableDefaultScope`: Disable the provider's default scopes (optional)
- `authorizationEndpoint`: Custom authorization endpoint URL (optional)

## `plugins`

List of Better Auth plugins.

```ts
import { betterAuth } from "better-auth";
import { emailOTP } from "better-auth/plugins";

export const auth = betterAuth({
	plugins: [
		emailOTP({
			sendVerificationOTP: async ({ email, otp, type }) => {
				// Send OTP to user's email
			}
		})
	],
})
```

## `user`

User configuration options.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	user: {
		modelName: "users",
		fields: {
			email: "emailAddress",
			name: "fullName"
		},
		additionalFields: {
			customField: {
				type: "string",
			}
		},
		changeEmail: {
			enabled: true,
			sendChangeEmailConfirmation: async ({ user, newEmail, url, token }) => {
				// Send change email confirmation to the old email
			},
			updateEmailWithoutVerification: false // Update email without verification if user is not verified
		},
		deleteUser: {
			enabled: true,
			sendDeleteAccountVerification: async ({ user, url, token }) => {
				// Send delete account verification
			},
			beforeDelete: async (user) => {
				// Perform actions before user deletion
			},
			afterDelete: async (user) => {
				// Perform cleanup after user deletion
			}
		}
	},
})
```

- `modelName`: The model name for the user (default: `"user"`)
- `fields`: Map fields to different column names
- `additionalFields`: Additional fields for the user table
- `changeEmail`: Configuration for changing email
- `deleteUser`: Configuration for user deletion

## `session`

Session configuration options.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	session: {
		modelName: "sessions",
		fields: {
			userId: "user_id"
		},
		expiresIn: 604800, // 7 days
		updateAge: 86400, // 1 day
		disableSessionRefresh: true, // Disable session refresh so that the session is not updated regardless of the `updateAge` option. (default: `false`)
		additionalFields: { // Additional fields for the session table
			customField: {
				type: "string",
			}
		},
		storeSessionInDatabase: true, // Store session in database when secondary storage is provided (default: `false`)
		preserveSessionInDatabase: false, // Preserve session records in database when deleted from secondary storage (default: `false`)
		cookieCache: {
			enabled: true, // Enable caching session in cookie (default: `false`)	
			maxAge: 300 // 5 minutes
		}
	},
})
```

- `modelName`: The model name for the session (default: `"session"`)
- `fields`: Map fields to different column names
- `expiresIn`: Expiration time for the session token in seconds (default: `604800` - 7 days)
- `updateAge`: How often the session should be refreshed in seconds (default: `86400` - 1 day)
- `additionalFields`: Additional fields for the session table
- `storeSessionInDatabase`: Store session in database when secondary storage is provided (default: `false`)
- `preserveSessionInDatabase`: Preserve session records in database when deleted from secondary storage (default: `false`)
- `cookieCache`: Enable caching session in cookie

## `account`

Account configuration options.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	account: {
		modelName: "accounts",
		fields: {
			userId: "user_id"
		},
		encryptOAuthTokens: true, // Encrypt OAuth tokens before storing them in the database
		storeAccountCookie: true, // Store account data after OAuth flow in a cookie (useful for database-less flows)
		accountLinking: {
			enabled: true,
			trustedProviders: ["google", "github", "email-password"], // or async (request) => ["google", "github"]
			allowDifferentEmails: false
		}
	},
})
```

- `modelName`: The model name for the account
- `fields`: Map fields to different column names

### `encryptOAuthTokens`

Encrypt OAuth tokens before storing them in the database. Default: `false`.

### `updateAccountOnSignIn`

If enabled (true), the user account data (accessToken, idToken, refreshToken, etc.)
will be updated on sign in with the latest data from the provider.

### `storeAccountCookie`

Store account data after OAuth flow in a cookie. This is useful for database-less flows where you want to store account information (access tokens, refresh tokens, etc.) in a cookie instead of the database.

- Default: `false`
- Automatically set to `true` if no database is provided

### `accountLinking`

Configuration for account linking.

- `enabled`: Enable account linking (default: `true`)
- `trustedProviders`: List of trusted providers. Can be a static array or an async function that returns providers dynamically based on the request (similar to `trustedOrigins`)
- `allowDifferentEmails`: Allow users to link accounts with different email addresses
- `allowUnlinkingAll`: Allow users to unlink all accounts

## `verification`

Verification configuration options.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	verification: {
		modelName: "verifications",
		fields: {
			userId: "user_id"
		},
		disableCleanup: false
	},
})
```

- `modelName`: The model name for the verification table
- `fields`: Map fields to different column names
- `disableCleanup`: Disable cleaning up expired values when a verification value is fetched

## `rateLimit`

Rate limiting configuration.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	rateLimit: {
		enabled: true,
		window: 10,
		max: 100,
		customRules: {
			"/example/path": {
				window: 10,
				max: 100
			}
		},
		storage: "memory",
		modelName: "rateLimit"
	}
})
```

- `enabled`: Enable rate limiting (defaults: `true` in production, `false` in development)
- `window`: Time window to use for rate limiting. The value should be in seconds. (default: `10`)
- `max`: The default maximum number of requests allowed within the window. (default: `100`)
- `customRules`: Custom rate limit rules to apply to specific paths.
- `storage`: Storage configuration. If you passed a secondary storage, rate limiting will be stored in the secondary storage. (options: `"memory", "database", "secondary-storage"`, default: `"memory"`)
- `modelName`: The name of the table to use for rate limiting if database is used as storage. (default: `"rateLimit"`)


## `advanced`

Advanced configuration options.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	advanced: {
		ipAddress: {
			ipAddressHeaders: ["x-client-ip", "x-forwarded-for"],
			disableIpTracking: false
		},
		useSecureCookies: true,
		disableCSRFCheck: false,
		disableOriginCheck: false,
		crossSubDomainCookies: {
			enabled: true,
			additionalCookies: ["custom_cookie"],
			domain: "example.com"
		},
		cookies: {
			session_token: {
				name: "custom_session_token",
				attributes: {
					httpOnly: true,
					secure: true
				}
			}
		},
		defaultCookieAttributes: {
			httpOnly: true,
			secure: true
		},
		// OAuth state configuration has been moved to account option
		// Use account.storeStateStrategy and account.skipStateCookieCheck instead
		cookiePrefix: "myapp",
		database: {
			// Use your own custom ID generator,
			// disable generating IDS so your database will generate them,
			// or use "serial" to use your database's auto-incrementing ID, or "uuid" to use a random UUID.
			generateId: (((options: {
				model: LiteralUnion<Models, string>;
				size?: number;
			}) => {
				return "my-super-unique-id";
			})) | false | "serial" | "uuid",
			defaultFindManyLimit: 100,
			experimentalJoins: false,
		},
		skipTrailingSlashes: true
	},
})
```

- `ipAddress`: IP address configuration for rate limiting and session tracking
- `useSecureCookies`: Use secure cookies (default: `false`)
- `disableCSRFCheck`: Disable all CSRF protection including origin header validation and Fetch Metadata checks (⚠️ security risk)
- `disableOriginCheck`: Disable URL validation for `callbackURL`, `redirectTo`, and other redirect URLs (⚠️ security risk)
- `crossSubDomainCookies`: Configure cookies to be shared across subdomains
- `cookies`: Customize cookie names and attributes
- `defaultCookieAttributes`: Default attributes for all cookies
- `cookiePrefix`: Prefix for cookies
- `database`: Database configuration options
- `skipTrailingSlashes`: Skip trailing slash validation in route matching. (default: `false`)
- OAuth state configuration options (`storeStateStrategy`, `skipStateCookieCheck`) are now part of the `account` option

## `logger`

Logger configuration for Better Auth.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	logger: {
		disabled: false,
		disableColors: false,
		level: "warn",
		log: (level, message, ...args) => {
			// Custom logging implementation
			console.log(`[${level}] ${message}`, ...args);
		}
	}
})
```

The logger configuration allows you to customize how Better Auth handles logging. It supports the following options:

- `disabled`: Disable all logging when set to `true` (default: `false`)
- `disableColors`: Disable colors in the default logger implementation (default: determined by the terminal's color support)
- `level`: Set the minimum log level to display (default: `"warn"`)
  - `"debug"`: Show all logs including debug information
  - `"info"`: Show all logs except debug information
  - `"warn"`: Show warnings and errors
  - `"error"`: Show only errors
- `log`: Custom logging function that receives:
  - `level`: The log level
  - `message`: The log message
  - `...args`: Additional arguments passed to the logger

Example with custom logging:

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	logger: {
		level: "info",
		log: (level, message, ...args) => {
			// Send logs to a custom logging service
			myLoggingService.log({
				level,
				message,
				metadata: args,
				timestamp: new Date().toISOString()
			});
		}
	}
})
```

## `databaseHooks`

Database lifecycle hooks for core operations.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	databaseHooks: {
		user: {
			create: {
				before: async (user) => {
					// Modify user data before creation
					return { data: { ...user, customField: "value" } };
				},
				after: async (user) => {
					// Perform actions after user creation
				}
			},
			update: {
				before: async (userData) => {
					// Modify user data before update
					return { data: { ...userData, updatedAt: new Date() } };
				},
				after: async (user) => {
					// Perform actions after user update
				}
			}
		},
		session: {
			// Session hooks
		},
		account: {
			// Account hooks
		},
		verification: {
			// Verification hooks
		}
	},
})
```

## `onAPIError`

API error handling configuration.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	onAPIError: {
		throw: true,
		onError: (error, ctx) => {
			// Custom error handling
			console.error("Auth error:", error);
		},
		errorURL: "/auth/error",
		customizeDefaultErrorPage: {
			colors: {
				background: "#ffffff",
				foreground: "#000000",
				primary: "#0070f3",
				primaryForeground: "#ffffff",
				mutedForeground: "#666666",
				border: "#e0e0e0",
				destructive: "#ef4444",
				titleBorder: "#0070f3",
				titleColor: "#000000",
				gridColor: "#f0f0f0",
				cardBackground: "#ffffff",
				cornerBorder: "#0070f3"
			},
			size: {
				radiusSm: "0.25rem",
				radiusMd: "0.5rem",
				radiusLg: "1rem",
				textSm: "0.875rem",
				text2xl: "1.5rem",
				text4xl: "2.25rem",
				text6xl: "3.75rem"
			},
			font: {
				defaultFamily: "system-ui, sans-serif",
				monoFamily: "monospace"
			},
			disableTitleBorder: false,
			disableCornerDecorations: false,
			disableBackgroundGrid: false
		}
	},
})
```

- `throw`: Throw an error on API error (default: `false`)
- `onError`: Custom error handler
- `errorURL`: URL to redirect to on error (default: `/api/auth/error`)
- `customizeDefaultErrorPage`: Configure the default error page provided by Better Auth. Start your dev server and go to `/api/auth/error` to see the error page.
  - `colors`: Customize color scheme for the error page
    - `background`: Background color
    - `foreground`: Foreground/text color
    - `primary`: Primary accent color
    - `primaryForeground`: Text color on primary background
    - `mutedForeground`: Muted text color
    - `border`: Border color
    - `destructive`: Error/destructive color
    - `titleBorder`: Border color for the title
    - `titleColor`: Title text color
    - `gridColor`: Background grid color
    - `cardBackground`: Card background color
    - `cornerBorder`: Corner decoration border color
  - `size`: Customize sizing and spacing
    - `radiusSm`: Small border radius
    - `radiusMd`: Medium border radius
    - `radiusLg`: Large border radius
    - `textSm`: Small text size
    - `text2xl`: 2xl text size
    - `text4xl`: 4xl text size
    - `text6xl`: 6xl text size
  - `font`: Customize font families
    - `defaultFamily`: Default font family
    - `monoFamily`: Monospace font family
  - `disableTitleBorder`: Disable the border around the title (default: `false`)
  - `disableCornerDecorations`: Disable corner decorations (default: `false`)
  - `disableBackgroundGrid`: Disable the background grid pattern (default: `false`)

## `hooks`

Request lifecycle hooks.

```ts
import { betterAuth } from "better-auth";
import { createAuthMiddleware } from "better-auth/api";

export const auth = betterAuth({
	hooks: {
		before: createAuthMiddleware(async (ctx) => {
			// Execute before processing the request
			console.log("Request path:", ctx.path);
		}),
		after: createAuthMiddleware(async (ctx) => {
			// Execute after processing the request
			console.log("Response:", ctx.context.returned);
		})
	},
})
```

For more details and examples, see the [Hooks documentation](/docs/concepts/hooks).

## `disabledPaths`

Disable specific auth paths.

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
	disabledPaths: ["/sign-up/email", "/sign-in/email"],
})
```

## `telemetry`

Enable or disable Better Auth's telemetry collection. (default: `false`)

```ts
import { betterAuth } from "better-auth";
export const auth = betterAuth({
  telemetry: {
    enabled: false,
  }
})
```
---
title: Resources
description: A curated collection of resources to help you learn and master Better Auth.
---

import { Resource } from "@/components/resource-section";

A curated collection of resources to help you learn and master Better Auth. From blog posts to video tutorials, find everything you need to get started.

## Video tutorials 

<Resource resources={
    [
		{
			title: "10 Better Auth plugins that just save so much time",
			description: "<strong>Dreams of Code</strong> showcases a comprehensive list of Better Auth plugins that can save you a lot of time.",
			href: "https://www.youtube.com/watch?v=CpBgjjnXuy4",
			tags: ["trends", "showcase", "review"],
		},
		{
			title: "The State of Authentication",
			description:
				"<strong>Theo(t3.gg)</strong> explores the current landscape of authentication, discussing trends, challenges, and where the industry is heading.",
			href: "https://www.youtube.com/watch?v=lxslnp-ZEMw",
			tags: ["trends", "showcase", "review"],
		},
		{
			title: "Last Authentication You Will Ever Need",
			description:
				"A comprehensive tutorial demonstrating why Better Auth could be the final authentication solution you'll need for your projects.",
			href: "https://www.youtube.com/watch?v=hFtufpaMcLM",
			tags: ["implementation", "showcase"],
		},
		{
			title: "This Might Be My New Favourite Auth Library",
			description:
				"<strong>developedbyed</strong> explores the features and capabilities of Better Auth, explaining why it stands out among authentication libraries.",
			href: "https://www.youtube.com/watch?v=Hjs3zM7o7NE",
			tags: ["review", "showcase"],
		},
	 	{
			title: "8 Reasons To Try Better Auth",
			description:
				"<strong>CJ</strong> presents 8 compelling reasons why Better Auth is the BEST auth framework he's ever used, demonstrating its superior features and ease of implementation.",
			href: "https://www.youtube.com/watch?v=_OApmLmex14",
			tags: ["review", "showcase", "implementation"],
		},
		{
			title: "Better Auth is so good that I almost switched programming languages",
			description:
				"<strong>Dreams of Code</strong> reviews Better Auth's features that nearly made them switch languages.",
			href: "https://www.youtube.com/watch?v=dNY4FKXwTsM",
			tags: ["review", "showcase", "implementation"],
		},
		{
			title: "Best authentication framework for next.js",
			description:
				"A detailed comparison of authentication frameworks for Next.js, highlighting why Better Auth might be your best choice.",
			href: "https://www.youtube.com/watch?v=V--T0q9FrEw",
			tags: ["nextjs", "comparison"],
		},
		{
			title: "Better-Auth: A First Look",
			description:
				"An introductory overview and demonstration of Better Auth's core features and capabilities.",
			href: "https://www.youtube.com/watch?v=2cQTV6NYxis",
			tags: ["implementation", "showcase"],
		},
		{
			title: "Stripe was never so easy (with better auth)",
			description: "A tutorial on how to integrate Stripe with Better Auth.",
			href: "https://www.youtube.com/watch?v=g-RIrzBEX6M",
			tags: ["implementation"],
		},
		{
			title: "Nextjs 15 Authentication Made EASY with Better Auth",
			description:
				"A practical guide showing how to seamlessly integrate Better Auth with Next.js 15 for robust authentication.",
			href: "https://www.youtube.com/watch?v=lxslnp-ZEMw",
			tags: ["nextjs", "implementation", "tutorial"],
		},
		{
			title: "Better Auth: Headless Authentication for Your TanStack Start App",
			description: "<strong>Jack</strong> demonstrates how to implement headless authentication in your TanStack Start application using Better Auth, providing a modern approach to auth.",
			href: "https://www.youtube.com/watch?v=Atev8Nxpw7c", 
			tags: ["tanstack", "implementation"],
		},
		{
			title: "Goodbye Clerk, Hello Better Auth – Full Migration Guide!",
			description: "A comprehensive guide showing how to migrate your authentication from Clerk to Better Auth, with step-by-step instructions and best practices.",
			href: "https://www.youtube.com/watch?v=Za_QihbDSuk",
			tags: ["migration", "clerk", "tutorial"],
		},
    ]
} />

## Blog posts

<Resource resources={
    [
        {
			title: "Better Auth with Hono, Bun, TypeScript, React and Vite",
			description:
				"You'll learn how to implement authentication with Better Auth in a client - server architecture, where the frontend is separate from the backend.",
			href: "https://catalins.tech/better-auth-with-hono-bun-typescript-react-vite",
			tags: ["typescript", "react", "bun", "vite"],
		},
		{
			title: "Polar.sh + BetterAuth for Organizations",
			description:
				"Polar.sh is a platform for building payment integrations. This article will show you how to use Better Auth to authenticate your users.",
			href: "https://dev.to/phumudzosly/polarsh-betterauth-for-organizations-1j1b",
			tags: ["organizations", "integration", "payments"],
		},
		{
			title: "Authenticating users in Astro with Better Auth",
			description:
				"Step by step guide on how to authenticate users in Astro with Better Auth.",
			href: "https://www.launchfa.st/blog/astro-better-auth",
			tags: ["astro", "integration", "tutorial"],
		},
		{
			title: "Building Multi-Tenant Apps With Better-Auth and ZenStack",
			description:
				"Learn how to build multi-tenant apps with Better-Auth and ZenStack.",
			href: "https://zenstack.dev/blog/better-auth",
			tags: ["multi-tenant", "zenstack", "architecture"],
		},
    ]
} />---
title: oauth_provider_not_found
description: The OAuth provider was not found.
---

## What is it?

This error occurs when Better Auth cannot identify a provider for the callback path—either because the provider
segment is missing or because no provider with that id is configured.

Better Auth expects the callback route to be shaped like `/api/auth/callback/<provider>`.
If the `<provider>` segment is absent (e.g., request hits `/api/auth/callback`),
we cannot determine which integration should handle the callback and the
request is rejected.

## Common Causes

* Visiting `/api/auth/callback` directly without the trailing provider segment.

## How to resolve

### Use the correct callback route shape

* Ensure your application exposes a callback route like `/api/auth/callback/[provider]` (framework-specific).
* When initiating the OAuth flow, ensure the redirect URI includes the provider segment so the provider
  returns to `/api/auth/callback/<provider>`.

### Configure infrastructure to preserve the path

* Check proxy/CDN rewrites (Vercel, Cloudflare, Nginx) to make sure they do not strip the final path segment.
* Align trailing slash behavior across environments so that `/api/auth/callback/<provider>` is preserved.

### Avoid manual access to the base callback route

* Do not navigate to `/api/auth/callback` directly; always start OAuth via Better Auth APIs which generate
  the correct provider-specific callback URL.

## Debug locally

* Inspect the request URL received by your server to confirm the `<provider>` segment is present.
* Log router/path parameters in your callback handler to verify the provider value.
* Compare environment configs (routes, basePath, rewrites) to ensure the same path structure is used everywhere.

## Edge cases to consider

* Trailing slash normalization may alter routing if your framework treats `/callback/google/` differently
  from `/callback/google`. Configure consistent behavior.---
title: signup_disabled
description: Signup disabled error
---

This error occurs when you disable sign up in your oauth provider config and a user tries to sign up with that provider.

## How to fix

If you're using the `disableSignUp` option with stateless mode, you will see this error. Please consider using database hooks instead to handle this case.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { APIError } from "better-auth/api";

export const auth = betterAuth({
  databaseHooks: {
    user: {
      create: {
        before: async (user, ctx) => {
          const isAllowedToSignUp = await isAllowedToSignUp(user, ctx); // [!code highlight] // check if the user is allowed to sign up
          if (!isAllowedToSignUp) {
            throw new APIError("BAD_REQUEST", {
              message: "Signup is disabled",
			});
          },
        },
      },
	},
  }
});
```---
title: email_not_found
description: The provider did not return an email address.
---

## What is it?

This error occurs during the OAuth flow when the provider does not return an email address for the user. 
Better Auth uses the email from the provider to identify or create a user account. If the provider omits 
the email (or returns it as empty/undefined), we cannot proceed and the request is rejected.

This error is only possible through OAuth providers. It will not occur in non-OAuth flows.

## Common Causes

* Missing or insufficient scopes in the provider configuration (e.g., not requesting `email`).
* The user's email is private or not exposed by default (e.g., GitHub private email).
* The provider returns email only via a separate endpoint and the scope/API call to fetch it was not enabled 
  (e.g., GitHub `user:email`).
* Provider project or tenant misconfiguration (consent screen, admin consent, restricted claims/attributes).
* Using different credentials between environments (preview/staging/prod) that do not request the same scopes.

## How to resolve

### Request the correct scopes

* Ensure your provider configuration requests the email-related scopes.

### Verify provider app/dashboard settings

* In the provider's dashboard, confirm the app has permission to request email and the consent screen allows it.

### Debug locally

* Inspect the outgoing authorize request to confirm the scopes include `email` where required.
* Inspect the callback payload (query, `id_token` claims, userinfo response) to see if an email claim exists.
* Log the provider profile object received by your callback handler to verify whether `email` is present.
* Check which environment's provider credentials are in use and whether scopes differ across environments.---
title: no_code
description: The code was not found in the request.
---

## What is it?

This error occurs during the OAuth callback when the authorization code is missing from the request.
In the Authorization Code flow, the provider redirects back to your `/api/auth/callback` route with a
`code` parameter (and typically `state`). Without the `code`, Better Auth cannot exchange it for tokens,
so the request is rejected.

## Common Causes

* The OAuth flow was not started correctly (wrong response type or custom URL missing required params).
* The provider returned an error instead of a code (e.g., user canceled consent), so only `error`/`error_description` are present.
* Query parameters were stripped by a reverse proxy, CDN, or framework rewrite.
* Callback URL mismatch at the provider caused an intermediate redirect that dropped query parameters.
* Mobile/WebView or deep-link handoff opened a new context that lost the query string.
* Using a response mode your handler does not read (e.g., form_post body vs query parameters).

## How to resolve

### Use the standard Authorization Code flow

* Start the flow through Better Auth so the provider receives the correct parameters and the app expects a `code`.
* In the provider settings, ensure your app is configured for Authorization Code (with PKCE where applicable).

### Verify callback URL and parameter delivery

* Confirm the provider's configured redirect URI exactly matches your `/api/auth/callback` route (protocol, host, path).
* Ensure infrastructure (proxies, rewrites, middleware) preserves the full query string and does not redirect in ways that drop parameters.

## Debug locally

* In DevTools → Network, inspect the callback request and verify whether `code` or `error` parameters are present.
* Log the raw query/body received by the callback handler during development to see exactly what arrived.
* Compare dev/staging/prod credentials and redirect URIs to ensure they are consistent across environments.
---
title: Unknown error
description: An unknown error occurred.
---

{/* 
    This page is intentionally not listed in the errors index.
    It's a fallback for unknown errors.
*/}

If you're seeing this page, it means that an unknown error occurred.
Please try again or return to the home page. 

If you believe this error comes from Better Auth core functionality or a plugin,
please open an issue on [GitHub](https://github.com/better-auth/better-auth/issues).

To view all known errors, please visit the [Error Codes Reference](/docs/reference/errors) page.---
title: Errors
description: Errors that can occur in Better Auth.
---

This section contains all the errors that cause you to be redirected to the `/api/auth/error` page. 

## List of errors

- [invalid_callback_request](/docs/reference/errors/invalid_callback_request)
- [state_not_found](/docs/reference/errors/state_not_found)
- [state_mismatch](/docs/reference/errors/state_mismatch)
- [no_code](/docs/reference/errors/no_code)
- [no_callback_url](/docs/reference/errors/no_callback_url)
- [oauth_provider_not_found](/docs/reference/errors/oauth_provider_not_found)
- [email_not_found](/docs/reference/errors/email_not_found)
- [email_doesn't_match](/docs/reference/errors/email_doesn't_match)
- [unable_to_get_user_info](/docs/reference/errors/unable_to_get_user_info)
- [unable_to_link_account](/docs/reference/errors/unable_to_link_account)
- [account_already_linked_to_different_user](/docs/reference/errors/account_already_linked_to_different_user)
- [signup_disabled](/docs/reference/errors/signup_disabled)---
title: invalid_callback_request
description: The callback request is invalid.
---

## What is it?

This error is thrown during the OAuth callback when the incoming request cannot be parsed or is missing
required fields. 

## Common Causes

* Query or body parameters were stripped by a reverse proxy, CDN, or framework rewrite.
* Double-encoding or improper URL encoding of parameters causes parsing to fail.
* Callback URL mismatch at the provider triggers an intermediate redirect that drops parameters.
* Middleware or route grouping sends the request to a different handler than intended.
* Very long URLs get truncated by an intermediary (rare but possible with some proxies).

## How to resolve

### Verify callback method and parameters

* Ensure your provider is configured to use the method your route expects (commonly GET with query parameters for Authorization Code flow).
* Confirm the callback includes required parameters (e.g., `code` and `state` for standard OAuth flows).

### Preserve query/body through infrastructure

* Check that reverse proxies (Vercel, Cloudflare, Nginx) and app rewrites forward the full query string and request body intact.
* If middleware intercepts or rewrites the callback, make sure it forwards all parameters without modification.

### Debug locally

* In DevTools → Network, inspect the callback request and verify parameters are present and well-formed.
* Compare dev/staging/prod credentials to ensure there are no environment differences causing different flows or endpoints.

### Edge cases to consider

* Mobile/WebView or deep-link flows can drop query parameters during handoff.
* Some providers can return parameters in fragments; your server will not receive fragments—ensure the provider uses query/body for server-side callbacks.
* Multiple redirects (including HTTP → HTTPS) can lose parameters if not configured correctly.

<Callout type="info">
    Callback parameters are normally handled automatically by Better Auth. If this error appears, it often
    indicates manual access to the `/api/auth/callback` route, a proxy/redirect that stripped parameters,
    or an integration mismatch. Double-check provider settings and infrastructure rewrites to ensure the
    full request reaches the callback unchanged.
</Callout>---
title: state_mismatch
description: The state parameter in the request doesn't match the state parameter in the cookie.
---

## What is it?

When an OAuth flow begins, a unique `state` value is generated and stored in a cookie.
After the user returns from the OAuth provider, this `state` is compared with the one provided in the callback.
If they don't match, the request is rejected to prevent unauthorized access.

This check exists to prevent CSRF (Cross-Site Request Forgery) and replay attacks during the OAuth flow -
basically, to make sure the callback that hits your `/api/auth/callback` endpoint really belongs to the
same browser session that started it.


## Common Causes

* The cookie wasn't set or readable during callback (common with `.vercel.app` preview domains or cross-domain issues).
* The cookie domain/path doesn't match between your app and callback route.
* The browser blocked third-party cookies (especially on Safari / iOS).
* You started the OAuth flow in one tab but finished it in another (different cookie context).
* The preview vs production domain mismatch (e.g., `preview.myapp.com` vs `myapp.com`).

## How to resolve
### Use a constant domain

* The best fix is to use a constant domain for your app and callback route.
* Avoid `.vercel.app` subdomains - browsers treat them as public suffixes, so cookies can't be shared across subdomains.

### Verify cookie configurations

* It's possible that you've configured custom cookie attributes in your auth config that can cause this issue.
* Check that cookies are not blocked by browser settings or privacy modes.
* Ensure you're starting and ending the OAuth flow in the same browser session.

### Skip state cookie check

If you know what you are doing, you can skip the state cookie check by
setting the `account.skipStateCookieCheck` option to `true` in your auth config.

<Callout type="warn">
  Please note that this is a security risk and should only be enabled if you know what you are doing.
</Callout>

### Production Debug

Head to your production site, and use your browser's DevTools → Application → Cookies to confirm:

* The state cookie is being set before redirect.
* It still exists when the OAuth provider redirects back.---
title: email_doesn't_match
description: The email doesn't match the email of the account.
---

## What is it?

This error appears only during OAuth account linking. It happens when a signed-in user tries to
link an OAuth provider account, but the email returned by the provider does not match the email
on the currently authenticated user (or the email you expect for that user). To prevent
accidental cross-account linking or account takeover, Better Auth blocks the link when emails do
not align.

This does not occur during normal OAuth sign-in; it is specific to the linking flow.

## Common Causes

* The user is logged into the provider with a different email (e.g., work vs personal).
* The provider returns an unverified or secondary email that differs from the app account email.
* Email normalization differences (case sensitivity, dots/aliases on Gmail) cause a mismatch.
* The user's email changed in your app or at the provider since the original account was created.

## How to resolve

### Ask the user to align identities

* Have the user switch to the correct provider account that uses the same email as their app account.
* Alternatively, update the app account email to the intended email (if your product allows it) and retry linking.

### Debug locally

* Log the current user's email in your app and the email returned by the provider profile.
* Inspect whether the provider email is verified/primary and whether any normalization is applied.
* Confirm which provider credentials (dev/staging/prod) are in use and that the returned identity is the expected one.
---
title: unable_to_link_account
description: The account could not be linked.
---

## What is it?

This error occurs only during an OAuth flow when attempting to link the provider account to the
currently authenticated user. Better Auth blocks the operation if either:

1) The database operation to create/update the linked account fails.
2) The provider is not considered trusted for linking based on your auth configuration
   (`account.accountLinking.trustedProviders`).

## Common Causes

* The provider is not listed in `account.accountLinking.trustedProviders`.
* Configuration differs across environments (dev/staging/prod), so the provider appears untrusted in one environment.
* Database write failed due to unique constraint, foreign key violation, or transaction/connection issues.
* A race condition linking the same provider concurrently caused a conflict.
* Pending migrations or a mismatched schema between services caused the write to fail.

## How to resolve

### Allow linking for the intended provider

* Add the provider id (e.g., `github`, `google`) to `account.accountLinking.trustedProviders` in your auth config.
* Verify you are using the correct provider id/slug that your integration expects.

### Fix database reliability and constraints

* Run pending migrations and ensure the schema matches the current Better Auth version.
* Investigate DB errors (deadlocks, timeouts, connection pool limits) and retry if appropriate.

### Verify environment configuration

* Ensure the same auth config is deployed to all environments and that environment variables are loaded as expected.
* Double-check that the runtime sees the intended `trustedProviders` list.

---
title: account_already_linked_to_different_user
description: The account is already linked to a different user.
---

## What is it?

This error occurs during the OAuth flow when attempting to link an OAuth provider account 
to the currently authenticated user, but that exact provider account is already linked to 
another user in your project. To prevent account takeover, Better Auth blocks the link and 
throws this error.

This situation is only possible through the OAuth flow (e.g., Google, GitHub, etc.). It is 
not triggered by email/password flows on their own.

## How to resolve

### Typical resolutions

* Log in as the user who already has the provider linked, unlink the provider from that account, 
  then link it to the intended account.
* If both accounts belong to the same person and you want a single user, merge the accounts: choose 
  a primary user, move sessions and linked accounts from the secondary user to the primary, then 
  deactivate or delete the secondary.

### Common Causes

* You previously signed in or signed up using this provider on a different user in the same project.
* You have two local users (e.g., created via email/password or magic link) and you linked the provider 
  to one of them; now you are trying to link the same provider to the other.
* Test/preview environments share the same OAuth provider configuration and database; the provider account 
  is already linked to a different user record.
* Data migration or manual database edits left a stale link pointing to the wrong user.
* You rely on email matching to decide linking, but the actual unique key is the provider account identifier 
  (e.g., `providerId` + `accountId`). If that mapping exists for another user, linking will be blocked.

### Safer patterns and prevention

* Avoid automatically linking a provider to whichever user is currently signed in unless you explicitly 
  confirm ownership with the user.
* If you provide a 'Connect account' UI, clearly communicate which user will receive the link and what to do 
  if the provider is already linked elsewhere.
* Consider disabling linking for providers you only want to use for sign-in, to avoid accidental cross-linking.

### Debug locally

* Inspect your `account` database table. You should see rows keyed by 
  `providerId` (e.g., 'google') and `accountId` (e.g., OIDC `sub`), pointing to a `userId`.
* Identify which user currently owns the provider link and decide whether to unlink, merge, or keep as-is.
* Verify your app is connected to the expected database and environment (dev/staging/prod) to avoid confusion 
  due to shared credentials or misconfigured environment variables.

### Provider considerations

* Ensure you request stable user identifiers from the provider (e.g., OIDC `openid` scope) so `accountId` 
  remains consistent across sessions.
* If you changed provider projects/tenants, identifiers may differ; confirm you are linking the correct provider 
  credentials for the environment.

<Callout type="info">
  This error is a security safeguard. It prevents an OAuth identity that already belongs to one user 
  from being attached to another user without explicit action. If a legitimate merge is intended, perform 
  a controlled merge or unlink-then-link flow rather than bypassing the check.
</Callout>
---
title: unable_to_get_user_info
description: The user info was not found in the request.
---

## What is it?

This error occurs only on the `/api/auth/callback` endpoint during an OAuth flow. After exchanging
the authorization code for tokens, Better Auth fetches the user's profile from the provider. If the
provider response is incorrect, empty, or missing required fields (like id or email when needed),
no usable user info can be derived and the request is rejected.

## Common Causes

* Missing or insufficient scopes, so the provider does not return profile data.
* The provider returned an error or an empty profile object for the user info request.
* Token exchange succeeded, but the user info request failed (network error, 401/403, invalid token).
* Provider configuration or environment mismatch (wrong client/tenant), causing unexpected or minimal claims.
* Temporary provider outage or rate limiting.

## How to resolve

### Request the right data

* Start the OAuth flow using Better Auth methods so the correct scopes and parameters are used.
* Ensure your provider app is configured to return basic profile details needed by your app.

### Verify configuration and environment

* Confirm the client credentials and callback URL match the environment you are testing (dev/staging/prod).
* If the provider supports different response modes or endpoints, ensure they align with the integration you use.
---
title: no_callback_url
description: The callback URL was not found in the request.
---

## What is it?

This error occurs during the OAuth flow when the request reaches your `/api/auth/callback` endpoint
but the `state` data does not contain a callback URL.
Better Auth stores metadata in `state` when the flow starts, including where to redirect after a
successful sign-in/link. If that URL is missing at callback time, we cannot safely continue.

## Common Causes

* The OAuth flow was not started via Better Auth APIs, so the `state` payload never included a callback URL.
* A reverse proxy, CDN, or middleware altered the flow, causing the app to read a different or empty `state`.

## How to resolve

### Start the flow through Better Auth

* Always initiate OAuth using Better Auth's built-in methods so `state` is generated with the needed fields.
---
title: state_not_found
description: The state parameter was not found in the request.
---

## What is it?

During the OAuth callback, Better Auth expects a `state` value to be present on the incoming request. 
This `state` is originally generated when the OAuth flow starts and is sent to the provider. When the 
provider redirects back to your app, it should include the same `state` value in the callback request.
If the `state` is missing entirely in the callback request (query or body), 
we cannot validate the flow and the request is rejected.

This check prevents CSRF and replay attacks by ensuring the callback belongs to the same browser session 
that initiated the flow.

## Common Causes

* You navigated directly to `/api/auth/callback` without starting an OAuth flow first.
* A reverse proxy, CDN, or rewrite stripped query or body parameters from the callback request.
* The OAuth provider was not given a `state` on the authorize request (custom/manual flow overriding parameters).
* The callback URL registered at the provider does not match your actual callback route, causing an intermediate 
  redirect that drops query or body parameters.
* The callback reached a different route/handler than expected due to framework routing or middleware, and the 
  handler is not reading the query or body you think it is.
* Mobile/WebView or deep-link handoff opened a new context that lost the original query string.

## How to resolve

### Start the flow via Better Auth APIs

Always initiate OAuth through Better Auth so we can generate and send `state` correctly. Avoid manually hitting 
callback endpoints or constructing authorize URLs unless you fully mirror Better Auth's parameters.

### Verify the callback URL and method

* Ensure the provider's configured callback URL exactly matches your app's `/api/auth/callback` route (including 
  protocol and domain).
* Most providers redirect via GET with query parameters. If you have custom handlers or methods, confirm the 
  handler reads the query/body consistent with your provider's redirect.

### Check proxies, rewrites, and middleware

* Confirm that any reverse proxies (Vercel, Cloudflare, Nginx) and app-level rewrites preserve the full query 
  string (including `state`).
* If you have middleware that redirects or rewrites the callback path, ensure it forwards query & body parameters intact.

### Debug locally

Use your browser DevTools → Network to inspect the callback request:

* Confirm the callback URL includes `?state=...` (or that the request body contains `state` if you expect one).
* Verify the authorize request was sent earlier from the same session and that a `state` cookie exists prior to 
  the redirect back.
* Log request query/body fields in your callback handler during local debugging to confirm what is actually 
  received by the server.

### Edge cases to consider

* Preview vs production domains can behave differently if extra redirects or rewrites occur.
* Mobile/WebView environments and deep links can drop or alter query parameters during handoff.
---
title: Installation
description: Learn how to configure Better Auth in your project.
---

<Steps>

<Step>
### Install the Package

Let's start by adding Better Auth to your project:

```package-install
better-auth
```

<Callout type="info">
If you're using a separate client and server setup, make sure to install Better Auth in both parts of your project.
</Callout>
</Step>

<Step>
### Set Environment Variables

Create a `.env` file in the root of your project and add the following environment variables:

1. **Secret Key**

A secret value used for encryption and hashing. It must be at least 32 characters and generated with high entropy. Click the button below to generate one. You can also use `openssl rand -base64 32` to generate one.

```txt title=".env"
BETTER_AUTH_SECRET=
```

<GenerateSecret />

2. **Set Base URL**

```txt title=".env"
BETTER_AUTH_URL=http://localhost:3000 # Base URL of your app
```

</Step>

<Step>
### Create A Better Auth Instance

Create a file named `auth.ts` in one of these locations:

- Project root
- `lib/` folder
- `utils/` folder

You can also nest any of these folders under `src/`, `app/` or `server/` folder. (e.g. `src/lib/auth.ts`, `app/lib/auth.ts`).

And in this file, import Better Auth and create your auth instance. Make sure to export the auth instance with the variable name `auth` or as a `default` export.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  //...
});
```

</Step>

<Step>
### Configure Database

Better Auth requires a database to store user data.
You can easily configure Better Auth to use SQLite, PostgreSQL, or MySQL, and more!

<Callout>
    You can also configure Better Auth to work in a stateless mode if you don't configure a database. See [Stateless Session Management](/docs/concepts/session-management#stateless-session-management) for more information. Note that most plugins will require a database.
</Callout>

<Tabs items={["sqlite", "postgres", "mysql"]}>
    <Tab value="sqlite">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import Database from "better-sqlite3";

    export const auth = betterAuth({
        database: new Database("./sqlite.db"),
    })
    ```
    </Tab>
    <Tab value="postgres">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { Pool } from "pg";

    export const auth = betterAuth({
        database: new Pool({
            // connection options
        }),
    })
    ```
    </Tab>
    <Tab value="mysql">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { createPool } from "mysql2/promise";

    export const auth = betterAuth({
        database: createPool({
            // connection options
        }),
    })
    ```
    </Tab>

</Tabs>

Alternatively, if you prefer to use an ORM, you can use one of the built-in adapters.

<Tabs items={["drizzle", "prisma", "mongodb"]}>

    <Tab value="drizzle">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { drizzleAdapter } from "better-auth/adapters/drizzle";
    import { db } from "@/db"; // your drizzle instance

    export const auth = betterAuth({
        database: drizzleAdapter(db, {
            provider: "pg", // or "mysql", "sqlite"
        }),
    });
    ```
    </Tab>
    <Tab value="prisma">
        ```ts title="auth.ts"
        import { betterAuth } from "better-auth";
        import { prismaAdapter } from "better-auth/adapters/prisma";
        // If your Prisma file is located elsewhere, you can change the path
        import { PrismaClient } from "@/generated/prisma/client";

        const prisma = new PrismaClient();
        export const auth = betterAuth({
            database: prismaAdapter(prisma, {
                provider: "sqlite", // or "mysql", "postgresql", ...etc
            }),
        });
    ```
    </Tab>

    <Tab value="mongodb">
    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { mongodbAdapter } from "better-auth/adapters/mongodb";
    import { client } from "@/db"; // your mongodb client

    export const auth = betterAuth({
        database: mongodbAdapter(client),
    });
    ```
    </Tab>

</Tabs>

<Callout>
  If your database is not listed above, check out our other supported
  [databases](/docs/adapters/other-relational-databases) for more information,
  or use one of the supported ORMs.
</Callout>

</Step>

<Step>
    ### Create Database Tables
    Better Auth includes a CLI tool to help manage the schema required by the library.

    - **Generate**: This command generates an ORM schema or SQL migration file.

    <Callout>
    If you're using Kysely, you can apply the migration directly with `migrate` command below. Use `generate` only if you plan to apply the migration manually.
    </Callout>

      ```package-install
      npx auth@latest generate
      ```

    - **Migrate**: This command creates the required tables directly in the database. (Available only for the built-in Kysely adapter)

      ```package-install
      npx auth@latest migrate
      ```

    see the [CLI documentation](/docs/concepts/cli) for more information.

    <Callout>
     If you instead want to create the schema manually, you can find the core schema required in the [database section](/docs/concepts/database#core-schema).
    </Callout>

</Step>

<Step>

### Authentication Methods

Configure the authentication methods you want to use. Better Auth comes with built-in support for email/password, and social sign-on providers.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  //...other options // [!code highlight]
  emailAndPassword: { // [!code highlight]
    enabled: true, // [!code highlight]
  }, // [!code highlight]
  socialProviders: { // [!code highlight]
    github: { // [!code highlight]
      clientId: process.env.GITHUB_CLIENT_ID as string, // [!code highlight]
      clientSecret: process.env.GITHUB_CLIENT_SECRET as string, // [!code highlight]
    }, // [!code highlight]
  }, // [!code highlight]
});
```

<Callout type="info">
You can use even more authentication methods like [passkey](/docs/plugins/passkey), [username](/docs/plugins/username), [magic link](/docs/plugins/magic-link) and more through plugins.
</Callout>
</Step>

<Step>
### Mount Handler
To handle API requests, you need to set up a route handler on your server.

Create a new file or route in your framework's designated catch-all route handler. This route should handle requests for the path `/api/auth/*` (unless you've configured a different base path).

<Callout>
  Better Auth supports any backend framework with standard Request and Response
  objects and offers helper functions for popular frameworks.
</Callout>

<Tabs items={["next-js-app-router", "next-js-pages-router", "nuxt", "svelte-kit", "react-router", "solid-start", "hono", "cloudflare-workers", "express", "elysia", "tanstack-start", "expo"]} defaultValue="next-js-app-router">
    <Tab value="next-js-app-router">
        ```ts title="/app/api/auth/[...all]/route.ts"
        import { auth } from "@/lib/auth"; // path to your auth file
        import { toNextJsHandler } from "better-auth/next-js";

        export const { POST, GET } = toNextJsHandler(auth);
        ```
    </Tab>
    <Tab value="next-js-pages-router">
        ```ts title="/pages/api/auth/[...all].ts"
        import { auth } from "@/lib/auth"; // path to your auth file
        import { toNodeHandler } from "better-auth/node";

        // Disallow body parsing, we will parse it manually
        export const config = { api: { bodyParser: false } };
        export default toNodeHandler(auth.handler);
        ```
    </Tab>
    <Tab value="nuxt">
    ```ts title="/server/api/auth/[...all].ts"
    import { auth } from "~/utils/auth"; // path to your auth file

    export default defineEventHandler((event) => {
        return auth.handler(toWebRequest(event));
    });
    ```
    </Tab>
    <Tab value="svelte-kit">
    ```ts title="hooks.server.ts"
    import { auth } from "$lib/auth"; // path to your auth file
    import { svelteKitHandler } from "better-auth/svelte-kit";
    import { building } from '$app/environment'

    export async function handle({ event, resolve }) {
        return svelteKitHandler({ event, resolve, auth, building });
    }
    ```
    </Tab>
    <Tab value="react-router">
    ```ts title="/app/routes/api.auth.$.ts"
    import { auth } from '~/lib/auth.server' // Adjust the path as necessary
    import type { LoaderFunctionArgs, ActionFunctionArgs } from "react-router" // or "@remix-run/node"

    export async function loader({ request }: LoaderFunctionArgs) {
        return auth.handler(request)
    }

    export async function action({ request }: ActionFunctionArgs) {
        return auth.handler(request)
    }
    ```
    </Tab>
    <Tab value="solid-start">
    ```ts title="/routes/api/auth/*all.ts"
    import { auth } from "~/lib/auth"; // path to your auth file
    import { toSolidStartHandler } from "better-auth/solid-start";

    export const { GET, POST } = toSolidStartHandler(auth);
    ```
    </Tab>
    <Tab value="hono">
    ```ts title="src/index.ts"
    import { Hono } from "hono";
    import { auth } from "./auth"; // path to your auth file
    import { serve } from "@hono/node-server";
    import { cors } from "hono/cors";

    const app = new Hono();

    app.on(["POST", "GET"], "/api/auth/*", (c) => auth.handler(c.req.raw));

    serve(app);
    ```
    </Tab>
    <Tab value="cloudflare-workers">
    ```ts title="src/index.ts"
    import { auth } from "./auth"; // path to your auth file

    export default {
        async fetch(request: Request) {
            const url = new URL(request.url);

            // Handle auth routes
            if (url.pathname.startsWith("/api/auth")) {
                return auth.handler(request);
            }

            // Handle other routes
            return new Response("Not found", { status: 404 });
        },
    };
    ```

    <Callout type="info">
    **Node.js AsyncLocalStorage Support**: Better Auth uses AsyncLocalStorage for async context tracking. To enable this in Cloudflare Workers, add the `nodejs_compat` flag to your `wrangler.toml`:

    ```toml title="wrangler.toml"
    compatibility_flags = ["nodejs_compat"]
    compatibility_date = "2024-09-23"
    ```

    Alternatively, if you only need AsyncLocalStorage support:
    ```toml title="wrangler.toml"
    compatibility_flags = ["nodejs_als"]
    ```

    In the next major release, we will assume AsyncLocalStorage support by default, so this configuration will be necessary.
    </Callout>
    </Tab>

    <Tab value="express">
    <Callout type="warn">
        ExpressJS v5 introduced breaking changes to route path matching by switching to `path-to-regexp@6`. Wildcard routes like `*` should now be written using the new named syntax, e.g. `/{*any}`, to properly capture catch-all patterns. This ensures compatibility and predictable behavior across routing scenarios.
        See the [Express v5 migration guide](https://expressjs.com/en/guide/migrating-5.html) for details.

        As a result, the implementation in ExpressJS v5 should look like this:

        ```ts
        app.all('/api/auth/{*any}', toNodeHandler(auth));
        ```
        *The name any is arbitrary and can be replaced with any identifier you prefer.*
    </Callout>

    ```ts title="server.ts"
    import express from "express";
    import { toNodeHandler } from "better-auth/node";
    import { auth } from "./auth";

    const app = express();
    const port = 8000;

    app.all("/api/auth/*", toNodeHandler(auth));

    // Mount express json middleware after Better Auth handler
    // or only apply it to routes that don't interact with Better Auth
    app.use(express.json());

    app.listen(port, () => {
        console.log(`Better Auth app listening on port ${port}`);
    });
    ```
    This will also work for any other node server framework like express, fastify, hapi, etc., but may require some modifications. See [fastify guide](/docs/integrations/fastify). Note that CommonJS (cjs) isn't supported.
    </Tab>
    <Tab value="astro">
    ```ts title="/pages/api/auth/[...all].ts"
    import type { APIRoute } from "astro";
    import { auth } from "@/auth"; // path to your auth file

    export const GET: APIRoute = async (ctx) => {
        return auth.handler(ctx.request);
    };

    export const POST: APIRoute = async (ctx) => {
        return auth.handler(ctx.request);
    };
    ```
    </Tab>
    <Tab value="elysia">
    ```ts
    import { Elysia, Context } from "elysia";
    import { auth } from "./auth";

    const betterAuthView = (context: Context) => {
        const BETTER_AUTH_ACCEPT_METHODS = ["POST", "GET"]
        // validate request method
        if(BETTER_AUTH_ACCEPT_METHODS.includes(context.request.method)) {
            return auth.handler(context.request);
        } else {
            context.error(405)
        }
    }

    const app = new Elysia().all("/api/auth/*", betterAuthView).listen(3000);

    console.log(
    `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port}`
    );
    ```
    </Tab>
    <Tab value="tanstack-start">
    ```ts title="src/routes/api/auth/$.ts"
    import { auth } from '@/lib/auth'
    import { createFileRoute } from '@tanstack/react-router'

    export const Route = createFileRoute('/api/auth/$')({
        server: {
            handlers: {
                GET: async ({ request }:{ request: Request }) => {
                    return await auth.handler(request)
                },
                POST: async ({ request }:{ request: Request }) => {
                    return await auth.handler(request)
                },
            },
        },
    })
    ```

    <Callout type="info">
    When you call functions that need to set cookies (like `signInEmail` or `signUpEmail`), you'll need to handle cookie setting for TanStack Start. Better Auth provides a `tanstackStartCookies` plugin to automatically handle this for you.

    For React (TanStack Start with React):

    ```ts title="src/lib/auth.ts"
    import { betterAuth } from "better-auth";
    import { tanstackStartCookies } from "better-auth/tanstack-start";

    export const auth = betterAuth({
        //...your config
        plugins: [tanstackStartCookies()] // make sure this is the last plugin in the array
    })
    ```

    For Solid.js (TanStack Start with Solid):

    ```ts title="src/lib/auth.ts"
    import { betterAuth } from "better-auth";
    import { tanstackStartCookies } from "better-auth/tanstack-start/solid";

    export const auth = betterAuth({
        //...your config
        plugins: [tanstackStartCookies()] // make sure this is the last plugin in the array
    })
    ```

    Now, when you call functions that set cookies, they will be automatically set using TanStack Start's cookie handling system.
    </Callout>
    </Tab>
    <Tab value="expo">
    ```ts title="app/api/auth/[...all]+api.ts"
    import { auth } from '@/lib/server/auth'; // path to your auth file

    const handler = auth.handler;
    export { handler as GET, handler as POST };
    ```
    </Tab>

</Tabs>
</Step>

<Step>
### Create Client Instance

The client-side library helps you interact with the auth server. Better Auth comes with a client for all the popular web frameworks, including vanilla JavaScript.

1. Import `createAuthClient` from the package for your framework (e.g., "better-auth/react" for React).
2. Call the function to create your client.
3. Pass the base URL of your auth server. (If the auth server is running on the same domain as your client, you can skip this step.)

<Callout type="info">
  If you're using a different base path other than `/api/auth` make sure to pass
  the whole URL including the path. (e.g.
  `http://localhost:3000/custom-path/auth`)
</Callout>

<Tabs items={["react", "vue", "svelte", "solid",
  "vanilla"]} defaultValue="react">
    <Tab value="vanilla">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/client"
            export const authClient = createAuthClient({
                /** The base URL of the server (optional if you're using the same domain) */ // [!code highlight]
                baseURL: "http://localhost:3000" // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="react" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/react"
            export const authClient = createAuthClient({
                /** The base URL of the server (optional if you're using the same domain) */ // [!code highlight]
                baseURL: "http://localhost:3000" // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="vue" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/vue"
            export const authClient = createAuthClient({
                /** The base URL of the server (optional if you're using the same domain) */ // [!code highlight]
                baseURL: "http://localhost:3000" // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="svelte" title="lib/auth-client.ts">
            ```ts  title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/svelte"
            export const authClient = createAuthClient({
                /** The base URL of the server (optional if you're using the same domain) */ // [!code highlight]
                baseURL: "http://localhost:3000" // [!code highlight]
            })
            ```
    </Tab>
    <Tab value="solid" title="lib/auth-client.ts">
            ```ts title="lib/auth-client.ts"
            import { createAuthClient } from "better-auth/solid"
            export const authClient = createAuthClient({
                /** The base URL of the server (optional if you're using the same domain) */ // [!code highlight]
                baseURL: "http://localhost:3000" // [!code highlight]
            })
            ```
    </Tab>
</Tabs>

<Callout type="info">
Tip: You can also export specific methods if you prefer:
</Callout>
```ts
export const { signIn, signUp, useSession } = createAuthClient()
```
</Step>

<Step>
### 🎉 That's it!
That's it! You're now ready to use better-auth in your application. Continue to [basic usage](/docs/basic-usage) to learn how to use the auth instance to sign in users.
</Step>
</Steps>
